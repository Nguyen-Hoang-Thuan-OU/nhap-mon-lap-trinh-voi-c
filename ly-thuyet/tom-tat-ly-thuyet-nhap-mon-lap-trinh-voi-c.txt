[PHI LỘ]

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Theo phong tục từ xa xưa, ngày khai xuân, khai bút, xuất hành, khai trương mở hàng	│
│	bắt đầu sau năm mới là vô cùng ý nghĩa và quan trọng.					│
│	Chọn được ngày đẹp, giờ tốt để thực hiện sẽ giúp cho mọi công việc, làm ăn suôn sẻ,	│
│	“xuôi chèo mát mái”, “đầu xuôi đuôi lọt”, thuận lợi trong suốt một năm mới.		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

=> Ngày đầu tiên bước vào thế giới lập trình một cách CHUYÊN NGHIỆP.

==========================================================================================

[MỞ ĐẦU - NHỮNG KHÁI NIỆM CƠ BẢN]

	[MÁY TÍNH & CHƯƠNG TRÌNH MÁY TÍNH - COMPUTER & APPLICATION]

Máy tính hỗ trợ con người trong rất nhiều lĩnh vực: hàng không vũ trụ, vận tải, nông nghiệp, y học, truyền thông, học tập, mua sắm và hẹn hò trực tuyến..., khiến cuộc sống của con người trở nên dễ dàng hơn.

------------------------------------------------------------

* Hệ thống (System): Là thứ được sắp xếp, mọi thành phần bên trong được tích hợp lại với nhau để cùng thực hiện một công việc, theo một quy có tắc được định nghĩa trước.

// Vậy, máy tính là gì?

* Máy tính (Computer): từ chỉ chung cho các máy Server, máy tính bảng, điện thoại thông minh, linh kiện thông tin..., tuỳ vào việc phóng to hay thu nhỏ các linh kiện, miễn là bên trong có bộ điều khiển để xử lý dữ liệu một cách tự động.

	- Máy tính là một từ chỉ chung.

		+ Máy tính được sử dụng làm hệ thống điều khiển cho nhiều loại thiết bị công nghiệp và điện tử gia dụng.
	
		+ Máy tính cũng bao gồm các thiết bị có mục đích đặc biệt đơn giản như lò vi sóng và điều khiển từ xa, các thiết bị nhà máy như rô-bốt công nghiệp và thiết kế có sự hỗ trợ của máy tính (CAD), cũng như các thiết bị đa năng như máy tính cá nhân và thiết bị di động như điện thoại thông minh.

----------------------------------------

	* Máy vi tính / Máy tính cá nhân / Máy tính điện tử (Microcomputer / Personal Computer): là máy có khả năng lưu trữ, truy xuất và xử lý dữ liệu (số, văn bản, hình ảnh, âm thanh...) một cách tự động; tương tác với các thiết bị ngoại vi và thực thi chương trình (danh sách các câu lệnh được chứa trong RAM).

	* Hệ thống máy tính (Computer System): bao gồm đầy đủ phần cứng, hệ điều hành (phần mềm chính) và thiết bị ngoại vi.

	* Mạng máy tính / Cụm máy tính / Điện toán cụm (Computer Network / Computer Cluster): một nhóm máy tính được kết nối và hoạt động cùng nhau.

------------------------------------------------------------

* Chương trình máy tính / Nhu liệu (Application): chính xác hơn thì là phần mềm / ứng dụng có thể chạy trên các nền tảng như máy tính cá nhân (desktop, laptop), di động (smartphone, tablet)...

	- Là tập hợp gồm nhiều câu lệnh mà lập trình viên đã viết sẵn (theo một thuật toán) và cất trong hệ điều hành để yêu cầu / chỉ dẫn (instruction) máy tính (cụ thể là CPU) làm một công việc gì đó.
	
	- Mỗi khi người dùng tương tác với hệ điều hành, máy tính chắc chắn sẽ tương tác ngược lại với người dùng theo đúng những "kịch bản" mà lập trình viên đã thiết kế trước đó.

	-> Một chuỗi các câu lệnh và có thể đi kèm với dữ liệu, để máy tính thực hiện nhằm giải quyết nhu cầu của con người.

(Máy tính không thông minh, nếu thiếu đi hệ điều hành thì nó chỉ đơn giản là một đống linh kiện điện tử, vì hệ điều hành là một phần mềm được sử dụng để quản lý toàn bộ hoạt động của máy tính.
Phần mềm do lập trình viên tạo ra mới thông mình, vì nó chính là linh hồn của máy tính, nếu thiếu phần mềm thì mọi thứ trong máy tính đều trở nên vô dụng.)

------------------------------------------------------------

Tổng kết nhanh về máy tính và chương trình:
	- Máy tính giúp thay thế con người và cung cấp khả năng xử lý nhanh chóng, chính xác và hiệu quả.
	- Chương trình sẽ giúp cho máy tính biết phải thực hiện những gì và thực hiện như thế nào.

--------------------------------------------------------------------------------

	[LỊCH SỬ HÌNH THÀNH CỦA MÁY TÍNH]

Trước khi máy tính điện tử ra đời, công cụ được sử dụng sớm nhất và đơn giản nhất để đếm chính là bàn tay và cụ thể là các ngón tay của con người. Sau này, khi số lượng cần đếm gia tăng nhưng số lượng ngón tay (và ngón chân) lại có giới hạn, các đồ vật trong tự nhiên bắt đầu được sử dụng để đếm, chẳng hạn như viên đá, sỏi, vỏ sò, cành cây...

Bắt nguồn từ nhu cầu của các thương gia khi họ cần có cách để lưu giữ số lượng hàng hóa (tồn kho) mà họ đã mua và bán. Bàn tính gảy (Abacus / Suan-Pan / Soroban) là một trong nhiều thiết bị đếm được phát minh để giúp các thương nhân tính toán số lượng lớn (trước đó có bảng đếm Salamis Tablet), loại bàn tính này có khả năng tính toán và lưu trữ trạng thái hiện tại của phép tính.

Trong nhiều năm sau đó, con người tiếp tục phát triển ra nhiều loại thiết bị tính toán khác, thiết bị ra đời sau tất nhiên sẽ tính toán nhanh và chính xác hơn thiết bị trước, từ đó mà cũng giúp giảm sức lao động của con người hơn. Tuy nhiên, tại thời điểm đó, chưa có thiết bị nào được gọi là máy tính (Computer).

Tài liệu sớm nhất ghi chép lại việc sử dụng từ "máy tính" bắt đầu từ năm 1613, nhưng cụm từ này được sử dụng để chỉ chức danh công việc - một người thực hiện các phép tính. Đến cuối những năm 1800, ý nghĩa của "máy tính" mới bắt đầu chuyển sang ám chỉ về những thiết bị.

Một nhà bác học người Anh, Charles Babbage, được xem là cha đẻ của công nghệ máy tính và là người phát minh ra máy tính cơ học đầu tiên. Bên cạnh Máy Khác Biệt / Công cụ Khác biệt / Động cơ Khác biệt (Difference Engine), một cỗ máy phức tạp, cao cấp hơn và có thể lập trình được gọi là Máy Phân tích / Công cụ Phân tích / Động cơ Phân tích (Analytical Engine) do Charles Babbage đề xuất, được xem là khái niệm cho máy tính cơ khí đầu tiên nói chung. Nó được lập trình bằng cách áp dụng hệ thống thẻ đục lỗ (Punched Card) - loại thẻ có nguồn gốc từ Máy dệt Jacquard. Nó thậm chí được đặc trưng bởi một bộ tính toán số học nguyên thủy Unit Arithmetic Logic (ALU) - chúng được tìm thấy trong các CPU và GPU hiện đại ngày, được sử dụng để thực hiện các phép tính số học và toán tử bitwise.
	-> Charles Babbage đã phát minh ra Động cơ Phân tích (Analytical Engine) - máy tính cơ học đầu tiên.

Sau khi Charles Babbage lên ý tưởng cho chiếc máy tính cơ học của ông - Động cơ Phân tích (Analytical Engine), nhiều nơi đã thường mời ông đến để thuyết trình về nó. Mùa thu năm 1840, ông được mời đến thành phố Turin ở phía Tây Bắc nước Ý để đưa ra lời giải thích và bài giảng công khai duy nhất cho một nhóm các nhà khoa học người Ý về Động cơ Phân tích (Analytical Engine). Vị kỹ sư quân sự và nhà toán học người Ý Luigi Menabrea (người sau này trở thành thủ tướng Ý) có tham dự và cũng là người được chọn để viết một báo cáo về bài thuyết trình này. Dưới sự hỗ trợ của Charles Babbage, Luigi Menabrea đã đồng ý viết một ấn phẩm về chiếc máy và xuất bản nó bằng tiếng Pháp trên một tạp chí Thụy Sĩ, mô tả nhiều khía cạnh của kiến trúc và lập trình máy tính. Sau đó, Charles Wheatstone (người đồng phát minh ra máy điện báo) đã đề nghị nhà toán học và nhà văn người Anh, Ada Lovelace (dưới tên Ada Byron), dịch ấn phẩm của Luigi Menabrea từ tiếng Pháp sang tiếng Anh để xuất bản. Do khá thân với Charles Babbage khi từng làm trợ lý cho ông từ trước đó, Ada Lovelace đã có một sự hiểu biết gần như tường tận về cỗ máy, nên bà cũng được đích thân Charles Babbage yêu cầu mở rộng nội dung cho bài viết theo ý thích của bà. Trong bản dịch, với độ dài gấp 3 lần độ dài của bài viết gốc, ngoài việc mở rộng nội dung, bà cũng đưa vào một số thiết kế về thuật toán - bà còn phụ chú một chương gồm nói về cách tính chuỗi số Bernoulli (chuỗi số hữu tỷ thường được sử dụng trong toán học lý thuyết hay số học) bằng cách sử dụng máy tính của Babbage. Bản phụ chú này được xem như là chương trình máy tính đầu tiên từng được xuất bản rộng rãi trong lịch sử; và đó là lý do tại sao Ada Lovelace thường được xem là lập trình viên đầu tiên cho máy tính.
	-> Ada Lovelace đã công bố thuật toán đầu tiên để tính toán chuỗi số Bernoulli bằng cỗ máy Động cơ Phân tích (Analytical Engine) của Charles Babbage.
		(Tham khảo thêm: https://psychclassics.yorku.ca/Lovelace/intro.htm)

Vào cuối thể kỷ 19, các thiết bị tính toán đã được sử dụng cho những mục đích đặc biệt trong khoa học và kỹ thuật, nhưng lại hiếm khi xuất hiện trong chính phủ, kinh doanh hoặc cuộc sống hằng ngày. Tuy nhiên, trong một lần phải đối mặt với những vấn đề trong cuộc điều tra dân số vào năm 1890 của chính phủ Mỹ, Cục điều tra dân số đã tìm đến Herman Hollerith. Herman Hollerith là một nhà thống kê, nhà phát minh và doanh nhân người Mỹ gốc Đức, ông là người đã phát triển ra một loại máy điện cơ được gọi là máy lập bảng / máy chữ đánh bảng (Tabulating Machine) - máy sử dụng các hệ thống cơ học truyền thống để lưu trữ những tính toán. Máy của ông cũng sử dụng các thẻ đục lỗ (Punched Card) để đại diện và lưu trữ thông tin. Các doanh nghiệp bắt đầu nhận thấy giá trị của máy tính cũng như tiềm năng của nó trong việc gia tăng lợi nhuận ở các lĩnh vực có liên quan đến dữ liệu, chẳng hạn như kế toán, bảo hiểm và quản lý hàng tồn kho. Vào năm 1896, ông thành lập công ty Tabulating Machine Company để khai thác thương mại phát minh của mình (và đổi tên thành The Tabulating Machine Company vào năm 1905). Đến năm 1911, công ty của ông cùng 3 tập đoàn lớn khác (Bundy Manufacturing Company, International Time Recording Company và the Computing Scale Company of America) đã hợp nhất (thông qua mua lại cổ phiếu) tại Thành phố New York và hình thành nên công ty mới, lúc đầu có tên là Computing-Tabulating-Recording Company (CTR) nhưng đã được đổi thành International Business Machines (IBM) vào năm 1924.
	-> Herman Hollerith được xem là một trong những cha đẻ của máy tính hiện đại nhờ phát minh máy lập bảng (Tabulating Machine).

Những cổ máy điện cơ kể trên được xem là một thành công lớn, nó thực sự đã thay đổi cách mà chính phủ và thương nghiệp đã vận hành. Cho đến giữa những năm 1900, sự bùng nổ dân số thế giới, cộng với sự gia tăng thương mại toàn cầu đã đòi hỏi nhiều công cụ linh hoạt và nhanh hơn để xử lý dữ liệu. Chính điều này đã tạo nên giai đoạn bùng nổ dành cho máy tính kỹ thuật số.

------------------------------------------------------------

Tham khảo thêm:
	- Khoa học Máy tính (Computer Science):
		+ Tiếng Anh: https://youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo
		+ Tiếng Việt: https://www.youtube.com/playlist?list=PLnRl-W3gZI79kfp8E7lcDkImtMHA6FIfr

	- Lịch sử phần cứng máy tính (History of computing hardware):
		+ Tiếng Anh: https://en.wikipedia.org/wiki/History_of_computing_hardware
		+ Tiếng Việt: https://vi.wikipedia.org/wiki/Lịch_sử_phần_cứng_máy_tính

--------------------------------------------------------------------------------

	[LẬP TRÌNH & NGÔN NGỮ LẬP TRÌNH - ROGRAMMING & PROGRAMMING LANGUAGE]

	---Chiết tự---
	* Lập / Thảo: tạo lập, tạo ra, viết ra một thứ gì đó (cần làm).
	* Trình / Chương:
		- Trong thực tế: hoạt động gồm rất nhiều công việc để đạt được một mục tiêu nào đó.
		- Trong công nghệ thông tin: chương trình máy tính.

		Ví dụ: trong thực tế, một chương trình lễ hội, cần quan tâm:
			- Đề cương chương trình.
			- Hình thức tổ chức.
			- Vật liệt.
			- Tài trợ.
			- Nhân lực.
			- ...
			- Kịch bản chương trình: liệt kê danh sách những thứ cần làm, chẳng hạn như khai mạc, tiết mục, công đoạn, bế mạc,...
				* Người lên kịch bản và chuẩn bị: con người (ban tổ chức).
				* Công cụ hỗ trợ viết kịch bản: bút, giấy, viết, thước kẻ, máy tính, phông nền,...
				* Người thực thi kịch bản: con người (ban tổ chức).
				* Các bước trong kịch bản:
					- Khai mạc.
					- Ca múa.
					- Lễ hội.
					- Nghỉ ngơi.
					- Ăn uống.
					- Bế mạc.
					- ...
				* Người tham dự (trải nghiệm): thành viên, khách mời,...
				* Mục đích: giải quyết và đáp ứng những nhu cầu của con người (thi thố, vui vẻ, tri ân, tưởng nhớ, chia sẻ kiến thức, nâng cao nhận thức,...).

* Lập trình / Thảo chương (Programming): vì máy tính như một "đứa trẻ" nên con người sẽ phải ra lệnh cho máy làm một việc gì đó / chỉ dạy cho máy tính phải làm thế nào.

	- Lập trình viên sẽ giao tiếp với máy tính thông qua những đoạn câu lệnh đã được mã hoá (chỉ hơi gần giống với ngôn ngữ tự nhiên).

	- Tận dụng khả năng xử lý mà không biết mệt mỏi của máy tính, lập trình viên sẽ dạy cho máy tính thực hiện những công việc mà một người có thể làm; giúp giảm sự nhàm chán, tăng tốc độ xử lý, độ chính xác và độ tin cậy.
	
	- Một khi máy tính đã biết phải làm thế nào, nếu người dùng (user) có nhu cầu tương tác với máy tính, máy tính sẽ tương tác ngược lại với người dùng giống hệt với cách mà lập trình viên đã dạy từ trước trong "kịch bản".

	Ví dụ 1: trong thế giới thật, người lớn dạy cho trẻ em: "Phải khoanh tay chào khi gặp người lớn tuổi hơn". Từ đó trở đi, hễ mỗi lần gặp người lớn tuổi, đứa bé đều tự động khoanh tay chào.

	Ví dụ 2: trong thế giới thật, trong môn văn học, mỗi khi đọc thơ/văn thì thầy/cô đều sẽ đọc thêm: "Phẩy", "Xuống hàng", "Gạch nối"... để học sinh chép cho chính xác hơn.

	Ví dụ 3: trong thế giới máy tính, lập trình viên yêu cầu (dạy) máy tính in cho dòng chữ: "Hello World!" một lần duy nhất, máy tính sẽ nhớ vào trong tập tin thực thi (executable - .exe). Kể từ đó, dù đưa file .exe này cho bất kỳ ai thì máy tính đều sẽ thực thi (tái hiện lại) giống hệt những gì đã được lập trình viên dạy.

		-> Lập trình là cách lập trình viên tạo ra (thiết kế) những câu lệnh (kịch bản -> chương trình) có khả năng chạy trên các hệ điều hành và nhờ máy tính thực thi (tái hiện lại) nhằm phục vụ một mục đích nào đó của người dùng (user).
			=> Cách con người sử dụng ngôn ngữ của chính mình để dạy cho một "người nước ngoài" biết cần phải làm gì để thoả mãn được nhu cầu của nhiều người khác.

		(Để viết lên kịch bản và dạy cho máy tính,
		 trước tiên, con người phải hiểu thật rõ bài toán,
		 phải biết cách giải thủ công thì mới có thể hướng dẫn được cho máy tính.
		 Con người phải hiểu và nắm rõ vấn đề
		 thì mới có thể hướng dẫn lại cho "người không biết gì".)

			Ví dụ: chương trình máy tính phục vụ cho nhu cầu của con người.
				- Chương trình máy tính bỏ túi giúp con người tính toán các phép tính.
				- Trình duyệt giúp con người duyệt web.
				- Microsoft Word giúp con người soạn thảo văn bản.
				- Foxit Reader giúp con người đọc được các tập tin ở định dạng PDF.

				* Người lên kịch bản và chuẩn bị: con người (lập trình viên).
				* Công cụ hỗ trợ viết kịch bản: một phần mềm khác (Code Editor, IDE) giúp viết nên phần mềm.
				* Người thực thi kịch bản: máy tính.
				* Các bước trong kịch bản:
					- Nhấn biểu tượng.
					- Cung cấp dữ liệu.
					- Tính toán & xử lý.
					- Nhận kết quả.
					- ...
				* Người tham dự (trải nghiệm): người dùng (user).
				* Mục đích: giải quyết và đáp ứng những nhu cầu của người dùng (giải trí, công việc hằng ngày,...).

------------------------------------------------------------

* Nhập môn lập trình với C (Programming Fundamentals Using C): học tư duy, suy nghĩ về lập trình (programming) nói chung và những vấn đề trong cuộc sống để làm sao tạo ra được chương trình trên máy tính (application), làm sao nói cho máy tính hiểu được điều con người muốn.
	-> Học về tư duy lập trình, cách suy nghĩ để làm ra một ứng dụng/chương trình máy tính.

(Ngôn ngữ C ở đây chỉ là được mượn để thể hiện tư duy và ý tưởng lập trình/viết chương trình máy tính của con người, chứ không phải học chuyên sâu về ngôn ngữ C.)

Ngôn ngữ C/C++ cho ta sử dụng một cách linh hoạt hơn để hiểu sâu về hệ điều hành, vì đây cũng là những ngôn ngữ tạo nên hệ điều hành. Cho phép can thiệp sâu vào hệ thống và can thiệp trực tiếp vào phần cứng, driver để điều khiển các thiết bị nhờ có con trỏ.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Lập trình là kỹ thuật tạo ra một chương trình máy tính với một loạt các kịch bản	|
│	để máy tính có thể tự động hoá công việc nào đó khi được người dùng (user) yêu cầu	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――


=> Những bước chân chập chững đầu tiên trong MỘT CUỘC CHƠI LỚN.

------------------------------------------------------------

[NGÔN NGỮ CỦA NGƯỜI & CỦA MÁY]

Là phương tiện để hai bên giao tiếp và trao đổi thông tin với nhau.

				Giao tiếp
(Con người) --------------------------------------------> (Con người)
		Ngôn ngữ: nói, kí hiệu, hình thể...
			+ Từ vựng & ngữ pháp
		(Ngôn ngữ chung mà đôi bên cùng hiểu)


				Giao tiếp
(Con người) --------------------------------------------> (Máy tính)
		Ngôn ngữ: ngôn ngữ lập trình
			  để giao tiếp với máy
			+ Từ khoá & cú pháp
		(Ngôn ngữ chung mà đôi bên cùng hiểu)

----------------------------------------

* Ngôn ngữ lập trình (Programming Language): thứ ngôn ngữ mà (Con người) phải học để giao tiếp với (Máy tính), ngôn ngữ thể hiện được mong ước của con người.

	- Về phía con người, đây là thứ ngôn ngữ quen thuộc, vì đa số sẽ được viết bằng tiếng Anh.

	- Chương trình dịch sẽ là cầu nối để giúp cho cả con người và máy tính có thể đọc và hiểu được.

	- Mỗi hệ thống khác nhau sẽ có những ngôn ngữ khác nhau (vẫn sử dụng tiếng Anh), nhưng chỉ cần tuân theo những quy tắc của ngôn ngữ đó, thì nhất định con người sẽ giao tiếp được với máy tính; sẽ ra lệnh được cho máy tính để giải quyết những bài toán trong thực tế.

	* Học ngôn ngữ lập trình: học cách giao tiếp và ra lệnh cho máy tính (sau đó là đóng gói thành tập tin cài đặt và phân phối chương trình).

----------------------------------------

Cả ngôn ngữ tự nhiên và ngôn ngữ lập trình đều có chung một mục đích là truyền đạt ý tưởng giải quyết một bài toán toàn đó. Chỉ khác nhau ở chỗ:
	- Ngôn ngữ tự nhiên: để con người hiểu và xử lý.
	- Ngôn ngữ lập trình: để máy tính hiểu và xử lý.

	Ví dụ: Giải và biện luận phương trình bậc 1: ax + b = 0

		* Ngôn ngữ tự nhiên:

			- Nếu a ≠ 0 ➙ phương trình x = -b / a
			- Ngược lại, nếu a = 0 ➙ phương trình 0x + b = 0
							   <=> 0x = -b
				+ Nếu b = 0 ➙ 0x = -0 ➙ phương trình vô số nghiệm
				+ Ngược lại, nếu b ≠ 0 ➙ 0x = -b ➙ phương trình vô nghiệm

		* Ngôn ngữ lập trình:

			int a, b;
			double x;

			if (a != 0)
			{
				x = (double)-b / a;
				printf("Phuong trinh co nghiem x = %d", x);
			}
			else // a == 0
				if (b == 0)
					printf("Phuong trinh co vo so nghiem!\n");
				else // b != 0
					printf("Phuong trinh vo nghiem!\n");

==========================================================================================
==========================================================================================
==========================================================================================

[QUY TRÌNH / VÒNG ĐỜI PHÁT TRIỂN PHẦN MỀM - SOFTWARE / SYSTEMS DEVELOPMENT LIFE CYCLE (SDLC)]

Quy trình [đơn giản] để phát triển một chương trình:

------------------------------------------------------------

	01. Phân tích vấn đề (Analyze the problem): từ những thông tin mà khách hàng đã cung cấp, phân tích xem đội ngũ phát triển cần làm những gì để đạt được những yêu cầu từ phía khách hàng.

		- Phân tích xem đội ngũ có trong tay những dữ liệu gì và cần phải đi giải quyết những vấn đề thực tế gì.

		- Sử dụng lưu đồ IPO (Input, Process, Output) để sắp xếp và trình bày kết quả của bước phân tích.
			+ Dữ liệu đầu vào (Input): các dữ liệu cần có để đạt được mục tiêu.
			+ Quy trình (Process): liệt kê các bước cụ thể để thực hiện.
			+ Dữ liệu đầu ra (Output): đích đến của việc giải quyết vấn đề.

		-> Xác định những dữ liệu sẽ được cung cấp (input) và kết quả cần phải có (output).
			-> Sử dụng lưu đồ IPO.

------------------------------------------------------------

	02. Thiết kế thuật giải (Design the algorithm): dựa theo những yêu cầu từ khách hàng đã phân tích được ở bước trên, tiến hành thiết kế những kỹ thuật cụ thể để giải quyết riêng cho từng vấn đề nhỏ (rồi sau này mới tập hợp lại và giải quyết một vấn đề lớn). Đây là bước quan trọng và yêu cầu những người giàu kinh nghiệm, giúp lập ra những bước cụ thể để giải quyết vấn đề, có thể minh hoạ các thuật giải bằng lưu đồ / sơ đồ quy trình (flowchart) hoặc mã giả (pseudo code).

		-> Xác định những bước cần phải làm và sắp xếp theo một thứ tự hợp lý.
			- Sử dụng ngôn ngữ tự nhiên.
			- Sử dụng lưu đồ / sơ đồ quy trình (flowchart)
			- Sử dụng mã giả (pseudo code).
				-> Sử dụng lưu đồ / sơ đồ quy trình hoặc mã giả.

------------------------------------------------------------

	03. Lập trình (Code the program): lựa chọn một ngôn ngữ nào đó mà con người có thể hiểu, để chuyển những kỹ thuật giải quyết bài toán và tập hợp chúng thành một chương trình với nhiều câu lệnh, sau đó chuyển đổi tiếp (biên dịch - compiler) thành ngôn ngữ mà máy tính có thể hiểu.

------------------------------------------------------------

	04. Kiểm thử (Test the program): thực thi chương trình đã được thiết kế xong để tìm lỗi và đảm bảo chất lượng của chương trình. Ngoài việc đảm bảo những tính năng của chương trình hoạt động đúng, còn phải đảm bảo rằng có đầy đủ những tính năng mà người dùng cần để phục vụ cho nhu cầu của họ.

--------------------------------------------------------------------------------

(* Lưu ý: đây chỉ là quy trình đã được rút gọn, trong thực thế sẽ còn nhiều công đoạn hơn.)

==========================================================================================
==========================================================================================
==========================================================================================

[NHẬP MÔN LẬP TRÌNH]

* Công cụ: chọn "đồ chơi" (công cụ) để thể hiện ý tưởng bằng ngôn ngữ lập trình và đưa cho máy hiểu.
		(Chọn không gian và bối cảnh để lập trình viên "chuyển đổi ý tưởng thành kịch bản".)

	- Integrated Development Environment (IDE): môi trường phát triển tích hợp nhiều thứ trong một.
		+ Đây là một công cụ lớn, phức tạp nhưng có nhiều tính năng và có đầy đủ mọi thứ để ngay lập tức bắt đầu vào lập trình.
		+ Cho phép gõ code, sửa lỗi trong quá trình lập trình, tự động biên dịch / thông dịch để ra được tập tin nhị phân và đóng gói thành thư viện hoặc tập tin có thể thực thi được.

		Ví dụ: Dev-C++, Code::Blocks, xCode, Eclipse, NetBeans, Visual Studio, IntelliJ...

	- Code Editor: trình soạn thảo code.
		+ Công cụ nhỏ nhẹ (lightweight), không có đủ mọi thứ ngay từ đầu, nếu muốn tận dụng tối đa sức mạnh thì cần phải cài thêm một số tiện ích trong quá trình sử dụng.
		+ Chỉ hỗ trợ cho quá trình viết code, còn để biên dịch/thông dịch và ra được tập tin nhị phân thì phải cài thêm một số công cụ bên ngoài.

		Ví dụ: Visual Studio Code, Brackets, Sublime Text...

=> Tuy có những sự khác nhau, nhưng vẫn có chung mục đích: giúp lập trình viên giao tiếp với máy tính.

--------------------------------------------------------------------------------

* Bước đầu vào lập trình:

	1. Xác định ngôn ngữ lập trình: C
		(Chỉ học về tư duy chứ không học sâu về ngôn ngữ.)

	2. Công cụ để thể hiện ngôn ngữ lập trình:
		+ IDE - Đơn giản: Dev-C++ (đối với Windows) và xCode (đối với macOS)
			(Có chút khác biệt liên quan đến trình biên dịch (compiler) giữa các hệ điều hành.)
		+ Code Editor - Phức tạp: Visual Studio Code (cả Windows và macOS)

	3. Học cách giao tiếp với máy tính, cách tạo ra kịch bản.
		(Bước vất vả và tốn thời gian nhất.)

--------------------------------------------------------------------------------

[THUẬT NGỮ VỀ DỰ ÁN KHI SỬ DỤNG CÔNG CỤ]

------------------------------------------------------------

* Giải pháp (Solution): được xem như "câu trả lời chung" cho mọi dự án (Project) khác nhau.

	- Có công dụng như một thư mục lớn (Solution), chứa nhiều thư mục nhỏ (Project) bên trong.

	- Một hoặc nhiều Project khác nhau (nhưng có liên quan đến nhau) có thể được chứa trong cùng một Solution.

		Ví dụ: Giải pháp - Xây dựng ứng dụng nhắn tin.
			* Dự án 1 - Server: quản lý việc nhắn tin thông qua Web API.
			* Dự án 2 - Client: thực hiện việc nhắn tin thông qua Windows Forms.

------------------------------------------------------------

* Phi vụ / Dự án (Project): những gì mà ta dự định sẽ làm.

	- Hoặc một chương trình / hệ thống đang trong quá trình được viết / thực hiện. Sau khi hoàn thành sẽ được gọi là sản phẩm.
	
	- Là không gian để làm việc (nơi lưu trữ tài nguyên, thông tin chung của dự án...), mã nguồn cũng sẽ được chứa trong đây.

	- Đích đến cuối cùng là một sản phẩm hoàn thiện.

	(Nơi "tập kết" tài nguyên của một chương trình trong thực tế.)

	Ví dụ: phía bên ngoài bao bì của một sản phẩm (bánh, kẹo,...) trong thực tế có chứa những thông tin chung về sản phẩm:
		- Nhà sản xuất.
		- Nơi sản xuất.
		- Hạn sử dụng.
		- ...

	* Danh sách các loại dự án có thể gặp:

		* Windows Application: dự án với ứng dụng có giao diện đồ hoạ (GUI) dạng cửa sổ (Window), chẳng hạn như lập trình trình Android.

		* Console Application: dự án với ứng dụng có giao diện cửa sổ dòng lệnh (Console) trên màn hình "nền đen - chữ trắng".

		* Dynamic Link Library (DLL): thư viện liên kết động.
			+ Thường thấy khi bẻ khoá (crack) phần mềm bằng cách ghi đè các file DLL đã được bẻ khoá (crack) từ trước lên file DLL gốc hiện có.
			+ Vì các nhà sản xuất phần mềm thường tách phần kiểm tra bản quyền (lisecense) ra thành một tập tin (chương trình) riêng, bên trong chứa các câu lệnh kiểm tra bản quyền để ứng dụng gọi đến mỗi khi khởi động.
			+ Nhưng do không thể phá cấu trúc của ứng dụng nên các nhà bẻ khoá (cracker) sẽ chỉ sửa lại phần kiểm tra thông tin bản quyền để khi ứng dụng được chạy, nó sẽ cấp nhận mọi loại khoá bản quyền (key lisecense) hoặc bỏ qua phần kiểm tra thông tin bản quyền,...
			-> Chương trình nhỏ được tách ra từ chương trình lớn, thường liên quan đến bản quyền.

----------------------------------------

	* Mã nguồn gốc (Source code / Source file / Source program): tập tin văn bản không định dạng (plain text) chứa các câu lệnh được (con người / lập trình viên) viết bằng ngôn ngữ lập trình để yêu cầu máy tính (cụ thể là CPU) thực hiện một công việc nào đó.

		- Mã hiệu (Code): công thức / thuật toán để biến đổi thông tin sang một dạng khác.

			+ Mã hoá (Encode) là quá trình biến đổi nguồn (Source) thành dữ liệu và gửi đến một nơi nào đó.
		
			+ Ý tưởng về lập trình đã có đôi chút sự biến đổi / mã hoá tuỳ theo ngôn ngữ lập trình.

			Ví dụ: mã hoá trong ngôn ngữ đời thường và ngôn ngữ lập trình.
				- Ý tưởng gốc: "In ra màn hình" - print something out.
				- Mã hoá trong ngôn ngữ C: printf(something);
	
		- Nguồn (Source): vật / nơi làm nảy sinh một vật khác hoặc một hiện tượng, một năng lượng.

			+ Về mặt lập trình, đây là tập tin mã nguồn chứa code gốc (những câu lệnh đã được mã hoá, gần giống với ngôn ngữ tự nhiên - tiếng Anh), do con người viết để máy tính làm theo những câu lệnh được viết trong đây.
		
			+ Là bản gốc chứa công sức và tài sản trí tuệ của lập trình viên, nên giữ bản quyền thật kỹ nếu không có ý định công khai làm mã nguồn mở (Open source).

		-> Tập tin chứa thuật toán do con người viết - chứa đựng tinh hoa của ứng dụng.

		Ví dụ: một số phần mở rộng phổ biến của mã nguồn gốc
			.pas
			.c
			.h
			.cpp
			.cs
			.java
			.php
			.js

----------------------------------------

	* Mã máy (Machine language / Machine code / Binary code / Byte code): những câu lệnh được (con người) viết bằng ngôn ngữ lập trình sẽ phải đi qua thêm một giai đoạn chuyển đổi (convert).
		- Vì máy tính không thể hiểu ngôn ngữ lập trình, mà con người thì cũng không thể lập trình bằng mã máy.
		- Mã máy sẽ được viết ở dạng nhị phân nên máy tính có thể hiểu được các câu lệnh này, từ đó giúp CPU có thể thực thi được chương trình.
		-> Bước trung gian, giúp chuyển đổi ngôn ngữ, để máy tính có thể hiểu được yêu cầu của con người.

--------------------

		* Chương trình dịch / Trình biên dịch (Compiler): là ứng dụng trung gian với nhiệm vụ chuyển đổi mã được viết bằng một ngôn ngữ lập trình (tiếng Anh) thành một thứ ngôn ngữ mà bộ xử lý của máy tính có thể hiểu được (mã máy).
			- Mã máy sau khi đã chuyển đổi xong sẽ được lưu trong một tập tin được gọi là object file.
			- Bên trong tập tin sẽ chứa các câu lệnh được viết dưới dạng nhị phân (binary - hệ đếm cơ số hai), vì máy tính hoạt động dựa theo quy tắc của dòng điện/xung điện/tín hiệu điện với hai trạng thái On/Off - nhị phân.
			-> Tập tin sau khi đã được biên dịch (object file); nhưng chưa thể thực thi được.
				(Chuyển tập tin '.c' thành '.obj')

			Ví dụ: một số trình biên dịch/thông dịch phổ biến
				// C và C++
				Cygwin / gcc / MinGW

				// Java
				JDK

				+ Biên dịch (Compiler): chương trình dịch với nhiệm vụ đọc toàn bộ mã nguồn, nếu không tìm thấy bất kì lỗi - bug nào (không thoả được bộ quy tắc) thì sẽ tiến hành chuyển tất cả sang mã máy, sau đó đưa cho máy tính để máy tính đọc mã máy và thực thi theo (nhờ sự hỗ trợ của trình thực thi).
					Ví dụ: biên dịch viên sẽ đọc toàn bộ tài liệu từ đầu đến cuối, sau đó mới chuyển nó sang một ngôn ngữ khác, có lưu lại thành tài liệu dịch thuật.

				+ Thông dịch / Phiên dịch (Interpreter): chương trình dịch với nhiệm vụ đọc từng dòng trong mã nguồn và trực tiếp thực hiện từng dòng lệnh trong đó (có được luôn kết quả), nhưng sẽ không lưu trữ lại thành một tập tin mã máy và mỗi lần gọi là mỗi lần phải thông dịch lại.
					Ví dụ: thông dịch viên / phiên dịch viên sẽ dịch nói (dịch đuổi / dịch miệng), chuyển tải từng câu nói sang một ngôn ngữ khác, không ghi ghép bản dịch thành một tài liệu bài bản.

--------------------

		* Trình liên kết (Linker / Link editor): trong quá trình biên dịch, mỗi tập tin mã nguồn khác nhau tạo ra được một object file.
			- Nhưng sau khi đã có được object file, vẫn chưa chạy được ngay, mà cần phải có trình liên kết để liên kết các object file lại với nhau; thêm bất kì thư viện (library) nào được yêu cầu và liên kết các thư viện đã sử dụng trong các object file lại với nhau (liên kết với các thư viện được khai báo #include từ bên ngoài vào).
			- Đồng thời, mỗi một chương trình đều cần có startup code để có thể chạy trên các hệ điều hành khác nhau. Trình liên kết cũng làm nhiệm vụ thêm startup code vào để tạo ra tập tin có thể thực thi được (executable file).
			- Bên cạnh tập tin thực thi (executable file), trình liên kết cũng có thể tạo ra những tập tin thư viện (library file) hoặc tạo ra những tập tin biên dịch (object file) khác.
			-> Bước gom nhiều object file và các thư viện lại; đã có thể thực thi được.
				(Chuyển tập tin '.obj' thành '.exe')

			* Trên hầu hết các hệ điều hành, thực sự có đến hai trình liên kết:
				1. Linker: 
				2. Dynamic linker: .dll


		(Để biến đổi ngược từ tập tin nhị phân (mà máy tính có thể hiểu) thành tập tin gốc (chứa các câu lệnh được viết bằng ngôn ngữ lập trình) thì phải sử dụng kỹ thuật dịch ngược - Decompiler & Reverse engineering)

----------------------------------------

	* Mã thực thi / Tập tin có thể thực thi được (Executable file): là kết quả của quá trình biên dịch (compile) và liên kết (link).
		- Sau khi hoàn thành hai quá trình này mà không có lỗi gì xảy ra, mỗi khi chương trình được thực thi bằng cách nhấp đúp vào tập tin hoặc được thực thi thông qua giao diện dòng lệnh (command-line interface - CLI).
		- Tập tin lúc này sẽ được nạp vào RAM và các câu lệnh sẽ được truyền cho CPU.
		-> Tập tin mà máy tính có thể hiểu và thực thi được.

		Ví dụ: một số phần mở rộng phổ biến của tập tin có thể thực thi được
			.apk
			.exe
			.dmg
			.dll

------------------------------------------------------------

* Sản phẩm (Product): thành quá/kết quả cuối cùng đạt được sau khi dự án đã hoàn thành.

------------------------------------------------------------

Cú pháp (Syntax): tập hợp các quy tắc của một ngôn ngữ lập trình mà lập trình viên phải tuân thủ.

==========================================================================================

[QUY ƯỚC TRONG QUÁ TRÌNH LẬP TRÌNH - CODING CONVENTIONS]

Một hệ thống có thể có sự tham gia của rất nhiều lập trình viên và mỗi người sẽ đảm nhận một phần, nếu ai cũng tự làm theo sở thích riêng của mình mà không hề có một quy tắc chung nào để giao tiếp và không thống nhất cách viết code với nhau, thì sẽ khiến code rất khó để bảo trì và nâng cấp trong tương lai.
	-> Cần tuân theo cách quy chuẩn để đảm bảo trật tự và giúp những thành viên khác dễ tiếp quản.

--------------------------------------------------------------------------------

[QUY TẮC TỔ CHỨC THƯ MỤC]

1.1 Trên hệ điều hành Windows, chương trình máy tính đang viết (code) phải nằm trong một thư mục KHÁC ổ đĩa C: để tránh bị mất khi hệ điều hành gặp vấn đề và bắt buộc phải cài lại.
	(Không nên để ở ngoài Desktop vì về bản chất thì nó chỉ là một thư mục con thuộc C:\Users\<TenNguoiDung>\Desktop)

(Trên hệ điều hành macOS và Linux sẽ không có ổ đĩa C, thay vào đó sẽ chỉ có thư mục gốc và các thư mục con sẽ được chia thành các phân vùng (partition), vì vậy, chỉ cần tạo một folder như trên hệ điều hành Windows.)

--------------------------------------------------------------------------------

1.2. Tên thư mục chứa code tuyệt đối không được:
	- Sử dụng Tiếng Việt có dấu.
	- Chứa khoảng trống (dấu cách).
	- Chứa kí tự đặc biệt.
		-> Ảnh hưởng đến quá trình biên dịch / thông dịch hoặc chạy chương trình vì các trình biên dịch / thông dịch không thân thiện với các kí tự lạ.

		Ví dụ:
			* Sai:
				D:\Lập trình\Cơ sở lập trình\...

			* Đúng:
				D:\lap-trinh\co-so-lap-trinh\...
				D:\lap_trinh\co_so_lap_trinh\...
				D:\lap.trinh\co.so.lap.trinh\...

--------------------------------------------------------------------------------

[QUY ƯỚC ĐẶT TÊN]

2.1. Quy ước đặt tên cho chương trình / dự án (Application / Project): mỗi chương trình mà ta đã hoặc đang viết đều sẽ có một cái tên (tương ứng với một thư mục trên ổ cứng).
	(Đang làm: dự án | Hoàn thành: chương trình - sản phẩm.)

	- Mặc định, tên của dự án sẽ:
		+ Sử dụng danh từ.
		+ Viết hoa mỗi đầu từ, trừ tình huống đặc biệt về nhận dạng thương hiệu (iCloud).
		+ Viết liền nhau.

		Ví dụ:
			TenCuaChuongTrinh
			TenCuaDuAn
			HeThongQuanLySinhVien
			HeThongDichVuChamSocThuCung
			FacebookMessenger

	- Nhưng khi xây dựng thành một bộ thư viện thì nên đặt chữ thường và ngăn cách nhau bằng dấu gạch nối, để đảm bảo về tính tương thích đối với các hệ điều hành Unix.

		Ví dụ:
			dat-ten-de-giup-tuong-thich-voi-unix
			chat-example
			math-util
			vscode-react-native
			node-core-utils 

------------------------------------------------------------

2.2. Tên gói (Package / Namespace): giống như cách tổ chức thư mục trên ổ đĩa.

	- Mặc định, tên gói sẽ:
		+ Sử dụng danh từ.
		+ Sử dụng các từ đơn.
		+ Viết hoàn toàn bằng chữ thường.
		+ Các thư mục con phân cách nhau bởi dấu chấm.

		Ví dụ:
			com.apple.quicktime
			util
			data
			vn.edu.ou.util
			vsg.data

------------------------------------------------------------

2.3. Tên lớp (Class) / Interface:

	- Mặc định, tên lớp sẽ:
		+ Sử dụng danh từ.
		+ Viết hoa mỗi đầu từ.
		+ Viết liền nhau.
		+ Viết rõ nghĩa, tránh viết tắt.

		Ví dụ:
			Dog
			Cat
			File
			String
			Student
			Person
			FileInputStream
			StringTokenizer
			HinhTron
			TamGiac

------------------------------------------------------------

2.4. Tên biến (Variable): là nơi lưu trữ dữ liệu để máy tính xử lý.

	- Mặc định, tên biến sẽ:
		+ Sử dụng danh từ.
		+ Sử dụng cú pháp con lạc đà / cú pháp iPhone *.
		+ Viết liền nhau.
		+ Nên đặt có ý nghĩa và tránh viết tắt (trừ khi chỉ là biến tạm / trung gian, biến đếm).

		Ví dụ:
			// Biến thông thường
			luongCoBan
			dienTich
			chuVi
			basicSalary
			yearOfBirth
			yob
			salary

			// Biến tạm
			t, temp, tmp

			// Biến đếm
			i, j, k

	- Hằng số (Constant): là đại lượng có giá trị không đổi.
		+ Sử dụng danh từ.
		+ Viết in hoa tất cả các từ.
		+ Giữa các từ được ngăn cách nhau bởi dấu gạch dưới.

		Ví dụ:
			PI
			VAT
			VALUE_ADDED_TAX
			THUE_GIA_TRI_GIA_TANG
			MAX_SPEED
			MAX_ELEMENTS

------------------------------------------------------------

2.5. Tên hàm / phương thức (Function / Method): diễn tả hành động, xử lý.

	- Mặc định, tên biến sẽ:
		+ Sử dụng động từ kèm theo bổ ngữ (Verb + Object).
		+ Sử dụng cú pháp con lạc đà / cú pháp iPhone *.

		Ví dụ:
			tinhLuong()
			computeArea()
			getSalary()
			showInfo()
			sort()
			sortByName()

	- Khuyến khích: có ghi chú cho tên hàm (ý nghĩa của hàm, đầu vào, đầu ra...).

------------------------------------------------------------

* Cú pháp con lạc đà (Camel Case Notation) / Cú pháp iPhone - trong ngôn ngữ Java: chữ cái đầu tiên viết thường, những chữ cái còn lại viết hoa đầu từ.

	- Tên biến: đại diện cho một giá trị.

		Ví dụ: minh hoạ về cách đặt tên biến trong lập trình.
			int choice;
			double radius;
			int yearOfBirth;
			double basicSalary;
			double soTienHocPhiLa;

	- Hằng số: đại lượng có giá trị không đổi.

		Ví dụ: minh hoạ về cách đặt tên hằng số trong lập trình.
			const double PI = 3.14;
			const double VALUE_ADDED_TAX = 0.08; // VAT: thuế giá trị gia tăng
			const int MAX_ELEMENTS = 500;

	- Tên hàm: nói về xử lý và hành động.

		Ví dụ:  minh hoạ về cách đặt tên hàm trong lập trình.
			void printMenu();
			int getFactorial();
			int computeFactorial();
			int printIntegerList();
			double tinhDienTichHinhChuNhat();

--------------------------------------------------------------------------------

4. Gióng lề / Thụt dòng (Indentation): thụt vào một tab (~ 4-8 khoảng trắng) để biểu diễn sự lệ thuộc khi câu lệnh này là lệnh con của câu lệnh kia.

	- Nếu không gióng lề thì CPU vẫn tự hiểu và biết cách thực thi sao cho đúng, nhưng về mặt đọc code của con người thì sẽ gây khó hiểu và khó tư duy.

	-> Những câu lệnh cùng cấp sẽ thẳng hàng, nhưng những câu lệnh con thì phải được gióng lề so với lệnh cha.

		Ví dụ:
			if ((gpa >= 9) && (gpa <= 10))
				System.out.println(“You are excellence”);

	- Bên cạnh đó, để việc viết được chuẩn chỉ hơn, ta cũng cần lưu ý dấu cách trong các thành phần của biểu thức, phép gán, câu lệnh.

		Ví dụ:
			// SAI chuẩn
			int a= 10;
			int a =10;
			int a=10;

			// Đúng chuẩn
			int a = 10;

--------------------------------------------------------------------------------

5. Ghi chú (Comment / Note): giúp giải thích mục đích của chương trình và câu lệnh.

	- Ghi chú sẽ không được chuyển thành mã máy nên sẽ không làm ảnh hướng đến chương trình, thậm chí được phép sử dụng tiếng Việt có dấu để ghi chú mà không gặp thông báo lỗi.

	- Nếu chương trình được chú thích tốt sẽ giúp dễ dàng hơn trong việc bảo trì, sửa chữa và nâng cấp; đặc biệt là đối với người mới tiếp quản dự án.

	* Các cách tạo ghi chú:

		// 1. Sử dụng cặp dấu "//" để ghi chú một dòng duy nhất,
		//    muốn có dòng thứ hai thì phải sử dụng lại cặp dấu "//"

		/*
		   2. Ghi chú trên nhiều dòng,
		      có thể thoái mái ghi chú bên trong cặp dấu "/* */"
		*/

	* Vị trí đặt ghi chú: dù đặt ở đâu thì đều có thể áp dụng cả hai cách ghi chú.

		1. Đầu chương trình (Header comment): xuất hiện ở đầu chương trình, có nhiệm vụ cung cấp thông tin tổng quát về chương trình.

		2. Từng dòng (Step comment / In-line comment): xuất hiện trong thân chương trình, có nhiệm vụ giải thích mục đích cho các câu lệnh hoặc nhóm các câu lệnh.

==========================================================================================
==========================================================================================
==========================================================================================

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Con người ---(Viết)---> Mã nguồn ---(Biên/Thông dịch)---> Nhị phân ---(Tạo thành)---> Ứng dụng	│
│												|	│
│												|	│
│		CPU ---(Xử lý lệnh)---> RAM <---(Đưa lệnh)--- Ổ đĩa máy tính <---(Chứa trong)----	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[CẤU TRÚC BÊN TRONG CỦA MÁY TÍNH]

* Card đồ hoạ (Graphic card): có liên quan đến bảng mã ASCII. Đồ hoạ, hiển thị bao nhiêu pixel trên màn hình hiển thị. Có cơ chế ánh xạ các tín hiệu/điểm ảnh tử RAM lên trên màn hình.

* Bộ nhớ truy cập ngẫu nhiên (Random Access Memory - RAM): nơi lưu trữ dữ liệu và các câu lệnh để CPU vào đọc và xử lý. Cũng giống như một tờ giấy nháp chứa các câu lệnh để CPU vào đọc và xử lý. Nếu thiếu RAM thì sẽ không có nơi chứa các câu lệnh để CPU biết đường thực thi. Mỗi ứng dụng khi khởi chạy sẽ tốn một vùng RAM nhất định.

* Ổ đĩa vật lý (Physical Hard Drive): dữ liệu được tổ chức trên các vòng tròn đồng tâm (track). Phân vùng (partition) đầu tiên tương ứng với ổ đĩa C.
	* Boot sector: đoạn (≈ vòng tròn đồng tâm đầu tiên) - vùng để mồi và khởi động hệ điều hành, thường chiếm khoảng 512 Byte và có chứa một phần của hệ điều hành trong đây. Chứa câu lệnh thực thi dạng nhị phân, được dùng để gọi hệ điều hành.
		* Điểm bắt đầu/khởi đầu (Entry point): cổng để đi vào.
		* Bootstrap: phần mồi để kéo hệ điều hành lên trong trường hợp hệ điều hành không khởi động được.

	* Partition (Logical Hard Drive): ổ đĩa sẽ được chia thành nhiều phần nhỏ hơn, được gọi là phân vùng. Mục đích là để dễ quản lý hơn.

* Hệ điều hành (Operation System): hệ điều hành Windows là một phần mềm được cài vào phân vùng đầu tiên - Boot sector (ổ đĩa C) trong ổ đĩa, phải luôn luôn được hoạt động để quản lý toàn bộ hoạt động của máy tính.

	Ví dụ:
		Toàn nhà nguyên khối	≈	Ổ đĩa
		Tầng lầu trong toà nhà	≈	Phân vùng ổ đĩa

* Hệ thống trên một vi mạch (System on a Chip - SoC): vi mạch được tích hợp nhiều thành phần và gần như hoàn chỉnh, thường được thấy trong điện thoại di động và máy tính bảng.

* Phần cứng máy tính cũng chỉ là các linh kiện điện tử, để hoạt động được thì vẫn phải dựa vào phần mềm, nhúng những mã nhị phân để điều khiển vào phần cứng.

==========================================================================================

* CMOS: Pin/chip lưu thông tin ngày giờ hoạt động của máy tính.

* Basic Input Output System (BIOS) - Legacy: chip dùng để ghi thông số hoạt động của máy, được nuôi bởi PIN.
	-> Được nâng cấp bằng một chip mới bảo mật và an toàn hơn: UEFI.

--------------------------------------------------------------------------------

** Khi nhấn nút nguồn của máy tính, điện được nạp vào trong máy và CPU sẽ lập tức được sống.

1. CPU sẽ gọi một chương trình nhỏ (chip BIOS), chương trình sẽ đi kiểm tra:
	+ RAM, bàn phím, chuột, máy in,.... xem có hoạt động ổn không (một số thiết bị sẽ sáng đèn).
		-> Tự kiểm tra khi bật nguồn - POST (Power-On Self-Test).

2. CPU yêu cầu chip kiểm tra xem người dùng đã cấu hình rằng hệ điều hành được nạp từ ổ đĩa nào (vì một máy có thể có nhiều ổ đĩa). Sau đó, CPU vào ổ đĩa để nạp toàn bộ các câu lệnh (được lưu trong Boot sector) vào trong RAM. CPU đọc các câu lệnh từ RAM (lệnh yêu cầu truy cập vào thư mục C:\Windows\System32) và tiếp tục thực thi theo (tiếp tục đưa câu lệnh vào RAM) cho đến khi hết câu lệnh thì hệ điều hành sẽ được khởi động.
	-> CPU nạp một phần nhỏ của hệ điều hành vào trong RAM (dùng đến đâu thì nạp đến đấy).

--------------------------------------------------------------------------------

Khi khởi động máy tính và hệ điều hành, các câu lệnh (code) của hệ điều hành - đang cài trên ổ cứng sẽ được nạp vào RAM. Lúc này, trong quá trình hoạt động sẽ không cần truy xuất ổ cứng vì code của hệ điều hành được chạy bằng cách lấy từ RAM lên.
	-> Các ứng dụng (nói chung) sẽ sao chép code của mình lên RAM. Trong quá trình hoạt động, truy xuất code trên RAM để chạy thay vì file .exe trên ổ cứng.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Các câu lệnh được lưu trữ trong ổ cứng nhưng sẽ được nạp vào RAM để chạy/xử lý	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[BÓNG BÁN DẪN & HỆ NHỊ PHÂN / HỆ ĐẾM CƠ SỐ 2]

Trong phần lớn các máy tính ngày nay, trước hết, mọi vấn đề sẽ được chuyển thành các yếu tố toán học bằng cách diễn tả mọi thông tin liên quan thành các số theo hệ nhị phân (hệ thống đếm dựa trên các số 0 và 1 hay còn gọi là hệ đếm cơ số 2). Sau đó, mọi tính toán trên các thông tin này được tính toán bằng đại số Boole (Boolean algebra).

Máy tính là một thiết bị điện tử và nó chỉ có thể hiểu tín hiệu điện tử hoặc tín hiệu nhị phân.

------------------------------------------------------------

	* Binary digit (bit): chữ số nhị phân.

	* Tranfer: chuyển.
	* Register: điện trở (cản trở dòng điện).

	* Semi: một nửa			| Bán: một nửa, 1/2.
	* Conductor: dẫn, truyền	| Dẫn: dẫn điện.

* Bóng bán dẫn (Transistor | Transfer register | Semi-conductor) - ba chân: biểu diễn được hai trạng thái có và không của dòng điện (là hệ nhị phân - 2 bit: 0 và 1), cũng giống như công tắc điện biểu diễn hai trạng thái tắt hoặc mở.

	- Tín hiệu điện tử 5 vôn có thể đại diện cho số nhị phân 1 trong khi 0 vôn có thể đại diện cho số nhị phân 0.

	- Biểu diễn thông tin qua đèn LED.

------------------------------------------------------------

Năm 1960, người ta phát hiện ra hai nguyên tố silic (Si) và germani (Ge) trong bảng hệ thống tuần hoàn các nguyên tố hóa học. Hai nguyên tố này có độ biến thiên electron (điện tử) lạ và đặc biệt hơn những nguyên tố khác mỗi khi có dòng điện chạy qua nên được sử dụng trong bóng bán dẫn.
	-> Lúc có, lúc không. Lúc cho và lúc không cho điện đi qua (có điện/không có điện - ON/OFF, 0/1).
		-> Phân chia hai trạng thái: CÓ hoặc KHÔNG
			=> Binary - Nhị phân.

=> Bóng bán dẫn (transistor) được dùng để biểu diễn thông tin.
	-> Biểu diễn thông tin được thì cũng xử lý thông tin được.

Thông qua tài năng đấu dây khéo léo của các nhà điện tử, dòng điện bật/tắt (On/Off, 0/1) có thể biểu diễn được thông tin nào đó. Vì vậy, khi học về máy tính, ta phải học về hệ nhị phân đầu tiên để có thể hiểu được bản chất của việc biểu diễn thông tin.

Riêng một trạng thái trong bóng bán dẫn: hoặc bật hoặc tắt / hoặc On hoặc Off / hoặc 0 hoặc 1 / hoặc có điện hoặc không có điện.
	-> Một bóng bán dẫn = 1 bit (gom cả 2 thì được gọi là binary).

* Kỹ thuật số (Digital): kỹ thuật dựa trên hai số 0 và 1 (hệ nhị phân).

Mọi thứ mà máy tính "nhận thấy" (kể cả khi máy tính được coi là có khả năng tự nhận biết) cũng chỉ là các hạt electron tương đương với các số 0 và 1. Chỉ có bộ não của con người mới nhận thức được những ký hiệu được hiển thị trên thiết bị xuất sẽ tạo thành các chữ hay số, rồi từ đó mới gắn ý nghĩa cho chúng.

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hệ nhị phân xuất phát từ bóng bán dẫn (transistor)	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[BÓNG BÁN DẪN TRONG CUỘC SỐNG]

RAM và CPU được chế tạo dựa trên việc nhồi nhiều bóng bán dẫn (transistor) vào một cái đế nhựa (một core).
	-> RAM và CPU được hình thành nên từ những mạch phức tạp (IC).

	* Nhiều đế nhựa được nhồi vào một tấm nhựa lớn.
		-> Đa lõi (Multi-core).

=> Những miếng chip đen (IC) trên RAM và CPU là tổng hợp của vài tỷ bóng bán dẫn (transistor).

* Mạch siêu tích hợp / Vi mạch (Integrated Circuit - IC): nhồi nhiều thứ vào cùng một chỗ, tích hợp nhiều bóng bán dẫn và các linh kiện điện tử thụ động (như điện trở) lại với nhau, để thực hiện được một chức năng xác định.
	- Xử lý âm thanh, Wifi, đồ hoạ (hiển thị),...

	(Thực tế cũng có những máy tính sử dụng hệ tam phân - Ternary
	 hay những máy tính lượng tử với Qubit có thể đồng thời ở nhiều trạng thái.
	 Nhưng cho đến nay, vẫn chưa loại nào có thể độ ổn định
	 để lưu và truyền tải thông tin giống như hệ nhị phân.)

--------------------------------------------------------------------------------

			(nối với)
			  |
Bóng bán dẫn (transistor) ≈ một đèn led hoặc một đống các đèn led (bật/tắt) để biểu diễn một chữ cái.
	-> Binary (2 bit: 0 và 1) -> Chữ số, chữ cái.

Các nhà thiết kế mạch/điện tử thích nói cùng một lúc về một cụm các bit để cho gọn và xử lý được nhiều.
	-> Làm việc trên nhiều bit cùng một lúc.

Nếu các bóng bán dẫn (transistor) được xếp cạnh nhau tạo thành các cụm:
	- 4 cái ở cạnh nhau sẽ được gọi là 1 nibble.
	- 8 cái ở cạnh nhau sẽ được gọi là 1 Byte.

	-> Nhóm lại với nhau để giải thích kí tự, số, kí hiệu...

	Ví dụ:
		Bóng bán dẫn (transistor):
			- Một cụm gồm 8 bit = 1 Byte
			- Nhiều Byte (nhiều cụm 8 transitor) -> KB, MB, GB, TB, PB,... (bội số của Byte)

		Tương tự như những sữa hộp:
			- Một lốc gồm 4 hộp.
			- Nhiều lốc sữa -> Thùng sữa

―――――――――――――――――――――――――――――――――――――――――
│	8 transistor = 8 bit = 1 Byte	│
―――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Lưu ý: trong thực tế, để tạo nên một đơn vị sẽ cần nhiều Byte hơn (ví dụ: 1 KiloByte = 1024 Byte). Điều này sẽ giúp dữ liệu không bị suy hao hay mất mát theo thời gian.

==========================================================================================

[PHÉP CỘNG NHỊ PHÂN]

(Phép cộng nhị phân)		(Kết quả nhị phân)		(Thập phân)
	0 + 0		=	     0
	0 + 1		=	     1
	1 + 0		=	     1
	1 + 1		=	    10			->	     2 
	1 + 1 + 1	=	    11 (10 + 1)		->	     3
	...

==========================================================================================

[QUY ĐỔI ĐƠN VỊ ĐO LƯỜNG]

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Một bit (b) sẽ tương đương với một chữ số 0 hoặc 1 trong hệ nhị phân	│
│										│
│	Một Byte (B) với 8 bit (b) sẽ biểu thị cho 256 giá trị từ 0 – 255	│
│	và một Byte cũng chỉ biểu diễn cho một kí tự.				│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

* Bảng giá trị quy đổi của một số đơn vị đo thông tin thông dụng:

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Đơn vị đo	│	Ký hiệu		│	Giá trị		│
│―――――――――――――――――――――――+―――――――――――――――――――――――+―――――――――――――――――――――――│
│	bit		│	b		│	–		│
│	Byte		│	B		│	8b		│
│	KiloByte	│	kB		│	1024B		│
│	MegaByte	│	MB		│	1024kB		│
│	GigaByte	│	GB		│	1024MB		│
│	TeraByte	│	TB		│	1024GB		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

* Ngoài ra, còn có thêm: PetaByte (PB), ExaByte (EB), ZettaByte (ZB), YottaByte (YB), BrontoByte (BB), GeopByte (GeB)

------------------------------------------------------------

* Khi nói về tốc độ internet:

Kilobit per second (kbit/s), (kb/s) hoặc (kbps)
kiloByte per second (kByte/s), (kB/s) hoặc (kBps)

--------------------------------------------------------------------------------

Trong đơn vị đo lường có nhiều hệ đo nhưng người ta thường sử dụng 10 mũ (bội số của 10)* để đo những đại lượng, vì chúng giúp giảm đi số lượng số 0 không cần thiết.

	1Ton = 1000kg  = 10^3kg
	1kg  = 1000gr  = 10^3gr
	1km  = 1000m   = 10^3m
	1m   = 100cm   = 10^2cm

(* Xu hướng sử dụng bội số của 10 để biểu diễn tất cả các con số là vì con người có mười ngón tay/chân.)

--------------------------------------------------------------------------------

* Theo lý thuyết:

x		: bit (0 hoặc 1)
xxxx		: nibble
xxxx xxxx	: Byte


   (1)           (2)           (3)           (4)           (5)           (6)           (7)           (8)

xxxx xxxx     xxxx xxxx     xxxx xxxx     xxxx xxxx     xxxx xxxx     xxxx xxxx     xxxx xxxx     xxxx xxxx
  1Byte         1Byte         1Byte         1Byte         1Byte         1Byte         1Byte         1Byte


	1kB  = 10^3B   = 1000B   = 8.000 bóng bán dẫn (transistor) = 8.000 bit


	1MB  = 10^3kB  = 1000kB
			 *  1kB  = 10^3B   = 1000B
			 => 1MB  = 1000 (kB) * 1000 (B)
				 = 1.000.000 Byte
				 = 8.000.000 bóng bán dẫn (transistor)


	1GB  = 10^3MB  = 1000MB
			 *  1MB  = 10^3kB  = 1000kB
			 *  1kB  = 10^3B   = 1000B
			 => 1MB  = 1000 (MB) * 1000 (kB) * 1000 (B)
				 = 1.000.000.000 Byte
				 = 8.000.000.000 bóng bán dẫn (transistor)


	1TB  = 10^3GB  = 1000GB
			 *  1GB  = 10^3MB  = 1000MB
			 *  1MB  = 10^3kB  = 1000kB
			 *  1kB  = 10^3B   = 1000B
			 => 1MB  = 1000 (GB) * 1000 (MB) * 1000 (kB) * 1000 (B)
				 = 1.000.000.000.000 Byte
				 = 8.000.000.000.000 bóng bán dẫn (transistor)

------------------------------------------------------------

* Trong thế giới của con người:

	10^3 = 1000
	^
	|
	|
	------------------------- Thế giới của con người (thập phân), mười trạng thái từ 0 đến 9

----------------------------------------

* Trong thế giới của máy tính (khoa học máy tính):

	2^10 = 1024 ≈ 1000 (có thể làm tròn vì độ lệch không quá nhiều đến mức ảnh hưởng lớn đến giá trị)
	^  ^
	|  |
	|  |			
	|  ---------------------- Thế giới của con người (thập phân), sử dụng hệ cơ số/hệ đếm 10
	|
	------------------------- Thế giới của máy tính (nhị phân), hai trạng thái 0 và 1


* Trong lý thuyết nghiêm ngặt và tính toán bội số:

	1kB  = 2^10B   = 1024B   ≈ 1000

	1MB  = 2^10kB  = 1024kB
			 *  1kB  = 2^10B   = 1024B
			 => 1MB  = 1024 (kB) * 1024 (B)
				 = 1.048.576 Byte <- Con số 48.576 so với 1.000.000 thì không đáng kể
				 ≈ 1.000.000 Byte

―――――――――――――――――――――――――――――――――
│	Kilô (k) = 10^3 = 1000	│
―――――――――――――――――――――――――――――――――

==========================================================================================

Máy tính dùng để tính toán.
	-> Làm sao để giúp máy tính biết cách tính toán trên nhị phân (có điện và không có điện).

Công dụng của bóng bán dẫn (transistor):
	- Biểu diễn thông tin thông qua đèn LED.
	- Biểu diễn số lượng, đếm, tính toán trên số lượng.

	* 10 ngón tay/chân của con người.
		-> Đếm số lượng trên 10 ngón và tính toán trên số lượng.

	* 2 trạng thái của máy tính.
		-> Tìm cách đếm số lượng trên 2 trạng thái.

--------------------------------------------------------------------------------

[CÁC HỆ CƠ SỐ / HỆ ĐẾM - NUMBER SYSTEM]

* Kí số (digit): kí tự (được viết ra) để biểu diễn một con số (đại lượng số), dùng nó như một "bảng chữ cái" để ghép thành những con số.
	-> Kí tự để biểu diễn một con số.

	Ví dụ: 10 trạng thái của số thập phân = 10 digit (0 1 2 3 4 5 6 7 8 9).

* Hệ cơ số / Hệ đếm (Base): tuỳ cách đếm mà cách viết những con số sẽ khác nhau: số Ả Rập/Ấn Độ, số La Mã..., dù số lượng cần đếm là không đổi.
	-> Cách để đếm dữ liệu (số lượng của vật vẫn không đổi, chỉ khác cách thể hiện kí tự)

	Ví dụ: khi đếm từ 1 đến 4, số lượng cần đếm là 4, nhưng sẽ khác cách viết/cách thể hiện kí tự
		- Số Ả Rập:	1	2	3	4
		- Số La Mã:	I	II	III	IV
			-> Đều biểu diễn được 4 số, chỉ khác nhau cách viết.

* Nguyên tắc đếm:
	- Lấy hàng đơn vị làm mốc và đếm tăng dần lên đến hết digit thì thôi (lấy hàng bên phải nhất mà đếm).
	- Khi hết digit thì (hàng đó) reset về 0.
		+ Khi một hàng nào về 0 thì hàng kế bên (bên trái) tăng lên 1.
		+ Cứ thế đếm đến hết (về 0) và ghép tăng lên 1.
		+ Ghép từ trái sang phải.

----------------------------------------

Cùng một đại lượng giá trị nhưng có nhiều cách biểu diễn khác nhau.
	(Số đồ vật là không đổi, nhưng khác nhau về cách đếm và thậm chí là cách thể hiện kí tự.)
	-> Chuyển đổi giữa các hệ cơ số/hệ đếm.

------------------------------------------------------------

* Các hệ cơ số/hệ đếm:

Nhị phân (2)		Bát phân (8)		Thập phân (10)		Thập lục phân (16)
Binary (BIN)		Octal (OCT)		Decimal (DEC)		Hexa-Decimal (HEX)
0000	0000			0			0			0
0000	0001			1			1			1
				2			2			2
				3			3			3
				4			4			4
				5			5			5
				6			6			6
				7			7			7
							8			8
							9			9
										A
										B
										C
										D
										E
										F

------------------------------------------------------------

[CÁCH ĐẾM SỐ LƯỢNG VÀ TÍNH TOÁN TRÊN SỐ LƯỢNG]

	- Thập: mười.
	- Phân: phân chia.
* Hệ đếm thập phân (Decimal - DEC): xuất phát từ 10 ngón tay.
	-> Phân chia mười trạng thái.

		0 1 2 3 4 5 6 7 8 9 (số Ả Rập)
		(10 trạng thái ở trên được gọi là 10 digit.)

	- Không biết phải làm sao để đại diện được số 10.
	- Trong lịch sử tồn tại của hệ đếm từ thời xa xưa, số 0 là chữ số được phát hiện/tạo ra cuối cùng trong hệ thống số.
	- Sử dụng kỹ thuật sắp xếp vị trí để đếm đủ các loại số dù lớn đến mức nào.
		* Đếm dãy số từ trái sang phải, đếm đến khi hết tất cả các số trong dãy số cơ bản dùng để đếm thì sẽ tiến hành ghép cặp.
			+ Dùng 10 trạng thái và ghép cặp chúng với nhau.
			+ Cùng một con số nhưng vị trí khác nhau thì giá trị (power - năng lực) khác nhau (hàng đơn vị, hàng chục, hàng trăm...).
				Ví dụ: 2022
					- Số 2 ở hàng đơn vị có giá trị khác với số 2 ở hàng chục.

=> Dùng một hữu hạn các giá trị và biểu tượng nhưng có thể biểu diễn được nhiều giá trị.

	* Cách đếm:
			  1
			  2
			...
			  8
			  9
			 10
			 11
			...
			 19
			 20
			...
			 98
			 99
			100

----------------------------------------

* Hệ nhị phân (Binary - BIN): xuất phát từ 2 trạng thái.

		0 1

	* Cách đếm:
			   0
			   1
			  10
			  11
			 100
			 101
			 110
			 111
			1000
			1001
			1010
			1011
			1100
			1101
			1110
			1111

----------------------------------------

* Hệ bát phân (Octal - OCT): xuất phát từ 8 trạng thái.

		0 1 2 3 4 5 6 7

	* Cách đếm:
			  0
			  1
			  2
			  3
			  4
			  5
			  6
			  7
			 10
			 11
			 12
			 13
			 14
			 15
			 16
			 17
			 20
			 21
			 22
			 23
			 24
			 25
			 26
			 27
			 30
			...
			 70
			...
			 77
			100
			101
			...
			107
			110

----------------------------------------

* Hệ thập lục phân (Hexa-Decimal - HEX): xuất phát từ "16 ngón tay của người sao Hoả".

		0 1 2 3 4 5 6 7 8 9 A B C D E F

	- Tăng chậm hơn/hết chậm hơn do có số to (nhiều) hơn BIN, OCT và DEC, cần ít kí tự hơn nhưng lại biểu diễn được số to hơn.
		Ví dụ: chỉ cần sử dụng F là đã có thể biểu diễn số 15 của hệ thập phân.

	* Cách đếm:
			  0
			  1
			  2
			...
			  8
			  9
			  A	<- 10 (hệ thập phân)
			  B
			  C
			  D	<- 13 (hệ thập phân)
			  E
			  F
			 10	<- 16 (hệ thập phân)
			 11
			 12
			...
			 19
			 1A	<- 26 (hệ thập phân)
			 1B
			 1C
			 1D	<- 29 (hệ thập phân)
			 1E
			 1F
			 20	<- 32 (hệ thập phân)
			 21
			...
			 29
			 2A	<- 42 (hệ thập phân)
			 2B
			 2C
			 2D	<- 45 (hệ thập phân)
			 2E
			 2F
			 30	<- 48 (hệ thập phân)
			 31
			...
			 99
			 9A	<- 154 (hệ thập phân)
			 9B
			 9C
			 9D	<- 157 (hệ thập phân)
			 9E
			 9F
			 A0	<- 160 (hệ thập phân)
			 A1
			...
			 A9
			 AA	<- 170 (hệ thập phân)
			 AB
			 AC
			 AD	<- 173 (hệ thập phân)
			 AE
			 AF
			 B0	<- 176 (hệ thập phân)
			 B1
			...
			 B9
			 BA	<- 186 (hệ thập phân)
			 BB
			...
			 FA	<- 250 (hệ thập phân)
			...
			 FF	<- 255 (hệ thập phân)
			100	<- 256 (hệ thập phân)

------------------------------------------------------------

=> Trong máy tính sẽ có bảng ánh xạ để máy tính tự động chuyển (chuyển đổi ngầm) từ hệ này sang hệ kia.

----------------------------------------

* Chuyển đổi hệ cơ số/hệ đếm (bảng ánh xạ):

Nhị phân (2)		Bát phân (8)		Thập phân (10)		Thập lục phân (16)
Binary (BIN)		Octal (OCT)		Decimal (DEC)		Hexa-Decimal (HEX)
0000	0000			 0			 0			 0
0000	0001			 1			 1			 1
0000	0010			 2			 2			 2
0000	0011			 3			 3			 3
0000	0100			 4			 4			 4
0000	0101			 5			 5			 5
0000	0110			 6			 6			 6
0000	0111			 7			 7			 7
0000	1000			10			 8			 8
0000	1001			11			 9			 9
0000	1010			12			10			 A
0000	1011			13			11			 B
0000	1100			14			12			 C
0000	1101			15			13			 D
0000	1110			16			14			 E
0000	1111			17			15			 F
0001	0000			20			16			10
0001	0001			21			17			11
0001	0010			22			18			12
0001	0011			23			19			13
0001	0100			24			20			14
...				...			...			...

--------------------------------------------------------------------------------

[KỸ THUẬT CHUYỂN ĐỔI GIỮA CÁC HỆ CƠ SỐ]

	* Thuật toán: kỹ thuật giải quyết bài toán (bằng cách nhân/chia/cộng/trừ) - công thức. Là quy trình / cách thức / kỹ thuật đưa những thông tin mà ta đang có vào, tìm cách xử lý để có được kết quả đầu ra đúng với yêu cầu.
		-> Kỹ thuật giải quyết bài toán - công thức.

Có những bài toán phức tạp sẽ đòi hỏi những thuật toán rất phức tạp, chẳng hạn như những thuật toán liên quan đến trí tuệ nhân tạo. Nhưng cũng có những bài toán đơn giản thì kỹ thuật giải quyết cũng rất đơn giản, chẳng hạn như thuật toán bói toán.

----------------------------------------

** Các cách để chuyển đổi giữa các hệ cơ số/hệ đếm (base).
	1. Liệt kê theo bảng ảnh xạ.
	2. Sử dụng Thuật toán chuyển đổi.
	3. Sử dụng ứng dụng Calculator sẵn có của hệ điều hành.

------------------------------------------------------------

[HỆ NHỊ PHÂN (2) -> HỆ THẬP PHÂN (10)]

Bản chất: dựa trên vị trí giá trị.

* Chuyển đổi hệ cơ số:
	1. Bắt đầu từ 0 (số gốc), đánh số mũ từ phải sang trái.
	2.* Từ phải (số gốc) sang trái, lấy từng số nhân với 2^(số mũ).
	3. Cộng tất cả các số lại với nhau.

		Ví dụ 1: (Có sử dụng bit dấu)

			   *
			  210 <- 2 mũ x

			0 010 = (0 * 2^0) + (1 * 2^1) + (0 * 2^2)
			      =     0	  +  (1 * 2)  +     0
			      =			2

		Ví dụ 2: (Có sử dụng bit dấu)

			   **
			  210 <- 2 mũ x

			0 011 = (1 * 2^0) + (1 * 2^1) + (0 * 2^2)
			      =  (1 * 1)  +  (1 * 2)  +     0
			      =     1	  +	2
			      =           3

----------------------------------------

* Tách số:
	1. Bắt đầu từ 0 (số gốc), đánh số mũ từ phải sang trái.
	2.* Từ trái sang phải, lấy từng số nhân với 10^(số mũ).
	3. Cộng tất cả các số lại với nhau.

		Ví dụ:
			*  *
			3210 <- 10 mũ
			2002 = (2 * 10^3) + (0 * 10^2) + (0 * 10^1) + (2 * 10^0)
			     = (2 * 1000) +     0      +     0      +  (2 * 1)
			     =    2000    +     0      +     0      +     2
			     =                        2002

==========================================================================================
==========================================================================================
==========================================================================================

[LẬP TRÌNH TRONG MÁY TÍNH]

	* Tính toán: giúp tính các phép toán (dựa trên nhiều biến/giá trị).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Máy tính được sinh ra để lưu trữ và tính toán thông tin	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

Muốn tính toán thì cần:
	- Hệ đếm và con số/toán hạng/số hạng/giá trị/đại lượng (Operand).
	- Phép tính số học/toán tử - công, trừ, nhân, chia nguyên / dư (Operator).
	- Phép tính quan hệ/so sánh số lượng (Relational Operator): >, >=, <, <=, ==, !=
	- Phép gán (Assignment Operator): =, +=, -=, *=, /=, %=
	- Phép tăng/giảm tự thân (Increment/Decrement Operator): ++, --
	- Toán tử logic (Logical Operator): AND, OR, NOT

	Ví dụ:
		5		+		5		=			  10
	    Operand	     Operator	     Operand	      Assignment operator	Result
	    (Giá trị)	     (Phép tính)     (Giá trị)	      (Phép gán)	       (Kết quả)

Dữ liệu/con số/toán hạng/số hạng/giá trị/đại lượng trong máy tính được lưu dưới dạng On/Off giống như bảng ánh xạ.

Con người nghĩ ra các con số và phép tính, họ sẽ làm toán thủ công.
	* Lập trình: sau khi đã biết cách tính ở ngoài đời thực, con người đưa số (biến - giá trị) và phép tính (công thức) cho máy móc tính toán giùm.
		-> Máy tính toán Computer (n) / Compute (v).

	-> Biết cách giải một bài toán ở ngoài đời thì mới có thể lập trình được.

--------------------------------------------------------------------------------

[KỸ THUẬT XỬ LÝ THÔNG TIN CỦA CON NGƯỜI]

Cách lập trình và cách hoạt động của máy tính đều dựa trên dư duy của con người, con người hành xử như thế nào thì sau đó sẽ dạy lại để máy tính cũng sẽ hành xử theo giống hệt vậy.
	* Nhờ máy tính giùm: máy tính được dùng để xử lý thông tin, nhưng muốn có được thông tin để xử lý thì trước tiên phải lưu trữ được.

Khi có quá nhiều thông tin (số liệu / dữ liệu - data) xung quanh cuộc sống cần được lưu trữ, con người sẽ có xu hướng:
	- Đặt tên gọi để định danh cho các giá trị / đại lượng (Identify).
	- Tổng quát hoá thành công thức (Function) nếu có thể.

----------------------------------------

		* Định danh (Identify/Indentification - ID): đặt tên gọi cho một đại lượng nào đó xung quanh cuộc sống để dễ phân biệt.
			- Trong công việc tính toán hằng ngày, con người luôn tìm cách xử lý thông tin sao cho nhanh chóng và hiệu quả nhất thông qua việc đặt định danh (tên gọi) cho mọi thứ cần xử lý và công thức hoá.

			- Việc đặt một cái tên sẽ giúp con người dễ dàng hơn trong việc giao tiếp, còn trong lập trình sẽ giúp cho máy tính dễ dàng hơn trong việc tham chiếu.

			Ví dụ: định danh - đặt tên gọi

				// Tên gọi cố định nhưng sẽ có thay đổi về giá trị
				// tuỳ thuộc vào ngữ cảnh
				sốTiềnHọcPhí: 5.000.000 vnđ, 10.000.000 vnđ, 15.000.000 vnđ...
				sốTínChỉ: 100, 110, 120, 127, 131...
				sốMônHọc: 40, 42...
				điểmTrungBình: 2.0, 2.5, 3.7, 4.0...

		* Công thức hoá (Formula/Function): con người sáng tạo ra công thức tính toán, đặt tên cho biến và sử dụng tên biến (thay cho giá trị vì tên biến sẽ tổng quát hơn) để giải quyết một lớp/loạt bài toán, mà không làm ảnh hưởng đến kết quả trả về một khi công thức đã đúng.
			(Tổng quát hoá thành công thức và đặt tên gọi cho các đại lượng.)

			Ví dụ: công thức hoá và xử lý trên tên biến

				// Công thức để tính tổng tiền
				tổngTiền =  sốLượng × đơnGiá	// Tên biến
				100.000  =     5    × 20.000	// Giá trị

				// Công thức để tính diện tích hình chữ nhật
				diệnTíchHìnhChữNhật = chiềuDài × chiềuRộng	// Tên biến
					50	    =    10    ×     5		// Giá trị

				// Công thức để tính diện tích hình tròn
				diệnTíchHìnhTròn = bán Kính × bán Kính × sốPI	// Tên biến
				      12.56      =     2    ×     2    × 3.14	// Giá trị

----------------------------------------

=> Đưa dữ liệu và công thức vào để máy tính toán giùm, sau đó nhận về kết quả.

------------------------------------------------------------

[BIẾN & GIÁ TRỊ - VARIABLE & VALUE]

----------------------------------------

	[BIẾN SỐ - VARIABLE]

		* Ví trí/Toạ độ/Địa chỉ vùng RAM (của một biến): cho biết rằng biến đó đang nằm ở Byte thứ mấy trong RAM, ví dụ: 6.000.001, 6.000.005, 8.000.008...

		* Giá trị (Value): đại lượng có thể thay đổi được.
	* Biến số (Variable): quy ước tên gọi chung, đại diện trực tiếp cho một hoặc nhiều giá trị (value) được lưu trong máy tính.

		- Trong quá trình tính toán, dữ liệu là thứ bắt buộc phải có. Để đưa được dữ liệu từ bên ngoài vào và lưu trữ nó trong máy tính (RAM), ta phải đặt tên gọi đại diện cho dữ liệu ấy.
		
		- Vì giá trị (value) trong máy tính cũng chỉ là một dãy các Byte, nên phải cần có một tên gọi để phân biệt chúng - tên biến. Vì vậy, biến là nơi để lưu trữ thông tin và phục vụ cho việc xử lý sau này.
	
		- Mục đích là để dễ thao tác với giá trị và xử lý thông qua tên gọi mà không bị nhầm lẫn (miễn là tên biến không được trùng nhau đối với những giá trị đơn giản), nếu giá trị trong biến có thay đổi thì kết quả xử lý cũng sẽ được tự động cập nhật theo.

		-> Tên gọi cho thứ có thể thay đổi/biến đổi theo ngữ cảnh - giá trị (value), được sử dụng để công thức hoá các tính toán.
			(Tên gọi cho một giá trị nào đó để công thức hoá và xử lý.)

			- Là một vùng RAM được đặt tên - tên vùng RAM.
			- Là cách thức lưu trữ dữ liệu để phục vụ cho việc xử lý.
			- Tuỳ vào kiểu dữ liệu mà biến sẽ chiếm một vùng nhớ (số Byte nhất định: 4 Byte, 8 Byte,...) trong RAM.
			- Bên trong RAM có thể chứa các giá trị bằng cách On/Off các bit (0101 0101).
			- Nằm ở một vị trí/toạ độ nào đó (địa chỉ) trong RAM - địa chỉ của biến.
				+ Địa chỉ (số thứ tự) của biến là toạ độ Byte đầu tiên trong một nhóm Byte được cấp cho biến đó.
				Ví dụ 1: biến và giá trị trong thực tế
					// Tên gọi	  // Giá trị
					tổngTiềnLà	: 5.000.000 vnđ
					tuổiLà		: 18
					địaChỉLà	: số 48, phố Hàng Ngang, phường Hàng Đào, quận Hoàn Kiếm, Hà Nội

				Ví dụ 2: biến và giá trị trong lập trình
					int diemSo = 10;
						// Tên của vùng RAM: diemSo
						// Kiểu dữ liệu: int (số nguyên - chiếm 4 Byte)
						// Chứa giá trị: 10
						// Nằm ở vị trí: 6684184 (trong RAM)

		* Lưu ý:
			- Một tên gọi có thể có nhiều giá trị khác nhau.
			- Một giá trị có thể có nhiều tên gọi khác nhau.

			Ví dụ 1: tiền học phí - một tên, nhiều giá trị.
				- Tên gọi / Biến: tiềnHọcPhí.
				- Giá trị:
						+ 8.000.000 vnđ.
						+ 9.000.000 vnđ.
						+ 10.000.000 vnđ.
						+ 11.000.000 vnđ.
					(Mỗi năm, tiền học phí của mỗi khoa/ngành đều thay đổi nhưng đó vẫn là tiền học phí.)
					-> Một tên gọi có thể có nhiều giá trị khác nhau.
						(Giá trị của một biến có thể thay đổi theo ngữ cảnh.)

			Ví dụ 2: những khoảng tiền - nhiều tên, một giá trị.
				- Tên gọi / Biến:
						+ tiềnHọcPhí.
						+ tiềnNhàTrọ.
						+ tiềnMuaSắm.
					(Tên gọi của những khoảng tiền có thể khác nhau nhưng lại có thể có cùng một giá trị.)
				- Giá trị: 5.000.000 vnđ.
					-> Một giá trị có thể có nhiều tên gọi khác nhau.
						(Nhiều biến khác nhau có thể lưu cùng một giá trị.)

----------------------------------------

	[GIÁ TRỊ - VALUE]

	* Giá trị (Value): giá trị tương ứng với biến, có thể là những giá trị quen thuộc như số, chữ, chuỗi (int, long, float, double, char...) hoặc giá trị đặc biệt - con trỏ (pointer).

		- Giá trị đơn giản / nguyên thuỷ / sơ cấp (Single / Primitive value): cùng một tên biến nhưng bên trong chỉ chứa một giá trị / thông tin.
			- Chỉ mang một ý nghĩa duy nhất và chỉ chiếm một vùng RAM duy nhất.
			- Có thể lấy giá trị được lưu trong biến để sử dụng được ngay, việc lấy tên biến hoặc giá trị bên trong để sử dụng là như nhau.
			-> Bên trong chứa giá trị tuy có thể thay đổi nhưng cũng chỉ mang duy nhất một ý nghĩa.
				(Một tên gọi để nói về một thứ duy nhất.)

			Ví dụ: một biến tuy có thể thay đổi về giá trị, nhưng chỉ có thể hiểu ở một góc độ duy nhất.
				- Biến "Tên": An, Bình, Cường, Dũng...
				- Biến "Tuổi": 16, 18, 20, 22, 24, 26, 28...
				- Biến "Ngày-tháng-năm sinh": 01/01/2000, 20/02/2002, 21/12/2112...

		- Giá trị phức tạp / phức hợp / có cấu trúc (Complex / Composite / Object value): cùng một tên biến nhưng bên trong chứa nhiều giá trị/thông tin và mang theo nhiều ý nghĩa.
			- Là một sự kết hợp khi bên trong sẽ bao gồm nhiều giá trị đơn giản khác hoặc thậm chí là những giá trị phức tạp khác nữa.
			- Sử dụng bằng tên gọi chung (tên con trỏ).
			-> Bên trong chứa những biến và giá trị có thể là đơn giản hoặc phức tạp khác.
				(Một tên gọi để nói về một thứ gồm nhiều thứ khác bên trong.)

			Ví dụ 1: Một danh sách / tập hợp các số nguyên sẽ bao gồm nhiều số nguyên bên trong.
				Tập hợp A = {-3; 2; 0; -1; 5; 7}

			Ví dụ 2: Một cấu trúc dữ liệu SinhViên sẽ gồm nhiều giá trị khác nhau.
				- Mã số
				- Họ tên
				- Địa chỉ
				- Số điện thoại
				- Điểm các môn học
				- Điểm trung bình
				- Điểm rèn luyện

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Biến là tên gọi của một vùng RAM		│
│	đại diện cho một giá trị đơn giản hoặc phức tạp	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

[CÁCH KHAI BÁO VÀ GÁN GIÁ TRỊ CHO BIẾN]

* Cách các để khai báo và gán giá trị cho biến:

	1. Khai báo, nhưng không gán giá trị:

		* Cú pháp: <kiểu-dữ-liệu> <tênBiến>;

			Ví dụ:
				double diemSo;
				int soTinChi;

	2. Khai báo và gán sẵn giá trị -> Khởi tạo giá trị mặc định:

		* Cú pháp: <kiểu-dữ-liệu> <tênBiến> = <giá-trị-khởi-tạo>;

			Ví dụ:
				double diemSo = 6.9;
				int soTinChi = 130;

	3. Sử dụng ké của một biến đã có sẵn giá trị.

		* Cú pháp: <kiểu-dữ-liệu> <tênBiếnNhậnGiáTrị> = <tênBiếnChoGiáTrị>;

		* Lưu ý: để gán được giá trị cho nhau thì hai biến phải có cùng kiểu dữ liệu.

			Ví dụ:
				double diemTruongNhom = 6.9;
				double diemCuaThanhVienTrongNhom = diemTruongNhom;

------------------------------------------------------------

[CÁC THUẬT NGỮ LIÊN QUAN]

----------------------------------------

	* Công thức (Formula/Function): tạo ra công thức để giải quyết mọi thứ (cho một lớp/loạt bài toán) thay vì chỉ giải quyết trên một bài toán.

=> Đưa biến vào trước (đưa giá trị vào biến sau) + công thức vào máy tính để máy tính tính toán.

----------------------------------------

	* Hằng số (Constant): là một vùng RAM chỉ cho phép đọc, nhưng không cho phép chỉnh sửa dữ liệu (read-only).
		- Dữ liệu sẽ được gán song song với lúc khai báo, không thuộc về bất kì hàm nào - Global variable.
		- Thường áp dụng cho những giá trị không bao giờ bị thay đổi (ví dụ: số pi, tốc độ ánh sáng - c...) hoặc rất hiếm khi phải thay đổi (ví dụ: thuế giá trị gia tăng...).
		-> Đại lượng chỉ cho phép khai báo mà không cho thay đổi giá trị (kiểu read-only).

		Ví dụ:
			const double PI = 3.14;
			const int MAX_ELEMENTS = 500;

		* Lưu ý: tránh hiểu nhầm hoặc hiểu sai về hằng số.

			- Từ "biến" (trong "biến hoá", "biến đổi" và cả "biến số") đã mang nghĩa là "có thể thay đổi".

			- Hằng số chỉ là một đại lượng có giá trị không đổi, nên không thể xem hằng số là "biến số nhưng không thay đổi giá trị" được, vì như vậy sẽ gây ra sự mâu thuẫn và sai nghĩa.

		#define tênNhãn giá-trị
			- Đặt tên giả cho giá trị nhưng lại không gây tốn RAM, vì đây chỉ là tên giả để đại diện cho giá trị.
				+ Viết in hoa toàn bộ tất cả các từ.
				+ Các từ ngăn cách nhau bởi dấu gạch dưới '_' theo cú pháp con rắn (Snake Notation / Snake Case).
			- Không được xem đây là biến, mà chỉ đơn giản là nhãn dán (Label).
			- Trước thi thực thi mã nguồn, trình biên dịch sẽ tiến hành tìm kiếm và thay thế tên nhãn trong code thành giá trị.

			Ví dụ:
				#define PI 3.14
				#define MAX_ELEMENTS = 500

------------------------------------------------------------

* Các bước khi lập trình:

	1. Đưa biến/giá trị vào trong máy tính và đặt tên cho vùng RAM - khai báo biến (declare a variable).
		(Biến/giá trị sẽ nằm trong RAM vì máy tính sẽ luôn xử lý từ trong RAM, còn ổ đĩa chỉ là nơi lưu trữ.)
		
	2. Đưa giá trị vào biến (vào từng byte - On/Off các transistor).

	3. Đưa công thức vào.

		=> Đưa giá trị và công thức vào để máy tính xử lý giống như con người xử lý.

----------------------------------------

* Lưu ý: khi khai báo biến để xin cấp một vùng RAM bất kỳ, nếu không gán sẵn giá trị cho biến...

	- Vùng RAM ấy có khả năng đã chứa giá trị 0 do máy tính vừa được khởi động. Hoặc đôi khi đã có sẵn một giá trị (On/Off) nào đó do ứng dụng trước đó để lại (tuy đã tắt ứng dụng, nhưng hệ điều hành sẽ không tự động giải phóng RAM để tiết kiệm hiệu năng cho CPU).
	
	- Nếu khai báo biến mà không gán trước một giá trị nào đó, khi tính toán sẽ có khả năng nhận về một giá trị rác (garbage value) - một giá trị ngẫu nhiên trong RAM, điều này sẽ gây nguy hiểm cho ứng dụng vì ứng dụng sẽ xử lý sai khi lấy một giá trị không mong muốn đem đi tính toán.

	-> Giá trị không mong muốn nhận được ngay khi mới xin cấp RAM được gọi là giá trị rác (garbage value).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Sau khi khai báo xong,					│
│	trước khi sử dụng biến thì phải gán giá trị cho nó	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[ĐỊA CHỈ BỘ NHỚ - MEMORY ADDRESS]

RAM được cấu tạo từ các bóng bán dẫn (transistor):

	- Trong RAM, các transistor sẽ được bố trí theo một cụm gồm 8 transistor ở gần nhau - tạo thành một Byte.

	- Byte (8 bit/8 transister) đầu tiên nhất trong RAM được gọi là Byte thứ 0 (Byte NULL), đóng vai trò rất quan trọng vì đây là nơi mà RAM bắt đầu.

		+ Đây là vùng sẽ không bao giờ được sử dụng để lưu dữ liệu.

		+ Được xem là vùng an toàn, quy ước toàn bộ các transistor sẽ luôn luôn được tắt (0000 0000), nghĩa là trong đây không có bất kì giá trị nào.

		+ Dùng như một cờ/cột mốc/dấu hiệu để đánh dấu việc kết thúc chuỗi trong RAM và trên ổ đĩa mà không làm ảnh hưởng đến nội dung.

		+ Trong lập trình hướng đối tượng, đây sẽ là nơi mà biến đối tượng (Object Variable) / con trỏ NULL (NULL pointer) trỏ vào.

		-> Nằm ở vị trí thứ 0 (đầu tiên nhất) và bên trong cũng không chứa bất kì giá trị nào (0000 0000).
			-> Địa chỉ của "đáy xã hội", toạ độ bắt đầu trong RAM là 0.

	- Trong mỗi Byte (toạ độ) có một đống On/Off nhị phân được gọi là giá trị (value) để lưu trữ và xử lý.
		+ Vùng RAM được phép cấp cho ứng dụng để hoạt động sẽ bắt đầu từ Byte thứ 6.000.000 (vùng Stack).
		+ Vùng RAM trước đó sẽ dùng cho hệ điều hành để điều khiển và quản lý máy tính vì bản chất của ứng dụng là những câu lệnh được đưa vào RAM và CPU sẽ thực thi theo những câu lệnh trong RAM.
		-> Cả ứng dụng và biến của ứng dụng đều phải nằm trong RAM và chiếm một số Byte nhất định.

* Địa chỉ bộ nhớ (Memory address): thứ tự/vị trí/toạ độ của 1 Byte (lốc 8 bit) trong RAM.

	- Tính từ đầu RAM, mỗi Byte sẽ có 1 địa chỉ riêng biệt.

	- Đây được xem là địa chỉ của biến nằm trên RAM.

	- Nếu biến có nhiều địa chỉ (kiểu int, double...), ta chỉ cần sử dụng địa chỉ khởi đầu của biến.

	-> Hỏi địa chỉ: "Anh nhà ở đâu thế?"

	Ví dụ 1: Giống như địa chỉ nhà trên ứng dụng Google Maps.
		- Mỗi ngôi nhà sẽ có một địa chỉ khác nhau.
		- Tuy nhà có thể hẹp hoặc rộng, dài hoặc ngắn...
			+ Nhưng ta sẽ chọn ra một nơi duy nhất để quy ước đâu là nơi được đánh dấu địa chỉ trên bản đồ.
			+ Địa chỉ được đánh dấu sẽ cho biết chính xác ngôi nhà ấy đang ở đâu. 
			+ Nhưng để biết hình dáng thật của ngôi nhà như thế nào, cần phải đến đúng địa chỉ.
		-> Một con số để đại diện cho ngôi nhà.

	Ví dụ 2: cho biến kiểu số nguyên chứa giá trị dạng thập phân 2022.

		// Nhị phân trong RAM
		0000 0000 -> Byte thứ 6.000.003
		0000 0000 -> Byte thứ 6.000.002
		0000 0111 -> Byte thứ 6.000.001
		1110 0110 -> Byte thứ 6.000.000	-> Địa chỉ của biến

(8GB: Byte thứ 0, Byte thứ 1, Byte thứ 2, Byte thứ 6.000.000,... Byte thứ 8.000.000.000 - 1)

------------------------------------------------------------

Vì biến là một nơi để chứa dữ liệu, nên khi nhập kí tự từ bàn phím vào RAM thì phải sử dụng biến để hứng kí tự.

CPU sẽ tương tác trực tiếp với RAM, nhưng bàn phím là thiết bị ngoại vi, nên để kí tự vừa nhập vào đến được chính xác vùng RAM của biến thì phải truyền vào địa chỉ.

	(Người trong gia đình chỉ cần nói "nhà" là đủ hiểu, nhưng người ngoài thì phải nói thêm địa chỉ nhà.)

	Ví dụ: scanf("%d", &yob);

		// Tưởng tượng việc đưa một kí tự từ bàn phím vào RAM
		// giống như công việc của một người giao hàng
		//	* Người giao hàng: Bàn phím
		//	* Địa chỉ giao hàng: Địa chỉ của biến trong RAM

		- Khi giao hàng đến một khu vực/dãy phố:

			+ Nếu chỉ biết tên người nhận hàng (tên biến) mà không biết được địa chỉ nhà/cơ quan cụ thể (địa chỉ bộ nhớ).
				-> Không tìm được nhà để giao hàng.

			+ Nếu chỉ biết địa chỉ nhà/cơ quan cụ thể (địa chỉ bộ nhớ) mà không biết tên người nhận hàng (tên biến).
				-> Không biết giao hàng cho ai trong khu đó.

			-> Sử dụng thêm ký hiệu '&' trước tên biến để đưa dữ liệu vào từ bàn phím kèm địa chỉ.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	CPU chơi với tên gọi, bàn phím chơi với địa chỉ		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[KHAI BÁO BIẾN & GÁN GIÁ TRỊ CHO BIẾN]

* Khai báo biến (Declare a variable): xin một vùng RAM để chứa dữ liệu (đi kèm với kiểu dữ liệu).

	- Vùng nhớ sẽ được cấp địa chỉ ngẫu nhiên trên RAM và có độ lớn tuỳ thuộc vào kiểu dữ liệu đã khai báo.

	- Tuy có quyền đặt câu lệnh khai báo ở bất kì đâu trong chương trình, nhưng...
		+ Khuyến khích khai báo tập trung ngay dưới tên hàm/nhóm câu lệnh để rõ ràng khi lập trình.
		+ Bắt buộc phải khai báo trước khi sử dụng nếu không sẽ bị báo lỗi.
		+ Khai báo toàn cục nếu đây là biến sử dụng chung trong toàn bộ chương trình.

	-> Khai báo một tên gọi để lưu trữ một giá trị tại một thời điểm.
		(Thông báo sự xuất hiện của một biến.)

	Ví dụ: "nội thất" bên trong của một biến.
		int namSinh = 2000;
		/*
			Trong đó:
				int: số Byte cần sử dụng (4 Byte đối với kiểu int).
				namSinh: tên của biến.
				2000: giá trị On/Off trong RAM.
				&namSinh (Giá trị ẩn): nằm ở vị trí nào trong RAM.
		*/

----------------------------------------

	- Cách 1: khai báo mà chưa cần gán giá trị vội, giá trị sẽ được từ từ gán sau trong tương lai. Vùng RAM được cấp theo cách này có thể chứa các giá trị rác (garbage value) do các ứng dụng trước đó để lại.

		* Cú pháp:
			<kiểu-dữ-liệu> <tênBiến>;
			<kiểu-dữ-liệu> <danh-sách-các-tên-biến-có-cùng-kiểu-dữ-liệu>;

		Ví dụ:
			int yob;

			int a, b, c;

----------------------------------------

	- Cách 2: vừa khai báo, vừa gán giá trị -> khởi tạo.

		* Cú pháp:
			<kiểu-dữ-liệu> <tênBiến> = <giá-trị>;
			<kiểu-dữ-liệu> <danh-sách-các-tên-biến-có-cùng-kiểu-dữ-liệu> = <giá-trị>;

		Ví dụ:
			// Khai báo các biến a, b và c đều có cùng kiểu dữ liệu số nguyên (int)
			int a = 10, b = 20, c = 30;

			// Không thể khai báo hai biến trùng tên nhau,
			// vì dù hai biến đó có thể khác toạ độ địa chỉ
			// nhưng CPU không chấp nhận hai vùng RAM khác địa chỉ nhau mà lại có cùng một tên

			// int a = 40;	// Bị trùng do biến a đã được khai báo ở trên (int a = 10)
			// a = 40;	// Hợp lệ vì đây là hành động gán lại giá trị
					// cho biến a đã khai báo ở trên

----------------------------------------

	- Cách 3: khai báo biến trước, gán giá trị sau thông qua bàn phím.

		* Cú pháp:
			<kiểu-dữ-liệu> <tênBiến>;
			scanf("%<tuỳ-kiểu-dữ-liệu>", &<tênBiến>);

		Ví dụ: các kiểu gán giá trị vào biến

			// 1. Gán bằng giá trị
			int yob = 2000;

			// 2. Gán bằng biến khác
			//	(Chỉ lấy giá trị và truyền từ biến này sang biến khác)
			int myYob = yob;
			
			// 3. Gán bằng biểu thức / phép tính
			double area = 3.14 * pow(radius, 2);

			// 4. Gán bằng cách nhập từ bàn phím - scanf()
			int yob;
			printf("Please in put your yob: ");
			scanf("%d", &yob);
				// Nếu có nhiều biến, để gán giá trị cho từng biến,
				// ngoài việc phải sử dụng nhiều lệnh scanf()
				// để gán giá trị cho từng dòng
				/ /thì ta có thể sử dụng kỹ thuật gán theo
				// "danh sách tham số trên dòng lệnh"
				// và ngăn cách giữa các giá trị với nhau
				// bằng dấu khoảng trắng (space) hoặc dấu xuống hàng (enter)

------------------------------------------------------------

[TRÌNH TỰ CHẠY CỦA CHƯƠNG TRÌNH]

* Lưu ý: CPU chạy từ tuyến tính trên xuống dưới, nên tại một thời điểm, một biến chỉ lưu được một giá trị, vì nó tương ứng với một trạng thái On/Off nào đó. Nên nếu muốn lưu nhiều hơn một giá trị thì phải có những kỹ thuật khác. Trong vòng đời tồn tại của biến, trước khi ứng dụng bị đóng, nếu một biến được gán lại giá trị nhiều lần thì trạng thái On/Off tương ứng cũng được thay đổi theo và khi in ra, giá trị gần nhất sẽ được hiển thị.
	-> Trong vòng đời tồn tại, một biến có thể thay đổi giá trị nhiều lần. Nhưng cuối cùng, tại một thời điểm, một biến chỉ lưu được một giá trị (giá trị của lần sửa đổi gần nhất).

	Ví dụ 1:
		// Ra quầy thu ngân để tính tiền
		tổngTiềnMuaHàngCủaBạnLà = 100.000

		// Mua thêm một số món
		tổngTiềnMuaHàngCủaBạnLà = 150.000

		// Số tiền phải trả cuối cùng là: 150.000

	Ví dụ 2:
		// Biến a ban đầu có giá trị khởi tạo là 5
		int a = 5;

		// Biến a được gán lại giá trị là 10
		a = 10;

		// Biến a được gán lại giá trị là 15
		a = 15;

		// Biến a được gán lại giá trị là 20
		a = 20;

		// In giá trị gần nhất của biến a ra
		printf("Gia tri cua a: %d\n", a);	// In ra 20

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Khai báo biến là kỹ thuật để lưu trữ dữ liệu ở trong RAM	│
│	và xác định kiểu dữ liệu (hình dáng) của loại dữ liệu ấy	│
│		(Có khai báo biến là có tốn vùng RAM)			│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[HÌNH THÁI / HÌNH DÁNG DỮ LIỆU - DATA TYPE]

	* Kiểu dữ liệu (Data type): hình thái của dữ liệu, cho biết dữ liệu sẽ được hiển thị ra bên ngoài dưới dạng như thế nào. Những hình thái khác nhau sẽ biểu đạt những ngữ nghĩa khác nhau.
		-> Cách mà dữ liệu được hiển thị/in/viết ra cho con người xem.

		Ví dụ: số, chữ, hình ảnh, âm thanh...

		(Kiểu dữ liệu byte, int, long, float, double, char... là những thứ cơ bản để ta tính toán và xử lý thông tin.)

Mỗi kiểu dữ liệu khác nhau, con người sẽ hiểu chúng rất linh hoạt. Nhưng do năng lực và hạn chế của máy tính mà khi sử dụng số, bên cạnh việc đặt tên cho dữ liệu, còn cần phải báo cho máy tính biết rằng ta sẽ dùng một số như thế nào (nhỏ, vừa hoặc lớn) nhằm giúp máy tính dễ dàng xử lý, nhận diện vấn đề và bố trí (allocate) RAM cho phù hợp để lưu trữ biến.

	-> Kích thước của kiểu dữ liệu - số Byte cố định dùng để lưu trữ và biểu diễn một kiểu dữ liệu nào đó.

Khi ta xác định được loại dữ liệu cần lưu trữ, CPU sẽ lập tức cấp ngay một số Byte tương ứng. Việc cố định số Byte cho dữ liệu sẽ giúp CPU dễ dàng định vị và xử lý (giống như kiểu "nhà liên kế" ngoài đời thực).

------------------------------------------------------------

Mỗi kiểu dữ liệu sẽ có một miền giá trị min-max (độ dài) khác nhau tuỳ thuộc vào hệ điều hành và trình biên dịch, mỗi kiểu dữ liệu sẽ sử dụng một vùng Byte tương ứng:

byte		int		long		float		double		char
 1B		2-4B		4-8B		  4B		  8B		1-2B

(Cùng là số thực, nhưng double sẽ chính xác hơn float về số phần thập phân.)

--------------------------------------------------------------------------------

[CÁCH LƯU DỮ LIỆU]

* Dữ liệu (Data): những thông tin xuất hiện và gợi cho chúng ta một điều gì đó.

Máy tính sẽ thay con người thực hiện những tính toán nào đó, nhưng để tính toán được thì máy tính lại cần phải có dữ liệu.

Xung quanh ta, dữ liệu có thể là:

------------------------------------------------------------

	1. Số: biểu diễn số nhị phân thành số ngoài cuộc sống khi con người bắt đầu có nhu cầu sở hữu, đo đạc.

----------------------------------------

		a. Số nguyên (nguyên con, không lẻ/sứt mẻ miếng nào)
			- Nhỏ: byte [-128...+127 | 0...255]

			- Vừa: int [±2 tỉ 1]
				Ví dụ: khi cần một con số vừa đủ lớn và không bị lẻ
					int yob = 2000;

			- Lớn: long (int) [±2 tỉ 1 | ±2^63]
				long long
				Ví dụ: khi cần lưu trữ một con số > 2 tỉ 1
					long amount = 4 000 000 000;

----------------------------------------

		b. Số thực / Lẻ phần thập phân (không trọn ven, bị mẻ / bể một chút ở phần thập phân)
			- Nhỏ: float [±10^38]
				Ví dụ:
					float pi = 3.14;
					float discount = 0.1;	// Giảm giá 10%

			- Vừa: double [±10^308]

------------------------------------------------------------

		* Chữ: Những gì được viết ra.
			- Chữ cái (Alphabet): Chữ được viết ra để đại diện cho câu văn.
			- Kí số (Digit): Kí tự đại diện cho con số.
			- Chữ-số (Alphanumeric): Là sự kết hợp của các kí tự chữ cái và kí tự số.

	2. Chữ/Kí tự: trong đời sống, kí tự là những thứ ta viết ra để biểu đạt/biểu thị/biểu diễn thông tin.
		- Trong tin học, kí tự là những thứ xuất hiện trên bàn phím máy tính (và những thứ tuy có nhưng lại "ẩn" sau bàn phím), giúp hiển thị ra màn hình một hình ảnh/hình dáng/thông điệp nào đó.

		- Tuy nhiên, cũng có những kí tự tuy không xuất hiện và mắt thường không thể nhìn thấy, nhưng nó lại có tác động đến những kí tự khác.

		- Mỗi kí tự trong cuộc sống đều được "chống lưng" (ánh xạ) thành một con số nguyên từ 0..255 (256 kí tự) và dùng 1 Byte (8 bit) để biểu diễn.
			-> Đằng sau mỗi kí tự là sự "chống lưng" của một con số, được biểu diễn dưới dạng nhị phân 1 Byte (8 bit).

		(256 = Tổ hợp/Số cách ghép của 2^8 = Số cách ghép nhị phân (0101...) / cách On/Off của 8 bit)

		- Kí hiệu "%d" cho phép ta biết được giá trị đó đã được On/Off như thế nào ở trong RAM.
			-> Mã "chống lưng" (ánh xạ).

		- Theo quan điểm của hệ thập phân (hệ 10), các số 0..255 "chống lưng" cho mỗi kí tự được gọi là mã ASCII.
			(Cũng giống như MSSV đại diện cho một sinh viên, mã số ASCII đại diện cho một kí tự.)
		=> Số "chống lưng": mã số ASCII, số nguyên chạy từ 0 - 255, chiếm 1 Byte (8 bit).

----------------------------------------

		Khi thiết kế máy tính, người Mỹ đặt ra một quy tắc để chuyển đổi thông tin.

			* Quy ước: tại thời điểm con chip BIOS (UEFI) được chế tạo, người ta quy ước sử dụng 1 Byte trong chip để lưu bảng mã hoá/chuyển đổi (ánh xạ) nhằm giúp biểu diễn kí tự. Khi đưa đủ 1 Byte dạng nhị phân từ RAM vào, chip sẽ chuyển đổi theo quy ước từ trước (đã cố định sẵn trong chip), sau đó đưa cho card đồ hoạ để hiển thị ra bên ngoài.
				-> Chip BIOS (UEFI) trên bo mạch chủ đảm nhận nhiệm vụ mã hoá kí tự.

						* Bảng: gồm hàng và cột.
						* Mã: mã hoá.
					=> Bảng mã kí tự (Character Encoding Table).

----------------------------------------

		[BẢNG MÃ ASCII]

		* Mã hoá (Encode): quy tắc để biến đổi thứ này thành thứ khác.

			Ví dụ 1: thời La Mã, hoàng đế Caesar đã bảo vệ các thông điệp có ý nghĩa quân sự bằng cách sử dụng phép dịch chuyển 3 vị trí (A trở thành D khi mã hóa và D trở thành A khi giải mã).

			Ví dụ 2: trong tin học, chip BIOS (UEFI) quy ước con số 32 là kí tự khoảng trắng.

		* American Standard Code for Information Interchange (ASCII): chuẩn mã trao đổi thông tin Hoa Kỳ. Quy tắc mã hoá mỗi kí tự thành một con số, con số đó sẽ được lưu trong chip BIOS và sau đó card đồ hoạ sẽ dựa vào đó để hiển thị ra màn hình.

			Vào ban đầu, khi thiết kế, bảng mã chỉ chứa 128 (2^7) kí tự tiếng Anh, về sau mới mở rộng thành 256 (2^8) kí tự và hỗ trợ thêm nhiều ngôn ngữ của những quốc gia khác.
				-> Sử dụng 8 bit để mã hoá 256 trường hợp.

				- Bảng mã ASCII truyền thống (ASCII Standard): chỉ sử dụng 7 bit để biểu thị kí tự.
				- Bảng mã ASCII mở rộng (Extended ASCII): sử dụng cả 8 bit để biểu thị kí tự.


		- Bảng mã ASCII quy ước cách On/Off để ra được kí tự, trong đó, 1 Byte trong BIOS (UEFI) được dùng để lưu bộ ánh xạ và nếu đưa đủ 8 bit On/Off nào đó thì sẽ ra được một kí tự nào đó. Nhờ có bảng mã mà các thiết bị bao gồm bàn phím, màn hình, máy in, ổ đĩa,... có thể thống nhất và cách lưu trữ và hiển thị dữ liệu.
			-> Quy ước về việc nhận tín hiệu từ bàn phím để hiển thị ra màn hình một kí tự có thể đọc được.

		- Nếu On/Off được một con số nhị phân (thập phân 0..255) trong RAM thì CPU, card đồ hoạ, bàn phím, ổ cứng, máy in, BIOS,... cũng sẽ biết cách hiển thị kí tự.
			(Bàn phím, bo mạch chủ, BIOS (UEFI), RAM, CPU, card đồ hoạ, màn hình, máy in, ổ đĩa,... đều thống nhất với nhau để hiển thị kí tự)

			-> Một kí tự chỉ cần 1 Byte, cần có chip BIOS (UEFI) để ánh xạ.

--------------------

		Để hiển thị được kí tự, hãy đưa 1 Byte (8 bit) vào RAM, sau đó CPU sẽ hỏi BIOS (UEFI) cách ánh xạ 1 Byte (8 bit) vào trong BIOS (UEFI) thành kí tự gì để yêu cầu card đồ hoạ hiển thị ra màn hình.

			(Nhị phân)	(Thập phân/Mã ASCII)	(Kí tự cho sự tồn tại - vô hình/hữu hình)
			0000 0000		0		'\0' | Đánh dấu kết thúc chuỗi (vô hình)
			0000 0001		1
			0000 0010		2
			0000 0011		3
			0000 0100		4
			0000 0101		5
			0000 0110		6
			0000 0111		7
			0000 1000		8		'\b' | Xóa ngược - phải sang trái (vô hình)
			0000 1001		9		'\t' | Tab ngang (vô hình)
			0000 1010		10		'\n' | Xuống dòng/chuyển dòng (vô hình)
			...
			0010 0000		32		' '  | Khoảng trắng/dấu cách (vô hình)
			...
			0011 0000		48		'0'
			0011 0001		49		'1'
			...
			0100 0001		65		'A'
			0100 0010		66		'B'
			...
			0110 0001		97		'a'
			0110 0010		98		'b'
			...
			1111 1111		255

			-> Bảng mã ASCII sử dụng 8 bit để mã hoá các kí tự.
				Ví dụ:
					A -> chữ cái a hoa	| 65 (hệ thập phân)
					a -> chữ cái a thường	| 97 (hệ thập phân)
						-> Chữ cái hoa nhỏ hơn thường 32 đơn vị.

					* Nếu muốn đổi từ hoa sang thường và ngược lại.
						-> Đổi mã ASCII (lấy mã ASCII ±32).

		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		│	Mã ASCII quy định mối tương quan		│
		│	giữa số nhị phân và số thập phân (số nguyên)	│
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		│	Mã ASCII là mã nhị phân	(8 bit)	được lưu trong RAM,	│
		│	nhưng được chuyển đổi thành thập phân để dễ ghi nhớ,	│
		│	đại diện (chống lưng) cho một kí tự			│
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------

		- Ngôn ngữ C cung cấp kiểu dữ liệu char để lưu On/Off của một kí tự ≈ BIOS (UEFI).
		- Có thể xem char như là int loại thu nhỏ và chỉ sử dụng 1 Byte thay vì 4 Byte.
		- Và vì đằng sau chữ cái là một con số (số nguyên) nên kiểu dữ liệu char có thể tương tác linh hoạt theo hai cách:
			1. Dùng trực tiếp kí tự - hiện thân (Ví dụ: 'A', 'a'...)
			2. Dùng mã số "chống lưng" ASCII - số nguyên thập phân (Ví dụ: 65, 97, 234...)
				-> Máy tính đều phải chuyển kí tự thành mã số On/Off trong chip BIOS (UEFI)

			Ví dụ:
				// Đưa một Byte vào trong RAM,
				// có một biến dùng để lưu kí tự,
				// nó phải được On/Off dựa theo bảng mã ASCII

				// Dấu nháy đơn ('') sử dụng cho một kí tự duy nhất
				// Dấu nháy đôi ("") sử dụng cho nhiều kí tự (chuỗi)
				char firstLetter = 'T';

--------------------

		Vậy, tóm lại, khi làm việc với kí tự bất kì sẽ có ba góc nhìn / cách biểu diễn hình dáng:

			1. Kí hiệu / Hiện thân / Hình dáng (biểu diễn / hiển thị ra bên ngoài) của kí tự đó như thế nào và nói lên thông điệp gì.
				Ví dụ: 'A', 'a', '\0'...

			2. Mã số thập phân trong bảng mã ASCII là bao nhiêu (biểu diễn bằng mã ASCII).
				Ví dụ: 73, 76, 111, 118, 101, 85...

			3. Mã nhị phân trong RAM tương ứng với mã thập phân là bao nhiêu (lưu trữ trong RAM).
				Ví dụ:
					(Nhị phân)	(Mã ASCII)	(Kí tự / Hiện thân)
					0100 0001	65		'A'
					0110 0001	97		'a'

--------------------

		Trong máy tính, các con số thực chất là chữ số
		vì trên bàn phím thì tất cả đều là chữ.
		Nghĩa là một chữ đại diện (biểu diễn ra bên ngoài) cho một con số,
		chỉ mang ý nghĩa về mặt nhìn chứ không tính toán.
			* Chữ số: chữ biểu diễn cho con số.
			* Chữ cái: chữ biểu diễn cho bảng chữ cái.

		'0' -> Chữ 0
		 	(Được vẽ ra hình tròn tròn, biểu thị thêm cho một đại lượng)

		// Kí tự hiển thị ra màn hình
		'0' -> Mã số "chống lưng" là 48 (trong RAM On/Off thành 48)
		'1' -> Mã số "chống lưng" là 49

		// Kí tự bị "ẩn", tuy có nhưng không hiển thị ra màn hình
		'\b' -> Mã số "chống lưng" là 8
		'\t' -> Mã số "chống lưng" là 9

		Có những kí tự tuy không hiển thị ra một cách rõ ràng để con người có thể xem,
		nhưng nó lại thật sự có tồn tại, vì nó có tác động đến những kí tự khác
		và phục vụ cho nhu cầu soạn thảo.
			-> Không thấy không có nghĩa là không có.

			Ví dụ: những thứ đặc biệt như phím Enter, Tab, Backspace... xét về mặt hiển thị:

				* Xoá: việc nó hiển thị ra sẽ khiến kí tự khác bị mất.
				* Xuống dòng: việc nó tồn tại sẽ khiến hai dòng bị ngắt. Ngoài ra, nó còn có thêm công dụng báo hiệu rằng kết thúc việc nhập dữ liệu.
				* Khoảng trắng: việc nó tồn tại sẽ đẩy hai kí tự sang hai bên, giúp phân biệt giữa hai thành phần. Ngoài ra, còn được dùng để phân cách các phần của biến được đưa vào RAM.

			=> Cần một thứ gì đó để nói về kí tự xuống dòng, xoá... tuy vô hình nhưng vẫn tồn tại.

		** Một số phím thường sử dụng trên bàn phím:
			* CRLF: phím [Enter] của Windows
				- Đối với Windows, dựa theo nguyên tắc của máy đánh chữ, khi nhấn [Enter] sẽ sinh ra hai kí tự (tín hiệu).
					+ '\r' Carriage Return - CR): về đầu dòng.
					+ '\n' (Line Feed - LF): xuống dòng mới.

				- Đối với macOS (cũ):
					+ '\r' Carriage Return - CR)

				- Đối với Unix, macOS (mới):
					+ '\n' (Line Feed - LF)
						-> Xuống dòng thì phải về đầu dòng (2 trong 1).

			* BS: phím [Backspace]
					+ '\b' (Backspace - BS): xóa ngược (xoá từ phải sang trái).

			* HT: phím [Tab]
					+ '\t' (Horizontal Tabulation - HT): tab ngang.

		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		│	Mọi thứ được nhập từ bàn phím đều là kí tự/chữ,			│
		│	nhưng trong quá trình tính toán sẽ có chuyển đổi để phù hợp	│
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------

		Có một kí tự cực kỳ quan trọng, cũng vô hình nhưng cần tồn tại để đánh dấu kết thúc chuỗi.
			-> Kí tự với mã ASCII là 0: 8 bit là 0000 0000.

			'\0': kí tự NULL - dùng như một cờ/cột mốc/dấu hiệu để đánh dấu việc kết thúc chuỗi trong RAM và trên ổ đĩa mà không làm ảnh hưởng đến nội dung.

				Ví dụ: báo hiệu kết thúc tập tin dữ liệu.

				-> Kí hiệu NULL được ra đời để đánh dấu/biểu diễn rằng không có gì cả.
					(Giống việc số 0 ra đời để nói rằng "không có gì cả".)

--------------------

		* Danh sách bảng mã ASCII:

			- 31 kí tự đầu tiên là tổ hợp phím (Non-printable): https://jkorpela.fi/chars/c0.html

			- Các kí tự còn lại (bao gồm bảng mã ASCII mở rộng): https://www.asciitable.com/

----------------------------------------

		[BỘ ĐỆM BÀN PHÍM / BỘ ĐỆM NHẬP XUẤT - BUFFER]

		Khi nhập kí tự/dữ liệu từ bàn phím, trong quá trình nhập (con trỏ còn nhấp nháy), dữ liệu sẽ chưa được đưa vào trong biến vội.
		
			- Thay vào đó, dữ liệu sẽ phải đi qua vùng RAM trung gian được gọi là bộ đệm nhập xuất (buffer), rồi sau đó mới được đẩy vào trong biến sau khi nhận được tín hiệu kết thúc việc nhập bằng cách nhấn nút [Enter].
				(Phím [Enter] vừa là một kí tự để xuống dòng, vừa là một tín hiệu để thông báo kết thúc việc nhập.)
			
			- Hoặc khi máy tính đang phải xử lý cùng một lúc nhiều tác vụ nặng và tốn tài nguyên (RAM và CPU), những tác vụ nhập xuất sẽ được đưa vào hàng đợi ở bộ đệm bàn phím, đến khi CPU rảnh thì sẽ quay trở lại xử lý sau. Giúp dữ liệu không bị mất khi khi CPU khi chưa kịp xử lý thông tin (có liên quan đến bộ lập lịch của CPU).

			-> Dữ liệu từ bàn phím đi vào một vùng RAM đệm (buffer) trước khi đi vào biến.

			- Bất kì ứng dụng nào trong máy tính có tính năng nhập liệu đều sẽ được cấp một vùng RAM phụ sử dụng chung cho tất cả các câu lệnh nhập của riêng ứng dụng đó, vùng RAM đặc biệt dành riêng cho một ứng dụng này được gọi là buffer (bộ nhớ đệm nhập xuất từ bàn phím).
		
			- Đây là một vùng RAM nhỏ, chứa được khoảng 2000 kí tự, không được dùng để chứa biến mà là để chứa những gì được gõ từ bàn phím nhằm đưa vào trong ứng dụng.
			
			- Mục đích là để tránh cho việc CPU bị nghẽn (bận rộn do xử lý không kịp), những lệnh đã được gõ mà chưa kịp được xử lý sẽ đi vào bộ đệm và nằm ở đấy chờ đến khi nào CPU rảnh sẽ xử lý sau.

			-> Buffer là vùng đệm (trung gian) của riêng mỗi ứng dụng, sử dụng để tạm lưu trữ giá trị trước khi CPU kịp xử lý do quá bận rộn, mục đích là để RAM để đồng bộ hoá tốc độ xử lý.
				(SRAM (Cache) - vùng đệm của CPU cũng được dùng để giải quyết câu chuyện tương tự như DRAM.)

					* CPU và RAM là hai thế giới chênh lệch nhau về tốc độ.
					  Câu lệnh trong RAM phải được đưa rất nhanh vào trong CPU để xử lý.
					  NNhưng vì CPU xử lý rất nhanh còn tốc độ đưa lệnh từ RAM vào CPU thì lại chậm,
					  nên trong trường hợp CPU chưa kịp xử lý thì RAM bắt buộc phải
					  đưa câu lệnh vào vùng đệm trung gian của CPU (Cache L1, L2, L3),
					  vùng đệm này được sắp xếp từ nhanh đến chậm
					  để phù hợp với tốc độ đưa dữ liệu vào của RAM.
						-> Tăng tốc cho CPU và không sợ bị thiếu lệnh để xử lý.

		-> Bộ đệm bàn phím (Buffer) là nơi chứa những kí tự hoặc câu lệnh để phòng khi CPU chưa kịp xử lý.
			=> Bước đệm trung gian để đồng bộ ở một tốc độ nào đó vì trước đó đã quá chênh lệnh với nhau về tốc độ xử lý.

		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		│	Buffer là vùng đệm của riêng mỗi ứng dụng, có dung lượng giới hạn,	│
		│	được sử dụng để tạm lưu trữ những giá trị được nhập vào từ bàn phím	│
		│	khi CPU chưa kịp xử lý do còn đang bận xử lý những tác vụ khác		│
		―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		- Vì kiểu kí tự rất đặc biệt khi có nhiều loại kí tự bị ẩn (có tồn tại về mặt ngữ nghĩa dữ liệu nhị phân, nhưng lại không hiển thị ra màn hình để có thể nhìn thấy được).
			+ Những gì được nhập từ bàn phím đều là kí tự, nên khi nhập sẽ có thể gặp hiện tượng "lạc trôi" kí tự (Bypass a statement), vì những kí tự "ẩn" đấy tuy không hiển thị ra màn hình nhưng vẫn tác động đến những kí tự khác.
			+ Lệnh nhập kí tự (scanf()) sẽ lấy tất cả những kí tự mà nó gặp được trong bộ đệm và trong đó có cả những kí tự không mong muốn - rác, có thể là do những câu lệnh trước để lại, chẳng hạn như xuống dòng ('\n' - enter).
			-> Cần đến bộ đệm bàn phím (buffer) vì đây là nơi lưu trữ mọi thứ được nhập từ bàn phím, kể cả những kí tự đặc biệt nhưng không hiển thị ra màn hình.
		
			Ví dụ: kí tự điều khiển/đặc biệt (enter, xoá, tab, khoảng trắng...) sẽ bị "ẩn".

		- Hiện tượng lệnh bị "lạc trôi" (tuy có thực sự chạy, nhưng lại cảm giác như có lệnh nào đó không được chạy / thực thi) chỉ xảy ra khi:
			+ Nhập tiếp kí tự/chuỗi (một câu dài) sau khi vừa nhập số.
				-> Lệnh nhập số "chơi đểu", chỉ dùng đúng phần số và để lại rác (phím cách [Space], phím xuống dòng [Enter], kí tự khác...) trong một vùng RAM đặc biệt gọi là buffer (bộ đệm bàn phím).
				-> Lệnh liền kề nhập kí tự/chuỗi thấy có kí tự trong bộ đệm, nên hốt luôn "rác" này gán vào biến kí tự/chuỗi.

			=> Câu lệnh "tài lanh" khi lấy rác trong bộ đệm để đem đi xử lý thay vì nhận trực tiếp từ bàn phím.

		- Không giống như những lệnh nhập số nguyên scanf("%d") hay số thực scanf("%f"),
		  lệnh nhập kí tự scanf("%c") và chuỗi scanf("%s") chỉ thích "đứng một mình",
		  nên nếu muốn đứng chung thì bắt buộc trước lệnh scanf() phải có ai đó dọn rác giùm
		  để đảm bảo an toàn cho những lệnh đến sau,
		  vì mọi thứ nếu đi từ bàn phím vào trong bộ đệm bàn phím thì đều được tính là kí tự.
			-> Phải có câu lệnh xoá bộ đệm bàn phím trước lệnh scanf("%c") và scanf("%s").

		* Câu lệnh để xóa bộ đệm chuẩn để dành cho việc nhập xuất dữ liệu:

			// Windows: fflush(stdin);
			//		-> Nếu sử dụng trình biên dịch MinGW, Microsoft Visual C++ (MSVC)

			//	    fpurge(stdin);
			//		-> Nếu sử dụng trình biên dịch GCC, Cygwin

			// macOS & Linux: __fpurge(stdin);

				// flush: don dẹp
				// purge: thanh trừng
				// stdin (standard input): vùng RAM chuẩn dành cho việc nhập dữ liệu
				//	-> Don dẹp vùng RAM chứa dữ liệu nhập từ bên ngoài vào

				Ví dụ:
					char tênBiến;
					fflush(stdin);
					scanf("%c", &tênBiến);


―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Mọi thứ đi qua bàn phím, thông qua bộ đệm, đều là kí tự/chữ,	│
│	chỉ là nó có hiển thị hoặc bị ẩn hay không			│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

	3. Ảnh (kỹ thuật số): là loại ảnh chạy trên máy tính mà khi phóng lớn lên, ta sẽ thấy được những ô vuông dạng lưới (điểm ảnh - pixel) được tô màu bằng đèn LED RGB (do transistor quyết định độ sáng/tối và mạnh/yếu). Độ phân giải càng cao thì sẽ càng có nhiều ô vuông/điểm ảnh (đèn LED), từ đó mà hình ảnh cũng sẽ càng mịn và ít bị răng cưa hơn.

	(Các ô vuông xếp cạnh thay vì hình tròn để đảm bảo không có khoảng hở màu đen giữa các điểm ảnh.)

------------------------------------------------------------

	4. Phim: thực chất cũng là những tấm ảnh xếp chồng lên nhau và được chiếu liên tiếp nhau. Độ mượt khi chuyển động của phim được quyết định bởi số khung hình trên giây (Frame Per Second - FPS).

------------------------------------------------------------

	5. Âm nhạc: dựa trên cường độ mạnh yếu của tín hiệu điện (dòng điện). [00:36:00]

------------------------------------------------------------

	6. Tài liệu/văn bản: tập hợp của hai loại dữ liệu cơ bản nhất là số và chữ.

	...

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Thiết bị nhập (Input): giúp mã hóa (chuyển đổi) thông tin	│
│	từ nhiều định dạng sang dạng dữ liệu mà máy tính có thể xử lý	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Thiết bị xuất (Output): thực hiện công việc giải mã dữ liệu	│
│	thành thông tin mà người sử dụng có thể hiểu được		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CÁCH HIỂN THỊ DỮ LIỆU]

Vì đều là On/Off nên CPU chỉ biết đấy là một số Byte (1, 2, 4, 8,...) nhưng không biết số Byte ấy là gì và nên cư xử như thế nào (như số nguyên, số thực,...).

* Sử dụng ký hiệu '%' để đặc tả / định dạng kiểu (hình dáng) của dữ liệu, dạy cho máy tính và ép máy tính phải tuân theo:
	- Cách in giá trị ra màn hình theo định dạng mà con người có thể hiểu được.
	- Cách chuyển giá trị được nhập từ bàn phím thành nhị phân, đưa dữ liệu từ bàn phím vào RAM và On/Off tương ứng.
		-> Đánh dấu, dấu hiệu chỉ dẫn để "điền vào chỗ trống" - trám vào.
 
------------------------------------------------------------

// Hãy cứ nhập từ bàn phím
%

// Nhận vào loại dữ liệu
u: unsigned (số nguyên không dấu - chỉ gồm số dương)
d: decimal (số nguyên có dấu - gồm cả số dương và âm)
l: long
f: float
c: char
s: string
p: pointer

byte		int		long		long long	float		double		char
 		%d		%ld		  %lld		 %f		 %lf		 %c


%u: address (unsigned integer) - hiển thị địa chỉ của một biến dưới dạng thập phân (10).
%p: address (pointer type data) - hiển thị địa chỉ của một biến dưới dạng thập lục phân (16).
	(Kết hợp với &biến / &phầnTử[Thứ] trong hàm printf() để hiển thị.)


* Định dạng cho dữ liệu:

	- Có thể quy định số lượng kí tự tối đa được phép hiển thị (độ rộng kí tự) bằng cách thêm con số phía sau kí tự '%', nếu độ rộng thực tế nhỏ hơn độ rộng tối đa thì giá trị sẽ được căn lề phải.

	- Dấu trừ '-' được sử dụng để căn lề trái thay vì căn lề phải như mặc định.

	Ví dụ:

		%4d: in số nguyên có độ rộng chiếm tối đa 4 kí tự.
		%-10s: in chuỗi có độ rộng chiếm tối đa 10 kí tự và căn lề trái.
		%5.2f: in số thực có tổng độ rộng tối đa 5 kí tự (bao gồm cả phần nguyên, phần dư và dấu chấm/phẩy) và tối đa 2 kí tự ở phần thập phân.

------------------------------------------------------------

Lệnh printf(), scanf() hoạt động theo cách "điền vào chỗ trống" - trám vào.

	Ví dụ 1:
		int a = 10, b = 3;

				    ---------------------
				    |	      |		|
				    v(2)      V(2)	|
		printf("a = %d; b = %d\n", a, b);	|
			    ^(1)	   ^(1)		|
			    |		   |		|
			    ------------------------------- "Điền vào chỗ trống" - trám vào

	Ví dụ 2:
		int yob;
		scanf("%d", &yob);
		       ^
		       |
		       -------------- Báo cho CPU biết rằng sẽ lưu dữ liệu vào RAM dưới dạng kiểu dữ liệu nào

==========================================================================================

[CÁCH LƯU SỐ NGUYÊN DƯƠNG VÀ NGUYÊN ÂM TRONG MÁY TÍNH]

"Tại sao trong máy tính, tuy chỉ có hai số 0 và 1 nhưng lại có thể giải quyết được số âm?"

Trong cuộc sống, dấu trừ (-) rất dễ để biểu diễn, có tác dụng biến một số dương thành nghịch đảo giá trị. Nhưng trong máy tính, vì không có dấu âm, nên cần phải có cách quy ước để máy tính có thể hiểu được. Để lưu trữ dữ liệu, ta sử dụng kỹ thuật số bù 2 (Two's complement).

	* Bù 1 (One's complement): chỉ đảo bit một lần, hệ quả +-0.
	* Bù 2 (Two's complement): lấp vào 2 lần để đủ thông tin. Có thể bị tràn bit (Overflow) nhưng vẫn đảm bảo đủ bit cho phần cần sử dụng.
		- Lần một - đảo bit (0 -> 1 và 1 -> 0).
		- Lần hai - cộng thêm 1.
	(Mẹo của những người thiết kế máy tính)

--------------------------------------------------------------------------------

* Sử dụng một số bit nhất định để lưu số nguyên dương và nguyên âm:

	- Bit dấu (Sign bit): bit bên trái nhất (trái cùng).
		* Quy ước:
			+ Số âm: 1
			+ Số dương: 0
	(Bị hụt mất 1 bit để biểu diễn giá trị.)

	- Nếu sử dụng 32 bit (4 Byte) để lưu con số nguyên (int) vừa vừa -> int: ±2 tỉ 1
	  Vì: số nguyên có 32 bit (4 Byte)
		- Chỉ sử dụng 31 bit để biểu diễn giá trị (2^31 ≈ 2 tỉ 1).
		- Bit thứ 32 - bit bên trái nhất được sử dụng để làm dấu:
			+ Số âm: 1
			+ Số dương: 0

		Ví dụ: giả sử có một loại máy tính chỉ sử dụng 4 bit để lưu số nguyên

			0 111
			^
			|
			---------------- bit bên trái nhất được sử dụng biểu diễn giá trị dương (+7)

			1 101
			^
			|
			---------------- bit bên trái nhất được sử dụng biểu diễn giá trị âm (-3)

--------------------------------------------------------------------------------

* Nguyên tắc biểu diễn số nguyên dương.
	- Bit dấu (trái cùng) phải là 0 (vì số âm được quy ước là 1).
	- Phần còn lại biểu diễn đại lượng số - sử dụng thuật toán đổi nhị phân (hệ 2) sang thập phân (hệ 10) như bình thường.

		Ví dụ:
			0 000	-> Dương 0
			0 001	-> Dương 1
			0 010	-> Dương 2
			0 011	-> Dương 3
			0 100	-> Dương 4
			0 101	-> Dương 5
			0 110	-> Dương 6
			0 111	-> Dương 7

------------------------------------------------------------

* Nguyên tắc biểu diễn số nguyên âm.
	- Nên căn từ số dương (mặc dù có rất nhiều kỹ thuật khác nhau).
	- Sử dụng kỹ thuật bù 2 để từ dương suy ra âm.
		-> Nghịch đảo về giá trị của một số dương bằng kỹ thuật bù 2.
			(Kỹ thuật bù 2 sẽ tự khiến cho bit trái cùng thành âm - đổi thành 1)

	* Kỹ thuật bù 2:
		1. Đảo toàn bộ bit của số dương (0 -> 1 và 1 -> 0).
		2. Cộng kết quả đảo bit với con số 1.
			-> Kết quả của phép cộng chính là số âm.

			Ví dụ:
				0 011	-> (+3)

				0 011	->	1 100	-> Đảo bit
					+	    1	-> Cộng kết quả đảo bit với 1
					-------------
						1 101	-> (-3) | Bù 2

				* Chứng minh 1101 là âm 3:
					(-3) + 3 = 0

						0 011 (+3)
					+	1 101 (-3)
					-------------
					      1	0 000 (0)
					      ^
					      |	
					      ----------- Bị dư ra nhưng không quan tâm vì chỉ sử dụng 4 bit

----------------------------------------

	* Nếu muốn từ âm suy ra dương, vẫn sử dụng kỹ thuật bù 2:

		Ví dụ:
			1 101	-> (-3)

			1 101	->	0 010	-> Đảo bit
				+	    1	-> Cộng kết quả đảo bit với 1
				-------------
					0 011	-> (+3)

------------------------------------------------------------

* Khi sử dụng 4 bit để biểu diễn con số:
	- Nếu có quan tâm đến âm-dương, số +7 là số lớn nhất.
		0 111	-> (+7)

		* Sử dụng bit trái cùng (mất đi 1 bit) chỉ để biểu diễn số âm hoặc dương.
			-> Có dấu (Signed): chơi với cả số âm và dương, có sử dụng bit dấu.
				(Cần có dấu để biết đấy là số âm hay số dương)


	- Nếu không quan tâm đến âm-dương, số 15 là số lớn nhất.
		1111	-> (15) <- Sử dụng thuật toán đổi nhị phân như bình thường
					[(1 * 2^3) + (1 * 2^2) + (1 * 2^1) + (1 * 2^0) = 8 + 4 + 2 + 1 = 15]

		* Sử dụng hết tất cả các bit để biểu diễn số dương, bỏ đi dấu cộng khi viết.
			-> Không có dấu (UnSigned): chỉ chơi với số dương, không sử dụng bit dấu.
				(Không cần dấu vì mặc định đã là dấu cộng - số dương)

----------------------------------------

	Ví dụ: khai báo một biến firstChar để chứa và hiển thị kí hiệu Omega

		// char ≈ số nguyên nhỏ ≈ số có dấu 1 Byte (8 bit)

		char firstChar = 234; // Nhị phân (lưu trong RAM): 1110 1010

		// %c -> Lấy tất cả các bit (8 bit) và chuyển đổi thành số dương thập phân,
		// 	 ánh xạ vào trong bảng mã ASCII để tìm ra Omega

		// %d -> Là số nguyên (int), theo nguyên tác phải loại bit đầu tiên
		//	 nên phần còn lại mới được tính giá trị - chỉ lấy 7 bit giá trị.
		// 	 Vì còn phải loại trừ đi bit đầu tiên để dành cho dấu (âm/dương)
		// 	 nên sẽ không đủ 234 như bình thường,
		// 	 do đó sẽ hiển thị kí số lạ nếu cố tình in ra
		// 	 mà không thông báo sử dụng không có dấu (UnSigned)

		// Ý nghĩa của con số khi muốn in mã bằng %d:
		//
		//		1 110 1010	// Số nhị phân của 234
		//
		//		0 001 0101	// Đảo bit
		//		+	 1	// Cộng 1
		//		----------
		//		  001 0110

		// Đổi kết quả từ hệ nhị phân (2) sang hệ thập phân (10):
		//
		//		  *  **
		//		654 3210
		//		001 0110
		//
		//		(2^4) + (2^2) + (2^1)
		//	=	  16  +   4   +   2
		//	=		 22
		//
		//			-> %d xem "1110 1010" là (-22) sau khi áp dụng kỹ thuật bù 2

		// Để %d sử dụng hết toàn bộ bit và in ra dưới dạng số nguyên dương,
		// không muốn loại trừ đi bit đầu tiên để dành cho dấu (âm/dương)
		// thì phải thông báo chỉ chơi với số nguyên dương bằng UnSigned

==========================================================================================

[BIỂU THỨC - EXPRESSION]

	* Toán hạng/Số hạng (Operand / Argument): là biến (variable) hoặc giá trị (value) sẽ được sử dụng/tham gia trong một phép toán (Operation).
	* Toán tử/Phép toán (Operator): là một phép thực hiện tính toán từ một số lượng đầu vào nào đó (gọi là toán hạng) để thành một giá trị đầu ra (output).

* Biểu thức (Expression): bao gồm số hạng và phép tính.

Máy tính (ngôn ngữ C) hỗ trợ và cung cấp một loạt các phép toán (Operator) để tính trên các con số.

	- Các phép toán (Operator) cơ bản có thể sử dụng:
		+ Cộng: 			+
		+ Trừ: 				-
		+ Nhân: 			*
		+ Chia lấy số nguyên:		/
		+ Chia lấy số dư (modulo):	%
			(Chỉ có tác dụng với hai số nguyên.)

------------------------------------------------------------

		+ Phép gán (Assignment Operator):
			= 	+=	-=	*=	/=	%=
			(Nhồi/Dồn/Gán - đã có sẵn rồi, ép thêm vô.)

------------------------------------------------------------

		+ Phép tính quan hệ/so sánh số lượng (Relational Operator):
			<	>	<=	>=	==	!=
			(Ngôn ngữ C cung cấp một loạt các ký hiệu/phép toán/toán tử
			 để ước lượng hơn thua, so sánh giữa các đại lượng số,
			 giúp ta xây dựng các biểu thức tính toán/các mệnh đề - câu phát biểu.)

			* Các phép toán quan hệ/so sánh:
				>	(lớn): xem vế trái có lớn hơn vế phải?
				>=	(lớn hơn hoặc bằng): xem vế trái có lớn hơn vế phải, nếu không thì xem vế trái có bằng vế phải? (chỉ cần một trong hai thoả mãn là đủ).
				<	(bé): 
				<=	(bé hơn hoặc bằng): 
				!=	(khác / không bằng): để nói rằng hai vế khác nhau, ký hiệu "!" được hiểu là phủ định.
				==	(bằng bằng): được hiểu là vế trái bằng vế phải.
					(Vì dấu "=" được dùng để gán (Assignment Operator) giá trị, nên để so sánh hai đại lượng và kết luận chúng bằng nhau thì phải sử dụng ký hiệu "==")

			* Kết quả của một phép/biểu thức so sánh là đúng hoặc sai. Vì vậy, ta có thể lưu giá trị (tính đúng/sai) của biểu thức vào trong một biến.
				- Quy ước (trong ngôn ngữ C):
					+ Đúng: 1
					+ Sai: 0
				- Quy ước (trong ngôn ngữ Java):
					+ Đúng: True
					+ Sai: False
				-> Một biểu thức so sánh, tuỳ đúng hay sai thì sẽ mang giá trị 0 hoặc 1.
					(Biểu thức so sánh ≈ giá trị)

					Ví dụ:
						int ketQua = 5 > 6;
						// Ngoài đời: Sai
						// Trong C (CPU): giá trị = 0

--------------------------------------------------------------------------------

	- Số toán hạng là lượng số/số ngôi/đối tượng đang thực hiện phép toán.
		+ 2 ngôi: cần tối thiểu 2 biến (2 vế ở 2 bên) để tính toán.

------------------------------------------------------------

		+ 1 ngôi (Tăng/Giảm tự thân - Increment/Decrement Operator): chỉ cần 1 biến là đã có thể tính toán.
			-> Chỉ duy nhất một toán hạng (giá trị nhập vào).

			Kí hiệu:
				++	--
				(Thứ tự nằm của các phép tăng/giảm tự thân (trước hoặc sau tên biến) chỉ thật sự quan trọng khi tham gia vào một biểu thức nào đó.)

			Ví dụ:

				// Sau lệnh này, biến sẽ được tự tăng hoặc giảm 1 đơn vị
				// Nếu đứng một mình thì sẽ không có chuyện gì xảy ra,
				// nuy nhiên, lệnh sẽ khá "cà chớn"
				// khi được lắp ghép chung với các biểu thức khác

				// Nếu đứng một mình thì có thể viết kiểu nào cũng được
				// Lệnh '++' và '--' nằm trước hay sau biến
				// đều không ảnh hưởng đến kết quả
				// (đều tăng biến lên một giá trị)
				int bien = 10;

				++bien;
				printf("#1 increasing by 1: n = %d\n", n); // 11

				bien++;
				printf("#1 increasing by 1: n = %d\n", n); // 12


				// Nhưng khi đưa lệnh '++' và '--' vào trong biểu thức hoặc phép gán
				// thì lệnh '++' và '--' nằm trước hay sau
				// sẽ cho ra kết quả rất khác nhau
				// vì nguyên tắc thực thi của CPU, tuỳ vào cách viết
				// nó sẽ tăng/giảm trước rồi mới tính toán
				// hay tính toán trước rồi mới tăng/giảm
				int bien = 10;
				int ketQua;
	
				ketQua = bien++;
				printf("Ket qua = %d; bien = %d\n", ketQua, bien);
				// ketQua = 10; bien = 11
	
				ketQua = ++bien;
				printf("Ket qua = %d; bien = %d\n", ketQua, bien);
				// ketQua = 12; bien = 12

				ketQua = (bien++ + 5);
				printf("Ket qua = %d; bien = %d\n", ketQua, bien);
				// ketQua = 17; bien = 13

			* Lưu ý: đừng viết code kiểu mơ hồ (chơi gộp) nếu không hiểu và không kiểm soát được giá trị.
				Ví dụ:
					* Không nên: int ketQua = ++bien; // Tăng rồi gán - Không sai nhưng không nên sử dụng nếu chưa hiểu rõ cơ chế hoạt động

					* Nên:
						- Nếu muốn tăng rồi gán:
									bien++;
									ketQua = bien;

						- Nếu muốn gán rồi tăng:
									ketQua = bien;
									bien++;

------------------------------------------------------------

		+ 0 ngôi: hằng số.

--------------------------------------------------------------------------------

* Lưu ý: trong một biểu thức chứa các kiểu dữ liệu khác nhau, kết quả trả về có thể nằm ngoài dự đoán nếu chúng ta không hiểu rõ cơ chế.
	* Nếu biểu thức tính toán (cộng, trừ, nhân, chia) có chứa:
		- Chỉ có số nguyên.
			-> Kết quả tính toán: số nguyên.

		- Số thực cùng với số bất kỳ.
			-> Kết quả tính toán: số thực (do miền giá trị của số thực rộng hơn).

==========================================================================================

* Cách xử lý câu lênh của CPU và RAM

// Khai báo biến n có giá trị là 10
int n = 10;

// Câu lệnh tính toán để tăng n lên 1 đơn vị/giá trị
n = n + 1	// Đây là câu lệnh mà CPU được yêu cầu phải làm

	1. RAM chứa giá trị/vùng RAM biến "n" và câu lệnh "n = n + 1"
	2. CPU vào trong RAM để đọc/lấy giá trị "n"
	2. CPU vào trong RAM để đọc/lấy câu lệnh "n = n + 1"
	3. CPU tính toán câu lệnh "n + 1" và trả/gán lại giá trị của "n" về cho RAM để lưu trữ
		-> RAM chứa giá trị và câu lệnh, CPU lấy giá trị và thực thi lệnh rồi cất giá trị vào RAM.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Câu lệnh nằm trong RAM, CPU sẽ đọc từ RAM và tiến hành xử lý rồi lưu trữ lại vào RAM	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[MỆNH ĐỀ / BIỂU THỨC LOGIC / PHÉP LUẬN LÝ - STATEMENT]

	* Mệnh đề (Statement): là câu phát biểu liên quan đến đúng và sai.
		-> Sự kết hợp giữa các biểu thức so sánh đúng và sai.

* Toán tử logic (Logical Operator): là một mệnh đề phức tạp, gộp các mệnh đề (câu phát biểu) con lại với nhau.
	-> Phép toán/cách ghép nối các mệnh đề/biểu thức logic/câu so sánh.

Ngôn ngữ C cung cấp ký hiệu/toán tử để kết nối các câu phát biểu, các mệnh đề so sánh (statement) để cho ra một kết quả đúng/sai cuối cùng.
	- Và - AND (&&): phụ thuộc cực kỳ chặt chẽ giữa các mệnh đề (câu phát biểu).
	- Hoặc - OR (||): phụ thuộc lỏng lẻo.
	- Đảo - NOT (!): 

	Ví dụ 1: con vào Thành phố học:
		- Không được đổi chuyên ngành
		- Không được rớt/nợ môn trong quá trình học
		- Điểm trung bình >= 8
		- Tốt nghiệp đúng hạn
			-> Phải thoả mãn tất cả các điều kiện trên, không được thiếu dù chỉ một cái.

	Ví dụ 2: nếu thời tiết đẹp VÀ có tiền.
			-> Thoả mãn cả hai thì đi chơi.

	Ví dụ 3: thanh xuân là khi tuổi nằm trong đoạn [20..30]
			-> (tuoi >= 20 && tuoi <= 30)

	Ví dụ 4: tui HOẶC bạn trả tiền cho bữa ăn đều được.
			-> Một trong hai đều được.

--------------------------------------------------------------------------------

[BẢNG SỰ THẬT / BẢNG CHÂN TRỊ  - TRUTH TABLE]

* Cách suy luận kết quả của một biểu thức phức tạp gồm lộn xộn AND hoặc OR.
	(Một câu phát biểu mà bên trong có những biểu thức so sánh và nối với nhau bằng AND hoặc OR)
	-> "Kết quả cuối cùng là đúng hay sai khi mỗi phép so sánh luôn đúng hoặc sai?"

	- Ta cần một bộ quy tắc để tìm nhanh kết quả cuối cùng của một mệnh đề rất phức tạp gồm một đống AND hoặc OR.
		-> Sử dụng bảng sự thật/bảng chân trị (Truth Table) để tìm đúng/sai khi nhiều phép so sánh được gộp trong một câu.

------------------------------------------------------------

Mệnh đề		Phép toán	Mệnh đề		Kết quả
   A		   &&		   B		Đúng/Sai

(Bản thân A, B đã là một biểu thức so sánh	<	>	<=	>=	==	!=)

----------------------------------------

[TOÁN TỬ AND - &&]

	Mệnh đề 1	Phép toán	Mệnh đề	2	Kết quả
	  Sai		   &&		  Sai		  Sai
	  Sai		   &&		  Đúng		  Sai
	  Đúng		   &&		  Sai		  Sai
	  Đúng		   &&		  Đúng		  Đúng

=> Mệnh đề/Biểu thức/Toán tử AND (&&) chỉ đúng khi tất cả đều đúng.
	(Tỷ lệ đúng 25% và tỷ lệ sai 75%)

----------------------------------------

[TOÁN TỬ OR - ||]

	Mệnh đề 1	Phép toán	Mệnh đề	2	Kết quả
	  Sai		   ||		  Sai		  Sai
	  Sai		   ||		  Đúng		  Đúng
	  Đúng		   ||		  Sai		  Đúng
	  Đúng		   ||		  Đúng		  Đúng

=> Mệnh đề/Biểu thức/Toán tử OR (||) chỉ sai khi tất cả đều sai.
	(Tỷ lệ đúng 75% và tỷ lệ sai 25%)

----------------------------------------

[TOÁN TỬ NOT - !]

!(biểu thức): phép đảo/nghịch đảo, làm ngược lại (tương phản).
	!(đúng) -> sai
	!(sai) -> đúng

	Ví dụ: !(x < 1 || x > 100)	<- Nghịch đảo của kiểm tra "ngoài miền"
		-> (x >= 1 && x <= 100) <- Kiểm tra "trong miền"

==========================================================================================

[CÂU LỆNH / CẤU TRÚC ĐIỀU KHIỂN - LOGIC CONSTRUCT / CONTROL STRUCTURE]
[ĐIỀU HƯỚNG CPU THỰC THI CÁC CÂU LỆNH BẰNG: IF-ELSE, SWITCH-CASE, FOR, WHILE, DO-WHILE]

* Cách tổ chức các câu lệnh của lập trình (Logic Construct): cách phối hợp một loạt các câu lệnh, kịch bản (ý tưởng) để điều khiển và vận hành ứng dụng (ví dụ: if, do, while, for...).
	-> Điều khiển trật tự thực hiện (flow control) của các câu lệnh trong chương trình.

	* Cấu trúc dữ liệu (Data structure): cách tổ chức và lưu trữ dữ liệu trong máy tính để sử dụng dữ liệu có hiệu quả.

------------------------------------------------------------

* Nếu xem các câu lệnh như một đại lộ:
	- Sequential order/Sequence construct (Thứ tự tuần tự / Cấu trúc trình tự): mặc định, CPU sẽ chạy các câu lệnh theo thứ tự tuần tự từ trên xuống dưới - câu lệnh nào được viết trước thì sẽ được thực thi trước.
		-> CPU đi theo một đường thẳng từ trên xuống (tuyến tính).

	-  Selection construct (Cấu trúc rẽ nhánh): có thể số câu lệnh sẽ rất nhiều, nhưng CPU không cần thiết phải thực thi hết tất cả các câu lệnh, có những lệnh sẽ được thực thi vào một lúc nào đó dưới một tình huống/điều kiện (con số/giá trị) nào đó - thực thi tuỳ thuộc vào ngữ cảnh.
		-> CPU "chặt hẻm" khi thoả mãn một điều kiện nào đó.
			=> Câu lệnh if và các biến thể ra đời (if, if/else, if/else/if, swith-case....)
		(Tận dụng kết quả đúng/sai của phép so sánh để rẽ nhánh, điều hướng việc xử lý.)

------------------------------------------------------------

* Các loại cấu trúc điều khiển:

	1. Cấu trúc rẽ nhánh (Selection Construct):
		if / if-else
		switch-case

	2. Cấu trúc lặp (Looping Construct):
		while
		do-while
		for

--------------------------------------------------------------------------------

[CÂU LỆNH IF]

	* Quy ước trong các ngôn ngữ lập trình:
		Đúng = True = 1 } Thành công
		Sai = False = 0 } Thất bại

* Cấu trúc:

	// Khi gặp một tình huống đúng thì thực thi một nhóm các câu lệnh
	// Cặp ngoặc nhọn {} trong lập trình dùng để nhóm các câu lệnh - block of code
	if (điều gì đúng hoặc sai / mệnh đề so sánh mà kết quả trả về là đúng hoặc)
	{
		thì làm những gì ở đây;
		những lệnh sẽ thực thi khi điều kiện ở trên đúng;
	}

		Ví dụ:
			if (đúng là trời mưa / trời == mưa)
			{
				thì đem đồ đang phơi ngoài sân vô trong nhà;
				thì đóng hết tất cả các cửa sổ lại kẻo mưa tạt;
			}

* KHÔNG ĐƯỢC: if (...); <- Xét về mặt logic thì đây là câu cụt và khiến CPU chạy sai vì kí tự ';' được xem như là kết thúc lệnh.

------------------------------------------------------------

[CÂU LỆNH IF-ELSE]

Cách viết một loạt các lệnh if, về mặt thuật toán, nếu viết quá nhiều if thì CPU sẽ hơi bị lag khi phải liên tục kiểm tra xem liệu if có đúng. Từ đó, sử dụng mệnh đề else để loại trừ những điều kiện có thể loại trừ được, vì có một số điều nếu đã đúng thì những điều ngược lại sẽ không bao giờ xảy ra.

	(Trong câu lệnh if-else, else được hiểu là "phần còn lại" chứ không phải tương phản/đối nghịch.)

	Ví dụ:
		- Hiểu sai:
				if (a > b)
					...;
				else (a < b) <- Hiểu sai vì đây là cách hiểu tương phản/đối nghịch
					...;
		- Hiểu đúng:
				if (a > b)
					...;
				else (a <= b) <- Hiểu đúng vì đây là cách hiểu "phần còn lại"
					...;

Trong mệnh đề else có thể có thêm những if và else khác - if-else lồng nhau (Nested).
	- Tuy không quy định chỉ được phép lồng bao nhiêu cấp (nghĩa là có thể lồng vô hạn cấp), nhưng theo chuẩn lập trình thì chỉ nên lồng tối đa bốn cấp.
	- Nếu lồng quá nhiều cấp thì sẽ khiến chương trình khó nhìn và kiểm soát, đồng thời cũng làm giảm hiệu năng khi biên dịch chương trình.
	-> Tuy các câu lệnh được phép lồng nhau, nhưng không có nghĩa là được phép lồng nhiều cấp.

	Ví dụ:
		if (a > b)
			...

		// else ở đây được hiểu là ngược lại của a > b,
		// có thể a == b hoặc a < b
		else if (a < b)
			...

		// Đây là else của if (a < b)
		else // (a == b)
			...

----------------------------------------

* Phong cách viết if-else: khi nào nên viết toàn bộ bằng if, khi nào nên sử dụng if-else lồng nhau.

	Ví dụ 1: một trọng tài trong môn bóng đá mới vào nghề.
		* Chỉ đem theo một quyển sách "Những lỗi vi phạm - Cao cấp"
		
		// Đọc quyển "Những lỗi vi phạm - Cao cấp",
		// nếu thấy có lỗi vi phạm như trong sách mô tả
		if (lỗi-của-cầu-thủ == lỗi-nặng)
			phạt-thẻ-đỏ();
			// Tiến hành xử phạt bằng thẻ đỏ
			// và cho phép trận đấu được tiếp tục

		// Nếu không thấy quyển "Những lỗi vi phạm - Cao cấp"
		// có đề cập đến lỗi vi phạm
		else
			// Không cần biết lỗi vi phạm là gì
			// và vi phạm ở mức độ "vừa" hay mức độ "nhẹ"
			phạt-thẻ-vàng();
			// Tiến hành xử phạt bằng thẻ vàng
			// và cho phép trận đấu được tiếp tục

		-> Chỉ cần một quyến sách là đã giải quyết được ba trường hợp.
		-> Nếu đã rơi vào trường hợp đầu tiên, có thể mặc kệ những trường hợp còn lại và không cần phải kiểm tra thêm nữa.

	Ví dụ 2: một trọng tài trong môn bóng đá mới vào nghề.
		* Cẩn thận đem theo cả ba quyển sách:
			1. "Những lỗi vi phạm - Cao cấp"
			2. "Những lỗi vi phạm - Trung cấp"
			3. "Những lỗi vi phạm - Sơ cấp"
		
		// Đọc quyển "Những lỗi vi phạm - Cao cấp",
		// nếu thấy có lỗi vi phạm như trong sách mô tả
		if (lỗi-của-cầu-thủ == lỗi-nặng)
			phạt-thẻ-đỏ();
			// Tiến hành xử phạt bằng thẻ đỏ
			// và cho phép trận đấu được tiếp tục

		// Mặc kệ trong quyển "Những lỗi vi phạm - Cao cấp"
		// có đề cập đến lỗi hay chưa,
		// vẫn tiếp tục đọc quyển "Những lỗi vi phạm - Trung cấp"
		// và nếu thấy có lỗi vi phạm như trong sách mô tả
		if (lỗi-của-cầu-thủ == lỗi-vừa)
			phạt-thẻ-vàng();
			// Tiến hành xử phạt bằng thẻ vàng
			// và cho phép trận đấu được tiếp tục

		// Mặc kệ trong quyển "Những lỗi vi phạm - Trung cấp"
		// có đề cập đến lỗi hay chưa,
		// vẫn tiếp tục đọc quyển "Những lỗi vi phạm - Sơ cấp"
		// và nếu thấy có lỗi vi phạm như trong sách mô tả
		if (lỗi-của-cầu-thủ == lỗi-nhẹ)
			phạt-thẻ-vàng();
			// Tiến hành xử phạt bằng thẻ vàng
			// và cho phép trận đấu được tiếp tục

		-> Cần đến ba quyển sách để giải quyết được ba trường hợp.
		-> Nếu đã rơi vào trường hợp đầu tiên, vẫn phải cẩn thận kiểm tra thêm hai trường hợp còn lại cho chắc ăn.

----------------------------------------

* Lưu ý: if và else chỉ là một câu, bao gồm hai góc nhìn của cùng một vấn đề - if và ngược lại của if (else).
	-> Được xem như là một lệnh duy nhất (có thể bỏ cặp dấu ngoặc nhọn {} nếu chỉ sử dụng một lệnh).

------------------------------------------------------------

[THUẬT TOÁN: KỸ THUẬT ĐẶT BIẾN CỜ - FLAG VARIABLE]

	* Nguyên tắc suy đoán vô tội/giả định vô tội (The presumption of innocence): nghi can bị bắt vì bị tình nghi nhưng không được kết luận rằng có tội nếu chưa chứng minh được là có tội.
		-> Mọi nghi can đều vô tội cho đến khi được chứng minh là có tội.
			(Buộc tội phải dựa trên những chứng cứ xác thực.)

Trong lập trình, cứ giả định một điều gì là đúng cho đến khi có tín hiệu báo rằng điều đó là sai. Kỹ thuật đặt cờ thường được sử dụng trong tình huống có nhiều dữ liệu. Giả định một điều gì đó ngay từ đầu và sẽ phất (thay đổi trạng thái) khi dữ liệu có điều gì đó đặc biệt.
	-> Cho biến giữ một trạng thái nào đó.

	Ví dụ: tìm số lớn nhất trong ba số (hoặc giữa một đống số)
		a = 5, b = 6, c = 7

		// Cách 1: cách làm truyền thống
		if (a > b && a > c)
			max = a;
		// if (a > b && b < c)	// ví dụ: a = 15, b = 6, c = 17
		//	max = ???
		// Nếu viết if-else không khéo thì sẽ có rất nhiều trường hợp do số tổ hợp quá nhiều


		// Cách 2: sử dụng biến cờ
		// Kiểm tra hết tất cả các tập giá trị/các trường hợp có thể xảy ra
		// chứ không loại trừ (không sử dụng if-else)
		biến trung gian: max = a;	// Giả sử: max = a = 5
						// Có thể đúng hoặc sai khi khẳng định rằng max = a,
						// và ở đây, nếu sai thì vẫn có thể sửa

		// Sự thật rằng nếu b > max
		if (b > max)
			max = b;	// Phất cờ nếu có thay đổi trạng thái

		// Sự thật rằng nếu c > max
		if (c > max)
			max = c;	// Phất cờ nếu có thay đổi trạng thái

		// -> Biến a vẫn là lớn nhất cho đến khi chứng minh được có biến nào khác (b hoặc c) lớn hơn

--------------------------------------------------------------------------------

[CÂU LỆNH IF-ELSE IF VÀ SWITCH-CASE]

	[SO SÁNH IF VS. IF-ELSE IF VÀ SWITCH-CASE]

Khi trong code có quá nhiều if-else lồng nhau (Nested) do trục số nhiều đặt nhiều khoảng/đoạn trên các tập giá trị rời rạc. Sử dụng cách viết đơn giản hơn để thay cho các if ngang nhau hoặc if-else lồng nhau nhiều cấp: Switch-Case.

	Ví dụ: biến có giá trị nào đó

	tênBiến = giá-trị;

	// Cách viết 1			// Cách viết 2			// Cách viết 3
	// "Nỗi đau kéo dài"		// "Đau một lần rồi thôi"	// "Đau một lần rồi thôi"

	// CPU có thể bị lag		// CPU sẽ loại trừ nếu đã đúng	// Tương đương với Cách viết 2,
	// do phải liên tục		// nhưng vẫn sẽ lag		// cũng loại trừ nếu đã đúng
	// kiểm tra điều kiện if	// nếu đến if cuối mới đúng	// và vẫn lag nếu đến case cuối mới đúng

	if (biến so sánh...)		if (biến so sánh...)		switch(tênBiến)
		thì làm gì...;			thì làm gì...;		{
										case giá-trị 1:
	if (biến so sánh...)		else if (biến so sánh...)			thì làm gì...;
		thì làm gì...;			thì làm gì...;				break;
										case giá-trị 2:
	if (biến so sánh...)		else if (biến so sánh...)			thì làm gì...;
		thì làm gì...;			thì làm gì...;				break;
										case giá-trị ...:
											thì làm gì...;
											break;

										// Sau khi loại trừ tất cả
										// (else của tất cả)
										default:
											thì "chốt" làm gì...;
									}

------------------------------------------------------------

* Lưu ý:
	- Câu lệnh break (ngừng) được sử dụng để bỏ qua toàn bộ những câu lệnh còn lại (nếu có) và lập tức thoát hẳn ra khỏi cả câu lệnh điều kiện (hoặc vòng lặp), chứ không phải chỉ đơn giản là thoát ra khỏi trường hợp (case) đang rơi vào.

	- Câu lệnh continue (tiếp tục) cũng được sử dụng để bỏ qua toàn bộ những câu lệnh còn lại (nếu có), nhưng sẽ không thoát hẳn ra khỏi câu lệnh điều kiện (hoặc vòng lặp) mà tiếp tục một chu kỳ mới.

	- Nếu các case là một dạy liên tục nhau (ví dụ: số nguyên - 0, 1, 2, 3...) thì sẽ chạy nhanh hơn.

	- Nếu ở các case của câu lệnh switch-case không có câu lệnh break (ngừng), bắt đầu từ nơi thoả mãn điều kiện trở xuống, CPU vẫn sẽ chạy cho đến khi nào gặp break hoặc đến cuối switch-case mới dừng.

	- Để sử dụng switch-case, biến bắt buộc phải là những kiểu dữ liệu rời rạc và đếm được (int hoặc char).
		+ Vì chúng sẽ giúp lựa chọn được một cách rõ ràng khi giữa hai giá trị không còn một giá trị nào khác.
		+ Sở dĩ kí tự (char) có thể sử dụng trong switch-case là vì nó được chống lưng bởi một con số nguyên (int) trong bảng mã ASCII.
		+ Không được sử dụng dạng chuỗi hoặc số thực (float, double) - một loại số tương đối, vì giá trị giữa những số thực với nhau sẽ không chính xác khi có thể có vô hạn phần thập phân, đó là do chúng ta đang sử dụng chuẩn IEEE 754 để biểu diễn số thực và chỉ biểu diễn ở mức gần đúng (ví dụ: 0.1 + 0.2 = 0.30000000000000004).
			* IEEE (Institute of Electrical and Electronics Engineers): Hội Kỹ sư Điện và Điện tử - một tổ chức phi lợi nhuận. Họ tổ chức rất nhiều phiên họp, mỗi phiên họp bàn luận về một chủ đề và được đánh một con số.

		Ví dụ: thử sử dụng loại số tương đối (số thực) trong câu lệnh switch-case
			
			float pi = 3.14;
			switch(pi)
			{
				case 3.14:
					printf("Ahuhu, bao loi roi :<\n");
					break;
			}

			// [Error] switch quantity not an integer

			// [Error] case label does not reduce to an integer constant

	- Về mặt lý thuyết, switch-case sẽ nhanh hơn so với if-else; nhưng ta vẫn sẽ ưu tiên if-else vì cấu trúc này có thể so sánh được những giá trị là số thực vã chuỗi.

--------------------------------------------------------------------------------

[VÒNG LẶP / LỆNH LẶP - LOOP]

* Vòng lặp (Loop): thay vì cho CPU thực thi một cách tuần tự, thì bây giờ ép CPU phải vòng lên và làm một việc liên tục đến một số lần được chỉ định rồi mới được dừng hoặc thậm chí là lặp vô tận. CPU với xung nhịp (clock) càng khoẻ thì vòng lặp sẽ chạy càng nhanh.
	-> Lặp lại một lệnh hoặc nhóm lệnh với một số lần nào đó.

	for ≈ do-while ≈ while
		* foreach thuộc nhóm for, duyệt từ đầu đến cuối mảng/dãy số. Với mọi phần tử trong mảng/tập hợp.

	(Bên cạnh ba loại vòng lặp chính đạo, ta còn có một vòng lặp tà đạo: goto)

------------------------------------------------------------

* Các loại hình thức lặp:

----------------------------------------

	1. Lặp và biết trước số lần lặp (điều kiện thoát).

		Ví dụ 1: giám thị kiểm tra thông tin của những thí sinh dự thi tại một phòng thi với số lượng thí sinh được biết trước, nếu đã kiểm tra đủ 50 sinh viên thì dừng việc kiểm tra lại vì số lượng sinh viên trong một phòng thi đã được quy định sẵn.

		Ví dụ 2: nhập từ bàn phím 5 con số nguyên, nhập đủ 5 số thì dừng và không cho nhập thêm.

		Ví dụ 3: một số hệ thống bảo mật chỉ cho phép nhập sai mật khẩu/mã số từ 3 đến 5 lần, nếu nhập sai quá số lần quy định thì hệ thống sẽ tự động thoát.

		Ví dụ 4: khi đi ăn nhà hàng, nếu gọi mười món thì ăn đến món thứ mười sẽ dừng.

		Ví dụ 5: trong lập trình

			// Điều kiện thoát: i <= 100
			for (int i = 1; i <= 100; i++)
				printf("%d ", i);

----------------------------------------

	2. Lặp nhưng chưa biết trước số lần lặp, "gấp đôi đến chết". Cứ tiếp tục làm đến khi nào được thấy đủ, bảo dừng hoặc nhìn dấu hiệu xảy ra thì mới dừng.

		Ví dụ 1: khi đi đường, cứ chạy mãi cho đến khi nào gặp [một số dấu hiệu] thì dừng xe.

		Ví dụ 2: nhập từ bàn phím một số lượng số nguyên, không biết phải nhập bao nhiêu số, chỉ biết là đến khi nào nhấn số 0 thì dừng.

		Ví dụ 3: một hệ thống cho phép chọn tên đăng nhập khi đăng ký tài khoản, nhưng nếu chọn tên bị trùng thì sẽ hiển thị thông báo lỗi, đến khi nào chọn được tên hợp lệ thì sẽ kết thúc quá trình kiểm tra.

		Ví dụ 4: khi đi ăn búp phê, ăn đến khi nào no (hoặc đến khi gọi món tráng miệng) thì dừng.

		Ví dụ 5: trong lập trình

			// Chưa biết trước số lần lặp
			int count = 1;
			for (;;)
			{
				printf("%d ", count);
				count++;

				// Làm đến khi count == 101 thì dừng (thấy dấu hiệu count == 101 thì dừng)
				if (count == 101)
					break;
			}

------------------------------------------------------------

[VÒNG LẶP FOR]

for: chỉ cho CPU biết cần phải lặp bao nhiêu lần. Thích hợp (vì dễ viết) dành cho loại vòng lặp đã biết trước số lần lặp.

	// * Biến chặn đầu: khởi đầu (khai báo biến và gán giá trị) từ đâu trong "mê cung", điều kiện ban đầu.
	//	-> Trạng thái khi bước vào vòng lặp.

	// * Kiểm tra chặn đuôi để kết thúc: kiểm tra điều kiện, nếu còn đúng là còn tiếp tục lặp, hết đúng thì dừng lặp.
	//	-> Trạng thái/điều kiện dừng lặp, còn đúng là còn lặp - "Còn thấy đau là còn thương".
	//	(Nếu điều kiện dừng lặp độc lập với biến đếm (mãi mãi đúng) thì sẽ khiến vòng lặp bị vô tận.)

	// * Bước nhảy: thay đổi giá trị của bước nhảy (tăng hoặc giảm) sau mỗi lần lặp, kết hợp với việc kiểm tra điều kiện để quyết định việc dừng lặp.
	//	-> Biến đếm số lần cần lặp.

	// (giá trị khởi tạo; điều kiện lặp; bước lặp)
	for (biến chặn đầu; kiểm tra chặn đuôi; bước nhảy)
		những lệnh cần lặp nằm trong đây;

	// Biến i (index - chỉ mục đếm/số đếm) là biến đếm siêu cục bộ (super local variable),
	// chỉ có hiệu lực trong for, xong vòng lặp for thì biến không còn chiếm trên RAM nữa
	// ("Hết cơm, hết rượu hết ông tôi" - Hết vòng lặp thì hết biến,
	//  trong khi biến trong hàm thì phải hết hàm mới hết biến.)

----------------------------------------

* Cú pháp viết vòng lặp for:

	// * Theo chuẩn cũ,
	// nếu không khởi động lại biến i mà đem đi sử dụng tiếp
	// thì sẽ rất dễ gặp phải hiệu ứng phụ (Side effect)
	int i;
	for (i = 0; i < n; i++) {}

	// * Theo chuẩn mới: std=c99 │ cách viết for theo chuẩn ngôn ngữ C
	//			     │ được ban hành vào năm 1999
	// biến i trở thành biến siêu cục bộ (super local variable)
	// và chỉ có ý nghĩa trong vòng for
	for (int i = 0; i < n; i++) {}

	// Nếu viết theo chuẩn mới,
	// đối với những phiên bản Dev-C++ cũ hơn có thể bị lỗi
	// * Khắc phục:
	//	-> Vào menu [Tools]
	//	-> Compiler Options...
	//	-> Tại tab [General]
	//	-> [✓] Add the following commands when calling the compiler: -std=c99

	Ví dụ: có thể xem sự sống của con người như một vòng lặp.

		// Nếu biết trước chỉ có 60 năm (≈ 21914 ngày) cuộc đời
		for (int ngayTuoi = 1; ngayTuoi >= 21914; ngayTuoi++)
			sinhHoatHangNgay();

----------------------------------------

Vòng lặp for được dùng để lặp một số câu lệnh nào đó. Vì vậy, bên trong for có thể chứa những câu lệnh khác, chẳng hạn như if.

	* Vòng lặp vô tận: khi không có cách gì để khiến điều kiện bị sai và thoát vòng lặp.
Có thể tận dụng câu lệnh break - cửa thoát hiểm (giống như trong switch-case) để thoát vòng lặp vô tận.

	Ví dụ:
		// Vòng lặp sẽ lặp vô tận vì điều kiện "i <= i" là điều kiện luôn luôn đúng
		// Ngoài ra, có thể thay điều kiện dừng "i <= i" của vòng lặp
		// bằng bất kì điều kiện luôn luôn đúng nào, chẳng hạn như: 69 < 96, 39 < 79...
		for (int i = 1; i <= i; i++)
		{
			printf("%d ", i);

			// Câu lệnh if lồng trong vòng lặp for
			if (i == 100)

				// Câu lệnh break dùng để thoát vòng lặp vô tận
				break;
		}

	* Lưu ý:
		- Mặc dù có thể được lồng trong câu lệnh điều kiện if, nhưng break vẫn sẽ áp dụng cho việc thoát khỏi vòng lặp hiện tại (vòng lặp gần nhất, trực tiếp có chứa break bên trong).

		- Câu lệnh continue cũng được sử dụng trong vòng lặp với mục đích bỏ qua vòng lặp hiện tại và lập tức đi đến vòng lặp tiếp theo (sau khi đã làm thay đổi biến đếm/biến chạy).
			+ Nên hạn chế sử dụng, vì đây là một trong những câu lệnh khiến chương trình "lội ngược dòng".
			+ Khi một chương trình bị ngắt ngang giữa chừng sẽ gây khó khăn trong việc kiểm soát khi chương trình bắt đầu được mở rộng.
			+ Ta hoàn toàn có thể sử dụng câu lệnh điều kiện if để lồng bên trong vòng lặp thay vì sử dụng continue.

------------------------------------------------------------

[THUẬT TOÁN: KỸ THUẬT NHỒI LIÊN TIẾP - ACCUMULATION]

Để tính tổng của dãy số nguyên, ví dụ từ 1..100, ta có thể sử dụng mẹo cộng đầu-đuôi rồi nhân số cặp:

	Ví dụ: tính tổng 1 + 2 + 3 + 4 + 5 + 6
		- Cộng đầu-đuôi:
					(1 + 6) = 7 <- 1 cặp
					(2 + 5) = 7 <- 1 cặp
					(3 + 4) = 7 <- 1 cặp
		- Nhân số cặp: 7 (tổng) * 3 (số cặp)
				-> Kết quả: 21

Nhưng cách mẹo trên chỉ thực hiện được với dãy số đều nhau và sẽ không thực hiện được nếu đấy là dãy số lộn xộn. Để giải quyết bài toán, ta sử dụng thuật toán "nhồi liên tiếp" (accumulation) - lặp để nhồi.
	* Accumulation: tích luỹ, gom góp, cộng dồn...

	Ví dụ:

		//	0 + 1 + 2 + 3 + 4 + 5 + 6 + ... + 98 + 99 + 100
		//     t0 + 1
		//	  t1  + 2
		//	      t3  + 3
		//		  t6  + 4
		//		     t10  + 5
		//			 t15  + 6
		//			     ...

		// tổng = tổng + 1 2 3 4...
		// tổng = tổng + i		(i chạy từ 1..100)

		// Khởi tạo tổng ban đầu bằng 0 để không bị dính giá trị rác <- cực kì quan trọng *
		// tổng = 0;
		// tổng = tổng + 1 -> 0 + 1 = 1
		// tổng = tổng + 2 -> 1 + 2 = 3
		// tổng = tổng + 3 -> 3 + 3 = 6
		// tổng += i;		// i cứ tăng từ từ và tổng cũng sẽ theo đó mà được nhồi tăng lên

		// => Công thức tổng quát: lặp lại phép cộng
		//	1. Đưa số vào và tiến hành phép cộng
		//	2. Nhớ tổng đang có
		//	3. Đưa số mới vào và tiến hành phép cộng với tổng đã nhớ trước đó
		//	4. Tiếp tục nhớ tổng mới và thực hiện tiếp phép cộng

------------------------------------------------------------

[VÒNG LẶP WHILE VÀ DO-WHILE]

[SO SÁNH FOR VS. WHILE VÀ DO WHILE]

Cấu trúc của vòng lặp for:

	for (biến khởi đầu; điện kiện còn đúng thì còn lặp; biến đếm số lần)
	{
		các câu lệnh cần được chạy nhiều lần;
	}

Vòng lặp while và do-while sử dụng lại kiến thức của vòng lặp for, nhưng có khác đôi chút về cách viết.

	Ví dụ:

	// Vòng lặp while				// Vòng lặp do-while

	// Rụt rè: chỉ làm khi				// Liều mạng: cứ làm trước một lần đã,
	// ngay từ đầu đã thấy đúng,			// sau khi làm xong thì hỏi lại xem
	// sau khi làm xong thì hỏi lại xem		// nếu vẫn còn đúng thì lại làm tiếp
	// nếu vẫn còn đúng thì lại làm tiếp

	// "Tiền tấu, hậu trảm"				// "Tiền trảm, hậu tấu"

	// Giám thị kiểm tra thông tin của thí sinh	// Giám thị cho thí sinh vào phòng thi trước
	// trước khi cho phép bước vào phòng thi	// sau đó mới kiểm tra thông tin trong quá trình làm bài

	// Suy nghĩ cách thoát trước khi bước vào	// Bước vào trước rồi suy nghĩ cách thoát sau

	// Có khả năng không được thực thi lần nào	// Ít nhất cũng đã được thực thi một lần

	while (điều kiện/mệnh đề so sánh còn đúng)	do
	{						{
		còn đúng thì còn lặp lại			còn đúng thì còn lặp lại
		các lệnh trong đây;				các lệnh trong đây;
	}						} while (điều kiện còn đúng/mệnh đề so sánh đúng);

					[CÁCH THOÁT VÒNG LẶP]

		1. Làm cho điều kiện đúng (mệnh đề so sánh đúng) bây giờ không còn đúng nữa.
			Sử dụng biến đếm và thay đổi giá trị -> Kiểm tra lại điều kiện -> Vi phạm điều kiện
				=> THOÁT (một cách tự nhiên)

		2. Khi điều kiện thoát bây giờ luôn luôn đúng, sử dụng câu lệnh break từ bên trong để thoát.
			Sử dụng biến đếm và thay đổi giá trị -> Kiểm tra lại điều kiện -> Vi phạm điều kiện
				=> THOÁT (một cách gượng ép)


	Ví dụ: Tú (Sena) - biểu tượng của "con nợ" trong làng game Việt.

		#include <stdbool.h>

		bool biGiangHoChem(bool conThoLaConGo);

		int main(int argc, char *argv[])
		{
			bool conThoLaConGo = true;
			int tienTrongTui = 3;
			bool khaNangTraNo = true;

			while (conThoLaConGo == true)
			{
				printf("Con tho la con go!\n");
				printf("So tien con lai: %d\n", tienTrongTui);
				printf("\n");

				if (tienTrongTui == 0)
				{
					khaNangTraNo == false;

					if (khaNangTraNo == false)
						biGiangHoChem(conThoLaConGo);

					printf("Het duong go roi!\n");
					printf("Anh Ba oi, cuu Tu!\n");
					printf("\n");

					break;
				}

				tienTrongTui--;
			}

			return 0;
		}

		bool biGiangHoChem(bool conThoLaConGo)
		{
			conThoLaConGo == false;
			return conThoLaConGo;
		}

--------------------------------------------------------------------------------

[HIỆU ỨNG PHỤ - SIDE EFFECT]

Hiệu ứng lề/Hiệu ứng phụ (Side effect) - bất ngờ: nếu máy tính chưa tắt thì biến trong RAM vẫn còn nguyên, mà nếu chưa kết thúc chương trình thì CPU vẫn sẽ sử dụng giá trị cũ của biến. Vì vậy, khi sử dụng cùng một biến ở nhiều nơi khác nhau với mục đích tiết kiệm biến/tiết kiệm RAM (vì cùng một lúc có thể có nhiều người cùng sử dụng ứng dụng đó chứ không chỉ riêng một người) thì sẽ có nguy cơ gặp phải tình trạng mất kiểm soát, vô tình quên giá trị trước đó/giá trị cũ của biến mà vô tư đem đi sử dụng tiếp khiến kết quả bị sai, thường xảy ra khi code rất dài và nhiều.
	-> Không kiểm soát được giá trị của biến khi nhiều nơi sử dụng cùng một biến.
		(Giống như việc quên gán giá trị ban đầu cho thuật toán nhồi liên tiếp.)

* Giải quyết: khởi động lại giá trị của biến về đúng giá trị trước khi được thực thi.

--------------------------------------------------------------------------------

* Có thể sử dụng hoán chuyển cho nhau: for ≈ do-while ≈ while

Tuy nhiên, vẫn có độ ưu tiên.
	for: "thường" được sử dụng trong trường hợp đã biết trước số lần lặp (do cấu trúc của for là biết trước/tính được số bước nhảy ≈ số lần lặp).

	do-while/while: "thường" được sử dụng trong trường hợp khi chưa biết trước số lần lặp, chỉ biết còn đúng thì còn lặp, nhưng sẽ thoát ở một lúc nào đó.

		do-while: "thường" được sử dụng trong trường hợp cần kiểm tra điều kiện.

==========================================================================================

[CÔNG THỨC LÀM ỨNG DỤNG: INPUT, PROCESS & OUTPUT - IPO]

Nếu bài toán trong toán học có...	thì bài toán trong tin học / lập trình sẽ có...
	- Giả thiết (Assumption)		- Dữ liệu đầu vào (Input)
	- Công thức (Formula)			- Hàm xử lý (Function)
	- Kết luận (Conclusion)			- Dữ liệu đầu ra (Output)

--------------------------------------------------------------------------------

Để làm ra được một ứng dụng, ta cần:

* Input (đầu vào): cần những (biến) gì để bắt đầu giải quyết bài toán?
	-> Thứ chưa biết và cần ai đó cung cấp để có thể bắt đầu sử dụng (xử lý).

* Process (thuật toán): xử lý gì, làm sao để đạt được?
	-> Công thức, cách thức xử lý đầu vào để có được đầu ra.

* Ouput (đầu ra): cần in ra kết quả gì sau khi đã tính toán xong?
	-> Kết quả cuối, nhận về được gì sau khi cung cấp đầu vào.

	Ví dụ 1: rút tiền ở máy ATM

		* Input	 : thẻ, số tiền hợp lệ muốn rút, số PIN hợp lệ.

		* Process:
				- Kiểm tra thẻ và số PIN có hợp lệ.
				- Kiểm tra số tiền được nhập có hợp lệ (chẵn hay không).
				- Kiểm tra số dư trong tài khoản có đủ để rút.
				- Kiểm tra số dư trong máy ATM có đủ để rút.
				- ...

		* Ouput  :
				- Nhận được số tiền tương ứng.
				- Nhận lại thẻ.
				- Số dư trong tài khoản được cập nhật lại kèm với thông báo.

	Ví dụ 2: giải phương trình bậc một ax + b = 0

		* Input	 : hai hệ số a và b -> hai biến a và b

		* Process: kĩ thuật giải phương trình bậc một
				- Nếu: a = 0, b <> 0 -> vô nghiệm
				- Nếu: a = 0, b = 0 -> vô số nghiệm vì x có thể là bất kì số nào
				- Nếu: a <> 0, b ...

		* Ouput  : in ra nghiệm x để nó luôn đúng khi được ráp vào công thức ax + b = 0
				-> một biến x

--------------------------------------------------------------------------------

* Lưu ý:
	- Input: với mỗi đầu vào sẽ cần một biến để lưu giá trị cho Input đó. Giá trị có thể đến thông qua việc nhập từ bàn phím hoặc đã được gán từ trước.
		-> Bao nhiêu Input thì bấy nhiêu biến.

		* Biến trung gian: giống như tờ giấy nháp để giải toán trước khi ra được kết quả cuối cùng. Thay vì trả kết quả trực tiếp về cho một biểu thức thì lúc này sẽ trả cho một biến trung gian và sử dụng biến đó để tính toán trong biểu thức.
	- Process: phần thuật toán xử lý (công thức) có khả năng cần thêm biến trung gian để lưu các giá trị trong quá trình tính toán.

		Ví dụ 1: trong bài toán tính tuổi theo năm sinh
			// Biến age được xem là biến trung gian
			// dùng để lưu trữ dữ liệu và sử dụng sau này
			age = 2022 - yearOfBirth;

		Ví dụ 2: trong bài toán giải phương trình bậc hai
			// Biến delta là biến trung gian
			// vì kết quả thực sự cần của phương trình bậc hai
			// là hai nghiệm x1 và x2
			delta = b^2 - 4ac;

	- Ouput: đầu ra có thể là một thông báo hoặc một biến trung gian giúp lưu kết quả để tiếp tục xử lý.

		Ví dụ: đầu ra của nghiệm phương trình bậc hai
			- Nếu có hai nghiệm x1 và x2 được in ra thì phải cần có hai biến để lưu trữ giá trị.

==========================================================================================

[HÀM - FUNCTION]

Con người luôn có xu hướng tổng quát hoá mọi thứ và giải quyết mọi thứ theo công thức nếu có thể.

	Ví dụ: khi tính diện tích của một hình chữ nhật.
		- Gọi cạnh dài hơn là "Chiều dài" và gọi cạnh ngắn hơn là "Chiều rộng".
		- Tuy mỗi hình có một "Chiều dài" và "Chiều rộng" khác nhau, nhưng đều phải lấy hai độ dài để nhân với nhau.
		-> Công thức chung để áp dụng cho một lớp các bài toán: Chiều dài x Chiểu rộng.

--------------------------------------------------------------------------------

[KHÁI QUÁT VỀ HÀM]

		* Hình thức: vẻ bề ngoài; chỉ có trên danh nghĩa, bên trong không có gì.
	* Tham số đầu vào (Parameter - param / Argument - arg): giá trị/tên biến nằm ngay trên tên hàm, là một loại biến cục bộ và những hàm khác không thể thay đổi giá trị, nhưng có nhiệm vụ giao tiếp với thế giới bên ngoài. Một hàm có thể có nhiều tham số đầu vào, mỗi đầu vào được ngăn cách nhau bằng một dấu phẩy.
		-> Cửa mở ra để giao tiếp, hứng dữ liệu từ bên ngoài để có dữ liệu mà xử lý.

		Ví dụ: Các hình thức nhận dữ liệu đầu vào từ bên ngoài để tiến hành xử lý ở bên trong và trả về kết quả.
		
			- Khe nhét thẻ ATM là nơi giao tiếp với chủ thẻ, nhận thẻ vào để tiến hành xử lý và trả thẻ về sau khi dữ liệu (tiền, thông báo dao dịch...) được cập nhật lại trong tài khoản chủ thẻ.

			- Nhân viên chăm sóc khách hàng là người trung gian nhận thông tin phản hồi từ phía khách hàng, sau đó chuyển sao cho bộ phận kỹ thuật để kiểm tra và xử lý và phản hồi lại cho khách hàng về kết quả xử lý.

			- Chủ tiệm tạp hoá nhận yêu cầu mua hàng từ khách khách, sau đó kiểm tra số lượng tồn kho trong tiệm và trả về kết quả giá tiền của những món còn hàng mà khách hàng muốn mua.

		* Tham số hình thức (Parameter - Param): biến được liệt kê với mục đích "xí chỗ".
		* Tham số thực sự / Đối số (Argument - Arg): biến chứa giá trị cụ thể sẽ truyền vào hàm.

			Ví dụ:
				// Tham số hình thức
				hamTinhTong(int thamSoHinhThuc, int mucDichXiCho);

				// Tham số thực sự
				int thamSoThucSu = 5;
				int bienChuaGiaTri = 10;
				hamTinhTong(thamSoThucSu, bienChuaGiaTri); // Đối số

Khi trong một bài toán lớn, phức tạp, gồm nhiều vấn đề nhỏ bên trong nhưng có thể chia nhỏ/tách riêng ra thành những bài toán độc lập, mỗi phần nhỏ đóng một vai trò khác nhau và được đặt tên để kiểm soát độ phức tạp của bài toán (code dài, sử dụng nhiều biến, thực hiện nhiều việc nhỏ).
	-> Áp dụng kỹ thuật "Chia để trị" (Divide and Conquer) nhằm giải quyết những bài toán lớn và phức tạp.

	Ví dụ 1: tại quầy tiếp tân của một cửa hàng tiện lợi sẽ được chia ra làm hai.
			- Một bên tính tiền.
				-> Tên gọi/Vai trò (Role): thu ngân.
			- Một bên chế biến những thực phẩm nóng để ăn tại chỗ hoặc mang đi.
				-> Tên gọi/Vai trò (Role): đầu bếp.

	Ví dụ 2: chương trình MathHelper giúp giải các bài toán tính diện tích của hình tam giác, tròn, hình chữ nhật...
		* Có thể chia nhỏ bài toán: mỗi bài có IPO riêng.
			- Tính diện tích của hình tam giác.
			- Tính diện tích của hình tròn.
			- Tính diện tích của hình hình chữ nhật.
			- ...

	Ví dụ 3: các công thức được tái sử dụng để áp dụng cho một loạt các bài toán
		- Trong máy tính bỏ túi: dấu cộng, trừ, nhân, chia,...
		- Trong ứng dụng Excel: hàng tính trung bình, tìm số lớn nhất và số bé nhất,...
		- Trong cuộc sống: công thức nấu cơm ngon,...

=> Kỹ thuật chuyên môn hoá/mô-đun hoá - "Chia để trị": hàm (function).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hàm ≈ Chức danh ≈ Công việc ≈ Vai trò: thực thi một nhiệm vụ chuyên biệt nào đó	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CHI TIẾT VỀ HÀM]

Trong toán học, hàm là một quy tắc biến đổi (cách thức xử lý) đầu vào để có được đầu ra.
	* Quy tắc biến đổi/xử lý: những ràng buộc phải tuân theo nếu muốn ra được kết quả xử lý như ý muốn.
		1. Đưa vào.
			2. Xử lý/Biến đổi.
				3. Trả kết quả
	-> Là quy tắc biến đổi mà nếu có ai đó đưa dữ liệu vào, nó sẽ xử lý và trả kết quả về.
		(Là quy tắc biến đổi một thứ gì đó để ra được một thứ mới và tận dụng kết quả xử lý đó.)

------------------------------------------------------------

Hàm/Hàm số (Function): trong lập trình, hàm (chương trình con) là một khối lượng/nhóm/đơn vị code - câu lệnh.
	- Bên trong gồm nhiều tác vụ, được gom lại để cùng phối hợp và thực thi một công việc nào đó.
	- Được đặt cho một cái tên nhằm phục vụ cho việc tái sử dụng sau này.
	- Mỗi hàm sẽ chỉ giải quyết duy nhất một công việc cụ thể (không nên có hàm nhiều chức năng).
	-> Một nhóm câu lệnh được đặt tên để giải quyết một công việc nào đó.
		-> Xử lý dữ liệu (biến).

	Ví dụ:

	* Trong toán học:

		- Công thức / Quy tắc:
				y = f(x)     =    x^2

		- Trong đó:
				      x      ->	 x * x  ->      y: bình phương của x
				  (Đưa vào)	(Xử lý)	   (Trả kết quả - gán lại vào y)
	
		- Sử dụng hàm:
				y = f(2) = 2^2 = 2 * 2 = 4
					-> Nếu đưa vào 2 thì sẽ trả về 4.

				y = f(-5) = (-5)^2 = (-5) * (-5) = 25
					-> Nếu đưa vào (-5) thì sẽ trả về 25.


	* Trong lập trình:

		// Hàm loại 1: hàm f() trả về kết quả bình phương của một giá trị x
		void f()
		{
			int x, y;

			printf("\nPlease input an integer to get a ^2: ");
			scanf("%d", &x);

			y = x * x;

			printf("The function y = f(x) = x^2; f(%d) = %d\n", x, y);
		}

----------------------------------------

=> Hàm là kỹ thuật gom một nhóm những câu lệnh thực hiện một việc gì đó lại và đặt tên gọi, sau đó gọi lên để sử dụng khi cần.
	(Gom những xử lý thành một bộ quy tắc, đặt tên và tái sử dụng ở nhiều nơi.)
		-> Tách những xử lý lặp lại ra một nơi để sử dụng ở nhiều nơi khác.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hàm là một nhóm lệnh, được đặt tên và làm một việc gì đó	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

* Lưu ý: hàm trong lập trình cũng giống với toán học khi kết quả trả về thường sẽ được viết ở bên phải:

	Ví dụ:
		// Toán học:	y   =	f			(x)	  =	x^2
		// Lập trình:	int	tinhLuyThuaBacHai     (int x)	{return x * x;}

------------------------------------------------------------

[LỢI ÍCH & LƯU Ý KHI SỬ DỤNG HÀM]

* Lợi ích:
	- Tính chuyên biệt hoá cao, tối ưu hiệu suất.
	- Tính tái sử dụng cao, cho phép chuyển giao/gọi lại đoạn lệnh chỉ bằng tên gọi.
	- Dễ bảo trì, nâng cấp, chỉnh sửa code.
	- Dễ cô lập vấn đề và giúp hạn chế gặp phải hiệu ứng lề/hiệu ứng phụ (side effect).
		=> Rõ ràng và dễ quản lý.

----------------------------------------

* Khi làm việc với hàm cần quan tâm:
	1. Khai báo hàm: định nghĩa công thức, mô tả quy tắc xử lý thông tin.
	2. Gọi hàm để sử dụng (Call/Invoke): gọi tên hàm mỗi khi cần CPU xử lý việc nào đó.
		(≈ CPU sao chép và dán nguyên đoạn lệnh trong hàm được gọi vào nơi vừa gọi tên hàm.)

		* Nếu các câu lệnh điều khiển có thể lồng nhau, các hàm cũng có thẻ lồng nhau - Một hàm có thể gọi một hàm khác.

			Ví dụ: ta có hai hàm
				- Hàm isPrime() được dùng để kiểm tra một số có phải là số nguyên tố hay không
				- Hàm printPrimeNumber() sử dụng để in các số nguyên tố từ 1..1000

				Lúc này, bên trong hàm printPrimeNumber() sẽ gọi hàm isPrime()
				để kiểm tra trước rồi sau đó mới quyết định có in ra hay không.
					(Hàm bây giờ được xem như một câu lệnh.)

------------------------------------------------------------

[CHƯƠNG TRÌNH CHÍNH  / HÀM CHÍNH - HÀM MAIN()]

Có thể thấy, main() cũng làm một hàm, nhưng nó lại rất quan trọng vì đây là một sân khấu - nơi "kịch bản" diễn ra. Mỗi tiết mục / đội / nhóm / diễn viên trên sân khấu này được xem là một hàm chuyên biệt, được sắp xếp theo một trình tự nào đó tuỳ vào mục đích của buổi biểu diễn, được đặt cho một cái tên để phân biệt và dễ gọi.

	* Hàm main() có nhiệm vụ phối hợp và điều phối cuộc chơi, vì CPU sẽ tìm hàm này để chạy đầu tiên và chỉ hoạt động trong main().
	
		- Trong cuộc chơi ấy có thể gọi thêm nhiều đồng minh khác để hỗ trợ, trình tự gọi hàm sẽ tuỳ theo thứ tự mà các hàm được bố trí trong main().
		
		- Vì vậy, nếu muốn những hàm khác có thể được gọi lên để thực thi, thì phải gọi trong hàm main().

		- Đóng vai trò như bộ não của con người, chi phối toàn bộ hoạt động của chương trình.

		-> Hàm lõi, trung tâm - nơi cuộc chơi bắt đầu.
			(Cơ quan đầu não, chi phối mọi hoạt động của chương trình.)

			Ví dụ 1: nhà bếp là nơi sinh hoạt chung của một số gia đình.

			Ví dụ 2: sân trường là trung tâm diễn ra mọi hoạt động của nhà trường.

			Ví dụ 3: bục giảng là nơi diễn ra toàn bộ các hoạt động giảng dạy chính của lớp học. Trong quá trình giảng dạy, giảng viên có thể gọi sinh viên lên đây để trả bài cũ, làm bài tập...

			Ví dụ 4: sân khấu là nơi tập trung để biểu diễn của các nghệ sĩ. Đối với một số nghệ sĩ, đôi lúc có thể bước xuống sân khấu để giao lưu cùng khán giản, nhưng rồi sau đó vẫn trở về sân khấu để tiếp tục vai trò của mình.

----------------------------------------

* Lưu ý: khi viết thành văn bản để giao tiếp, ghi chú... nên viết "hàm main()" thay vì "hàm main" để thông báo rằng đây là một hàm chứ không phải tên biến, dấu ngoặc tròn () cũng giống như cái phểu để hứng đầu vào.

----------------------------------------

Sử dụng/gọi hàm khác bên trong hàm main():
		int main(int argc, char *argv[]) {

			// Gọi hàm lên để sử dụng
			fV1();
	
			return 0;
		}

------------------------------------------------------------

[ĐẦU RA & ĐẦU VÀO CỦA HÀM - RETURN TYPE]

--------------------

	[KHÔNG CÓ GIÁ TRỊ TRẢ VỀ]

* void: hàm có xử lý nhưng không trả về một giá trị (char, int, long, float, double...) cụ thể nào đó để có thể cầm nắm được mà chỉ có thể xem thông qua printf(). Thường sử dụng cho những hàm không thể, không biết, không lựa chọn được hoặc không cần thiết phải trả về một giá trị nào đó.
	-> Xử lý xong và chỉ trả về thông báo, chứ không trả về giá trị để có thể tương tác thêm.

	Ví dụ 1: nhờ bạn đi mua thuốc lá, sau khi đi một hồi thì quay lại
		1. Nhận được tin: "Còn cái nịt".
			-> void

		2. Cầm được trên tay gói thuốc cắn dở.
			-> giá-trị + return

	Ví dụ 2: khi đi lấy căn cước công dân, đưa giấy hẹn cho cán bộ, bộ phận bên trong có xử lý để làm thẻ cho cân dân...
		1. Chỉ nhận về một câu thông báo rằng thẻ chưa về và không thể làm gì hơn.
			-> void

		2. Nhận về căn cước công dân và có thể làm nhiều thứ với loại CCCD mới có gắn chip này.
			-> giá-trị + return

	(* Lưu ý: Hàm chỉ có xử lý mà không có kiểu trả về còn được gọi là thủ tục (Procedure).)

--------------------

	[CÓ GIÁ TRỊ TRẢ VỀ]

	* giá-trị: char, int, long, float, double...
* giá-trị + return: hàm có trả về cho bên ngoài một giá trị (char, int, long, float, double...) nào đó. Kỹ thuật gán giá trị cho tên hàm, vì vấy, nếu hàm thiếu return thì biến sẽ mang giá trị rác. Thường sử dụng cho những hàm mà nơi gọi hàm cần kết quả đã xử lý từ hàm để đi tính toán tiếp.
	-> Xử lý xong và trả về giá trị (thuộc kiểu dữ liệu int, double...) để có thể sử dụng tiếp.

	* return:
		- Nếu bằng một cách nào đó mà CPU chạm vào được lệnh return (return có thể nằm ở bất cứ đâu trong code), thì nó sẽ lập tức kết thúc hàm và mặc kệ, không thèm thực thi những câu lệnh phía sau của lệnh return.
		- return mạnh hơn break vì break chỉ thoát lặp, còn return thoát luôn hàm dù cho CPU đang ở trong vòng lặp.
		- Mặc định, hàm main() sẽ trả về (return) một số nguyên.
			-> return = dừng hàm.

	* Cách sử dụng:

		int a = int f() { return...; }

		// Lúc này, cụm tên hàm f() được xem như là một biến (cũng giống như biến a)
		// vì nó cũng có kiểu dữ liệu (cách khai báo cũng giống như cách khai báo biến a)
		// và cách để gán giá trị nào đó cho tên hàm (cho biến) này là thông qua câu lệnh return,
		// mà đã là một giá trị thì có thể sử dụng để tính toán tiếp bằng cách gán tiếp cho biến khác
		// hoặc in giá trị của tên hàm (của biến) ra thông qua câu lệnh printf()

	- Mặc định, ta sẽ không thể chủ động gọi hàm main() bên trong một hàm khác, mà CPU sẽ gọi. Lúc này, tuỳ vào kiểu dữ liệu trả về của hàm mà return sẽ được sử dụng hoặc không:

		+ Nếu hàm có kiểu dữ liệu trả về (int, long, double...) thì việc sử dụng câu lệnh return để đưa dữ liệu trả về ấy cho hàm là điều hết sức bình thường. Nhưng nếu không có bất kì giá trị nào để trả về, thì câu lệnh return lúc này sẽ được xem là câu lệnh để kết thúc chương trình.
			-> Trả dữ liệu về hoặc đơn giản là kết thúc chương trình.

			* Quy ước: những quy ước mà chương trình phải tuân theo vì hệ điều hành muốn mọi thứ được ổn định, mà ứng dụng được chạy trong hệ điều hành nên cũng phải tuân thủ theo quy ước này.

				- Mặc định sẽ return 0 để báo hiệu cho CPU và hệ điều hành biết rằng ứng dụng chạy ổn và không khiến máy bị treo (mặc dù trong code vẫn có lỗi do chủ quan của người viết code).
					-> Ứng dụng thông báo cho CPU và hệ điều hành biết rằng mình đã "hoàn thành nhiệm vụ" và "hạ cánh an toàn" bằng cách trả về số 0.

				- Nếu return 1 có nghĩa là đã xảy ra lỗi trong quá trình thực thi chương trình, và hàm không thực hiện những gì mà nó dự định làm. Vì ngôn ngữ C không có ngoại lệ nên return 1 được sử dụng để thay thế.
					-> Ứng dụng thông báo cho CPU và hệ điều hành biết rằng mình đã "không hoàn thành nhiệm vụ" bằng cách trả về số 1.
			

		+ Nếu hàm không có dữ liệu trả về (void), câu lệnh return có thể được bỏ qua, vì đơn giản là hàm đã không trả về gì. Nhưng nếu vẫn sử dụng câu lệnh return nhưng không có giá trị trả về (return;) trong một hàm kiểu void, câu lệnh return sẽ được hiểu giống như câu lệnh break, được sử dụng để thoát khỏi luồng thực thi của main() - câu lệnh nhảy (jump statement). Còn nếu cố tình sử dụng câu lệnh return với kiểu dữ liệu trả về (return giá-trị-nào-đó;) trong một hàm kiểu void, thì sẽ gặp lỗi cú pháp.
			-> Đã không muốn trả về thì cũng không ép return, nếu vẫn return thì đồng nghĩa với kết thúc chương trình.

----------------------------------------

[CÁC KIỂU RETURN TRONG HÀM]

"Hàm được quyền có bao nhiêu lệnh return (lối thoát)?"

Tuỳ vào người lập trình viên mà sẽ có 2 phong cách thiết kế hàm có trả về giá trị (hàm loại 3 & 4), không có khác biệt gì về hiệu năng, chỉ khác biệt về việc thích kiểm soát hướng ra và mạch đi của giá trị theo hướng tổng quay hay theo từng khu vực, nhưng đích đến cuối cùng cũng chỉ là để có được một giá trị phù hợp:

----------

	1. Vì return tương đương với lối thoát, cũng giống như nhà chỉ có một cửa thoát, nên hàm chỉ nên có một cửa thoát đó là sau khi đã tính toán xong hết tất cả các giá trị và chuẩn bị trả về giá trị. Đòi hỏi phải kiếm soát được mạch đi của hàm, nhưng sẽ giúp dễ dàng, nhất quán và có được tư duy tổng thể trong việc kiểm soát giá trị đầu ra.
		-> [Hàn lâm] Có duy nhất một lệnh return ở cuối hàm để trả về giá trị sau khi đã tính toán, giúp kiểm soát giá trị đầu ra.

			Ví dụ: sử dụng return ở cuối
				
				int getFactorialV4(int n) {
					int acc = 1;
	
					if (n == 0 || n == 1)
						acc = 1;
					else
						for (int i = 2; i <= n; i++)
							acc *= i;

					// Sử dụng return ở cuối
					return acc;
				}

----------

	2. Cũng giống như việc một trung tâm mua sắm có nhiều cửa thoát, hàm cũng nên có nhiều lối thoát, trong bất kì tình huống nào, miễn đã xác định được giá trị của hàm thì dừng luôn mà không cần phải đợi đến cuối mới return. Trong tình huống này, mỗi cửa thoát sẽ có những giá trị khác nhau và yêu cầu phải kiểm soát được từng giá trị tại từng thời điểm.
		-> [Thực dụng] Có được giá trị ở đâu thì lập tức return ở đấy, bất kì khi nào có được giá trị cho hàm.

			Ví dụ: sử dụng return bất kì khi nào có được giá trị cho hàm
				
				int getFactorialV4(int n) {
					int acc = 1;
	
					if (n == 0 || n == 1)
						// Nếu CPU chạm vào được return
						// thì lập tức thoát chương trình
						// mà không cần quan tâm phần còn lại
						// và giá trị 1 sẽ được đẩy lên trên tên hàm
						return 1;
					else
					{
						for (int i = 2; i <= n; i++)
							acc *= i;

						return acc;
					}
				}

=> Phải kiểm soát lúc nào thì return và return với giá trị gì.

--------------------

Trong hàm do người dùng tự định nghĩa (User-defined function), giá trị trả về của câu lệnh retrun lại mang một ý nghĩa khác.

	- return 0 = false: hàm xử lý không thành công.
	- return 1 = true: hàm xử lý thành công.

* So sánh sự khác nhau giữa return 0 và return 1 khi được sử dụng trong hàm main () và khi được sử dụng trong hàm do người dùng tự định nghĩa.

	-----------------------------------------------------------------------------------------
	| Trường hợp sử dụng	|	return 0		|	return 1		|
	|-----------------------|-------------------------------|-------------------------------|
	| Trong hàm main()	| Thông báo rằng chương trình	| Thông báo rằng có lỗi xảy ra	|
	|			| đã được thực thi thành công	| và chương trình		|
	|			|				| thực thi KHÔNG thành công	|
	|-----------------------|-------------------------------|-------------------------------|
	| Trong hàm người dùng	| Thông báo rằng chương trình	| Thông báo rằng chương trình	|
	|  tự định nghĩa	| xử lý KHÔNG thành công	| đã xử lý thành công		|
	-----------------------------------------------------------------------------------------

--------------------

* Lưu ý: dù được đặt ở bất kì đâu, exit(0) cũng sẽ để kết thúc cả một chương trình thay vì chỉ kết thúc một hàm giống như câu lệnh return.

----------------------------------------

[LOẠI TRỪ / "ĂN BỚT" CÂU LỆNH BẰNG RETURN]

Nếu code có if-else và trong if-else đều có return từ sớm, thì có thể chỉ giữ lại phần if và bỏ hẳn phần else vì return sớm đã bao gồm sự loại trừ.
	-> Đã có if và return từ sớm thì không cần đến else vì if + return sẽ loại trừ phần còn lại nếu đúng.

	* Cấu trúc: nếu có return từ sớm

		// Cấu trúc gốc,					// Cấu trúc sau khi sử dụng return
		// sử dụng return ở nhiều nơi				// để loại trừ
		if ()							if ()
		{							{
			...;							...;
			return;	// sớm		[Tương đương			return;
		}			 	 nhưng gọn hơn ->]		}
		else							những lệnh của else nằm ở đây;
		{							return;
			...;
			return;
		}


			Ví dụ: loại bỏ else nhưng vẫn đảm bảo tính đúng đắn của if-else
				
				int int getFactorialV4(int n) {
					int acc = 1;
	
					if (n == 0 || n == 1)
						return 1;

					// Sử dụng return để thay thế cho phần else phía sau lệnh if
					for (int i = 2; i <= n; i++)
						acc *= i;

					return acc;
				}

----------------------------------------

return NULL;

--------------------------------------------------------------------------------

[PHÂN LOẠI HÀM]

Dựa theo định nghĩa: "Hàm là một quy tắc xử lý đầu vào để có được đầu ra", tức là khi nói về hàm thì đồng nghĩa với đang nói về xử lý và phải có dữ liệu để tiến hành xử lý.
	-> Đầu ra và đầu vào của dữ liệu.

	* Đầu ra và đầu vào:
		- Toán học: 	   y          =      f      (x)      =		   x^2

		- Lập trình: 	đầu-ra    [return]   f   (đầu-vào)   =   {phần xử lý bình phương}
		   Hàm loại 1:  void                 f      ()       =    printf("%d", (x * x));
		   Hàm loại 4:  int                  f    (int x)    =        int y = x * x;

----------------------------------------

	* Đại số: những con số được đại diện bằng một chữ cái.
		Ví dụ:
			f(x) = x^2	// x ở đây đại diện cho một con số, khi nào cần sử dụng thì đưa vào

------------------------------------------------------------

- Dựa vào đầu vào và đầu ra, ta có bốn cách/kỹ thuật viết hàm - bốn loại hàm khác nhau (trong khi đó, toán học chỉ có một cách). Tuy cách viết khác nhau nhưng đích đến là như nhau.
	-> Hoạt động dựa theo nguyên tắc: "Nhân quả" - Tuỳ đầu vào mà sẽ có đầu ra tương ứng.

- Bên cạnh đó, tuỳ vào loại hàm khác nhau mà cách gọi tên hàm cũng khác nhau đôi chút.

* Phân loại theo đầu ra (giống phong cách của toán học khi viết đầu ra trước, ví dụ: y = f(x) = x^2):

	// Hàm loại 1		// Hàm loại 2		// Hàm loại 3		// Hàm loại 4
	// KHÔNG vào		// CÓ vào		// KHÔNG vào		// CÓ vào
	// KHÔNG ra		// KHÔNG ra		// CÓ ra		// CÓ ra
	void fV1()		void fV2(I: int x)	int fV3()		int fV4(I: int x)
	{			{			{			{
	  I: int x;		  I: xem như đã có	  I: int x;		  I: xem như đã có
	     scanf(x);					     scanf(x);

	  P: int y = x * x;	  P: int y = x * x;	  P: int y = x * x;	  P: int y = x * x;

	  O: printf(y);		  O: printf(y);		  O: return y;		  O: return y;
	}			}			}			}

	-> Xét về ví dụ máy xay sinh tố:

		- Hàm loại 1 và 3 đã có sẵn phểu để hứng giá trị đầu vào.
			=> Tính đa dụng không cao vì luôn phải sử dụng như đã thiết kế ban đầu.
				=> Bế tắc trong việc tận dụng kết quả xử lý cho những việc trong tương lai.

		- Hàm loại 2 và 4 không có sẵn phểu và phải tự làm thủ công để hứng giá trị đầu vào.
			=> Tính tái sử dụng cao khi cho phép sử dụng theo nhiều phong cách khác nhau.
				=> Linh hoạt trong việc tận dụng kết quả xử lý cho những việc trong tương lai.

// Tại sao lại "không ra, không vào" trong khi mục đích của hàm là nhận đầu vào, xử lý và trả kết quả đầu ra?

Vì:
	- Kết quả đầu ra có thể trả về trực tiếp trong hàm thông qua các câu lệnh printf(). Bằng cách này, ta có thể trả về nhiều hơn một kết quả đầu ra.

	- Vì không thể nhận tham số đầu vào từ nơi gọi hàm, nên để có dữ liệu phục vụ cho việc xử lý, bắt buộc bên trong hàm phải có câu lệnh scanf() để nhận dữ liệu đầu vào.

----------------------------------------

[HÀM LOẠI 1: KHÔNG RA, KHÔNG VÀO]

* Hàm loại 1: KHÔNG ra, KHÔNG vào trên tên hàm
	void f()

* Cấu trúc:
		không-ra f(không-vào)

		void f() {
			cần scanf() để có dữ liệu mà xử lý;
			cần printf() để in kết quả đã xử lý;
		}

	Ví dụ:

		// Viết hàm - Thiết kế phần thân hàm
		void fV1()
		{
			// Khu vực viết code - quy tắc xử lý bên trong hàm

			// Quy tắc xử lý: xử lý đầu vào để có được đầu ra
			// Công thức IPO sẽ được nhét hoàn toàn vào trong hàm

			// Không có đầu vào tên phải "tự cung tự cấp" đầu vào

			// 1. Đầu vào: để tính được f()
			//    thì bắt buộc phải khai báo biến và nhập giá trị vào
			int x;

			printf("Please input an integer to get ^2: ");
			scanf("%d", &x);

			// 2. Xử lý/Biến đổi
			int y = x * x;

			// 3. Đầu ra
			printf("y = f(x) = x^2; f(%d) = %d\n", x, y);
		}

		// Sử dụng hàm - Gọi hàm
		int main(int argc, char *argv[]) {
			fV1();
		}

----------------------------------------

[HÀM LOẠI 2: KHÔNG RA, CÓ VÀO]

* Hàm loại 2: KHÔNG ra, CÓ vào trên tên hàm
	void f(int a)

* Cấu trúc:
		không-ra f(có-vào)

		void f(int a) {
			KHÔNG NÊN scanf() vì biến a lúc này xem như đã có dữ liệu đưa vào để xử lý rồi;
			cần printf() để in kết quả đã xử lý;
		}

	Ví dụ:

		// Viết hàm - Thiết kế phần thân hàm
		void fV2(int x)	// 1. Đầu vào
		{
			// 2. Xử lý/Biến đổi
			int y = x * x;

			// 3. Đầu ra
			printf("The function y = f(x) = x^2; f(%d) = %d\n", x, y);
		}

		// Sử dụng hàm - Gọi hàm

		// Sử dụng hàm bằng cách đưa trực tiếp giá trị vào trong x và bắt đầu tính toán
		// mà không cần phải khai báo biến và nhập giá trị cho nó nữa
		// vì lúc này x đại diện cho một con số đầu vào bất kì nào đó
		// và xem như đã có rồi, được đưa vào ở ngã đầu vào của tên hàm

		int main(int argc, char *argv[]) {

			// Ở đây, những lệnh trong đây được xem là công thức để tính toán giá trị đầu vào,
			// mà công thức thì phải ở mức tổng quát, tức là xem như đã có đầu vào rồi
			// và x ở đây đại diện tạm cho một giá trị/con số đầu vào cụ thể nào đó
			// sẽ được đưa vào công thức sau này
			//	-> Trong tương lai, x là giá trị cụ thể nào đó sẽ được nơi gọi hàm đưa vào sau

			// Việc xử lý trên công thức cũng chính là xử lý trên giá trị thật (trong tương lai),
			// do đó, khi sử dụng hàm thì bắt buộc phải đưa giá trị vào

			// Vì bản chất chỉ cần một con số
			// mà không cho biết là con số đó sẽ đến từ đâu nên sẽ có hai cách sử dụng:

			// Cách 1: truyền trực tiếp giá trị vào trong hàm
			// Gán cứng giá trị vào trong hàm, chỉ việc lấy giá trị và sử dụng
			fV2(5);

			// Cách 2: gán giá trị cho biến thông qua việc nhập từ bàn phím
			//	-> Bao gồm luôn cách sử dụng của hàm loại 1
			int n;
	
			printf("\nPlease input an integer to get a ^2: ");
			scanf("%d", &n);	// Lúc này, n được xem là một giá trị
						// và nó đã được nhập từ bàn phím
	
			// Gán giá trị n (được nhập từ bàn phím) vào trong hàm
			fV2(n);
		}

----------------------------------------

[HÀM LOẠI 3: CÓ RA, KHÔNG vào]

* Hàm loại 3: CÓ ra, KHÔNG vào trên tên hàm
	int f()

* Cấu trúc:
		có-ra f(không-vào)

		int f() {
			cần scanf() để có dữ liệu mà xử lý;
			KHÔNG NÊN printf() vì đã return dữ liệu ra ngoài;
			bắt buộc return giá-trị-nào-đó ra ngoài qua tên hàm để sử dụng tiếp;
		} // Tên hàm là 1 biến được gán giá trị từ return

		// Nếu cố tính sử dụng lệnh printf() trong khi hàm đã có return
		// thì tính tái sử dụng sẽ bị thu hẹp

	Ví dụ:

		// Viết hàm - Thiết kế phần thân hàm
		int fV3()
		{
			// Không có đầu vào tên phải "tự cung tự cấp" đầu vào

			int x, y;
	
			printf("Please input an integer to get ^2: ");
			scanf("%d", &x);
	
			y = x * x;

			return y;	// biến y = tên hàm
					// int y = int fV3()
		}

		// Sử dụng hàm - Gọi hàm
		int main(int argc, char *argv[]) {

			// Cách 1: hàm được xem như là một giá trị
			// nên có thể khai báo biến để gán và in ra giá trị của hàm ra
			int result = fV3();
			printf("The result: %d\n", result);

			// Cách 2: có thể sử dụng trực tiếp hàm như một giá trị
			// ở bên trong những hàm, biểu thức và câu lệnh khác

			// Sử dụng định luật bắt cầu trong toán học = tương đương/đổ ngang giá trị
			// vì đây cũng là một giá trị
			// 	a = b; b = c -> a = c
			// (Nhờ "cầu" b nằm ở giữa mà a và c đã tìm thấy nhau)
			printf("The result: %d\n", fV3());

			return 0;
		}


----------------------------------------

[HÀM LOẠI 4: CÓ ra, CÓ vào]

* Hàm loại 4: CÓ ra, CÓ vào trên tên hàm
	int f(int a)

		=> Được khuyến khích sử dụng vì nó trả về một giá trị và ta có thể tái sử dụng giá trị đó trong các công thức, biểu thức khác. Vì vậy, không nên có câu lệnh printf() vì nó sẽ in ra những câu lệnh không mong muốn khi sử dụng hàm trong các biểu thức.
			(Tuy viên, vì lúc này tên hàm được xem là một biến,
			 mà một thời điểm, một biến chỉ có thể lưu trữ được một giá trị,
			 nhưng khi có ≥ hai đầu ra / giá trị cần trả về (ví dụ: một mảng),
			 thì lúc này phải sử dụng hàm void vì nó không trả về gì cả
			 và trực tiếp in ra luôn kết quả xử lý ở bên trong hàm.)

* Cấu trúc:
		có-ra f(có-vào) // double r = sqrt(4); Math.sqrt(4);

		int f (int a) { //IPO
			KHÔNG NÊN scanf() vì biến a lúc này xem như đã có dữ liệu đưa vào để xử lý rồi;
			KHÔNG NÊN printf() vì đã return giá trị ra ngoài;
			bắt buộc return giá-trị-nào-đó ra ngoài qua tên hàm để sử dụng tiếp;
		} // Tên hàm là 1 biến được gán value từ return
		// SOÁI CA, RE-USE CAO NHẤT, NHÚNG VÀO LỆNH KHÁC

	Ví dụ:

		// Viết  - Thiết kế phần thân hàm
		int fV4(int x)
		{
			int y = x * x;
			return y;
		}

		// Sử dụng hàm - Gọi hàm
		int main(int argc, char *argv[]) {

			// Hàm có trả về giá trị, nhưng cần gọi ra và gán cho biến khác
			// hoặc gán trực tiếp vào hàm khác để có thể xem được giá trị

			// Cách 1: gán trực tiếp giá trị
			int result = fV4(5);
			printf("The result: %d\n", result);

			// Cách 2: nhập giá trị từ bàn phím

			return 0;
		}

----------------------------------------

* Lưu ý: đối với các hàm loại 3 và 4, có thể tưởng tượng việc sử dụng thêm câu lệnh printf() khi đã có dữ liệu trả về như sau...

	Ví dụ: khi được một người nào đó hỏi tuổi.
		[Người lạ]	: "Xin hãy cho tôi biết tuổi của bạn."
		[Tôi]		: "Dạ, 2000."
					-> Thông tin cần thiết là con số "2000",
					   chữ "Dạ" sẽ bị dư
					   khi mỗi lần hỏi là một lần "Dạ",
					   điều này có thể đúng
					   khi người hỏi là một người lớn hơn,
					   nhưng sẽ không còn đúng
					   khi người hỏi là một người nhỏ hơn

--------------------------------------------------------------------------------

[TÓM TẮT CÁC BƯỚC ĐỂ XÂY DỰNG HÀM]

Bước 01: Xác định ý nghĩa và mục đích của hàm mà mình dự định sẽ xây dựng.
	- Hàm có cần xử lý tính toán hay không?
		+ Đặt tên hàm phải nói lên được công dụng của hàm.

Bước 02: Xác định số lượng tham số và loại tham số cần truyền vào hàm (nếu có).
	- Bao nhiêu dữ liệu cần đưa từ bên ngoài vào hàm để tính toán, tương ứng với số lượng tham số cần truyền vào.
	- Tham số truyền vào sẽ là...
		1. Tham trị: tạo ra một hình nhân thế mạng.
		2. Tham chiếu: đích thân tham gia.

Bước 03: Xác định dữ liệu đầu ra.
	- Có kiểu trả về hay không?
		+ Sử dụng hàm có kiểu trả về nếu chỉ trả về duy nhất một giá trị.
		+ Sử dụng hàm không có kiểu dữ liệu trả về...
			1. Khi cần trả về nhiều hơn một giá trị.
			2. Khi không cần trả về giá trị nào (mà chỉ cần thông báo...).

Bước 04: Tiến hành thiết kế chức năng cho hàm bên trong thân hàm (Body of Function).

------------------------------------------------------------

* Lưu ý:
	- Đối với những hàm chỉ đảm nhận việc in thông tin (void) hoặc tính toán và trả về kết quả dựa trên một biến khác (temp, sum, max...) mà không có nhu cầu làm thay đổi / cập nhật giá trị cho tham số đầu vào, ta có thể thiết kế các tham số đầu vào là hằng số.
		+ Việc này giúp đảm bảo rằng trong quá trình hoạt động, hàm không được phép thay đổi bất kì giá trị nào trong tham số.
		+ Việc khai báo tham số là hằng số chỉ làm cho hàm thêm chặt chẽ và thể hiện rõ được mục đích, chứ không phải là bắt buộc.

		Ví dụ: hàm tính tổng hai số nguyên.

			// Biến tinhTongSoNguyen sẽ là biến tạm để trả kết quả về,
			// hai biến soThuNhat và soThuhai không cần phải được cập nhật
			// trong quá trình hàm được thực thi
			int tinhTongSoNguyen(const int soThuNhat, const int soThuhai)
			{
				int tinhTongSoNguyen;
				tinhTongSoNguyen = soThuNhat + soThuhai;
				return tinhTongSoNguyen;
			} 

==========================================================================================

[THƯ VIỆN - LIBRARY]

	* Cách có được hàm để có thể tái sử dụng trong tương lai:

		1. Hàm do ai đó đã viết sẵn và đi kèm với trình biên dịch, ta chỉ việc đi tìm, đem về và sử dụng.
			-> Pre-defined function
				Ví dụ:
					tolwr(kí tự)	 -> Chữ thường
					sqrt(con số)	 -> Căn bậc hai
					abs(con số)	 -> Trị tuyệt đối
					sin(độ góc cung) -> Sin lượng giác
					pow(a, b)	 -> Trả về a^b

		2. Hàm nhà làm.
			-> User-defined function / Custom function
				Ví dụ: getFactorial()

------------------------------------------------------------

* Thư viện (Library): nơi chứa nhiều hàm - tập hợp những câu lệnh sử dụng chung và đã được người khác thiết kế sẵn (có sẵn để ai cũng có thể sử dụng khi cần), có thể sở hữu riêng bằng cách mua hoặc không cần mua mà vẫn có thể sử dụng được ở bất kì đâu. Với mục đích phục phụ tốt nhất cho việc tái sử dụng mà hầu hết các hàm trong thư viện đều là hàm loại 4.
	-> Đây là những hàm sử dụng chung, đã được thiết kế sẵn và chỉ việc gọi lên khi cần.
		(Có thể tự do sử dụng ở bất kỳ đâu.)
	
		=> Trừu tượng hoá (Abstract) những thứ quen thuộc thành bộ thư viện để đem đi sử dụng ở nhiều nơi.

	- Là một dạng chỉ thị tiền xử lý (preprocessor directive), được sử dụng để phục vụ cho những câu lệnh ở phía bên dưới nó. Vì những câu lệnh đã được viết và đóng gói trong những thư viện đã được định nghĩa sẵn (Pre-defined function) và được đính kèm trong bộ cài đặt của IDE. Nên khi cần sử dụng thư viện (hay cụ thể là hàm) nào, thì ta chỉ việc khai báo tên thư viện (sử dụng chỉ thị tiền xử lý #include để thông báo cho chương trình biết) và sau đó chỉ định đúng hàm mà mình cần.

----------------------------------------

* Framework cũng là một dạng thư viện nhưng phức tạp hơn khi còn làm sẵn một giàn khung, các cú pháp đã có sẵn và đã được định nghĩa / quy định từ trước, ta chỉ việc khai báo và sử dụng theo đúng những cú pháp ấy (nếu chỉ có hàm được làm sẵn thì chỉ được gọi là thư viện).
	-> Bộ thư viện với cấu trúc định sẵn.
		(Khi sử dụng phải tuân theo một cấu trúc có sẵn được yêu cầu.)

--------------------------------------------------------------------------------

[CÁCH SỬ DỤNG CÁC THƯ VIỆN TRONG LẬP TRÌNH]

Thư viện (tập tin) trên ổ cứng chứa sẵn các hàm / xử lý và chỉ việc lấy ra sử dụng.
	-> Cần biết thư viện nào chứa hàm gì để tái sử dụng.

Tên của thư viện (Header file) với định dạng .h, sẽ giúp phân loại các hàm và gom những hàm có chung mục đích sử dụng lại với nhau.
	-> Gom những hàm cùng xử lý cho một vấn đề vào cùng một nơi.
		(Lập trình thủ tục / Lập trình hàm.)

	* Cú pháp: #include<thư-viện-nào-đó.h>

		ví dụ: ctype.h, string.h, math.h...

* Cách sử dụng thư viện: trước khi sử dụng thì phải 

	#include ≈ đi vào thư viện để lấy sách ra
	// Khi đã vào được rồi thì thoải mái lấy hàm ra để sử dụng,
	// tìm đến ngăn tủ / kệ sách / giá sách đang chứa thể loại sách ta cần
		-> Khai báo rằng muốn sử dụng hàm do ai đó đã viết sẵn.

		Ví dụ: #include <stdio.h>
			-> Vào thư viện, đến kệ sách math,
			   tại đây sẽ có một đống sách cùng loại liên quan đến math

--------------------------------------------------------------------------------

[MỘT SỐ THƯ VIỆN CÓ SẴN]

- Những thư viện có sẵn trong ngôn ngữ C:

	#include <stdio.h>
		gồm những thư viện nhập xuất cơ bản, chứa printf() và scanf(): hàm điều khiển bàn phím và màn hình để in ra kết quả

	#include <stdlib.h>
		

	#include <math.h>
		gồm những hàm toán học cơ bản: sqrt(), pow()...

		Ví dụ:
			// Hàm trả về số mũ
			float area = 3.14 * pow(radius, 2);

	#include <ctype.h>
		gồm những hàm liên quan đến việc xử lý mã ASCII

	#include <string.h>
		gồm những hàm liên quan đến việc xử lý chuỗi (câu văn) / mảng kí tự: strlen(), strcpy()...

		Ví dụ:
			// Hàm xem độ dài của chuỗi,
			// mặc dù có thể khai báo dư số lượng phần tử
			// nhưng nó chỉ đếm tổng số phần tử
			// nằm trước kí tự '\0' (NULL)
			int len = strlen(name);
			printf("The length of your name: %\n", len);
				

- Bên cạnh đó, ta cũng có thể làm những thư viện .h của riêng mình.

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hàm chứa những câu lệnh,					│
│	sau đó cũng biến thành câu lệnh để nơi khác gọi và sử dụng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[TẦM VỰC CỦA BIẾN - SCOPE OF VARIABLE]

	* Khu vực tự trị: mỗi hàm là một khu vực tự trị, vì những hàm khác nhau sẽ không thể biết được xử lý của nhau.
		-> Khả năng hàm chạm được biến.

** Liên quan đến việc nơi nào có thể và không thể thấy được biến, biến sẽ được chia thành hai loại:

------------------------------------------------------------

[01. BIẾN TOÀN CỤC - GLOBAL VARIABLE]

	* Biến toàn cục (Global variable): biến nằm (được khai báo) lơ lửng ngoài tất cả các "khu vực tự trị" của mỗi hàm (vượt ra khỏi phạm vi kiểm soát của hàm), hàm nào cũng có thể thấy và sử dụng được.

		- Phạm vi sử dụng sẽ trải dài từ nơi mà biến bắt đầu được khai báo/khởi tạo trở xuống.
	
		- Khi sử dụng, phải cẩn thận hiệu ứng lề, vì bất kì hàm nào cũng có thể thay đổi giá trị của nó và nó sẽ chịu sự tác động của hàm gần nhất, nên tốt nhất là không sử dụng nếu không thể kiểm soát được.
		
		- Không nên lạm dụng loại biến này khi thiết kế phần mềm vì nó sẽ phá đi tính độc lập và tự trị của mỗi hàm, biến nhà ai thì nhà nấy quản lý thay vì để công khai.

		-> Khai báo bên ngoài tất cả các hàm/câu lệnh, mọi hàm/câu lệnh đều có thể thấy và thay đổi giá trị được.

			Ví dụ 1: nấu ăn xong, đem ra giữa xóm mời mọi người cùng ăn.

			Ví dụ 2:
				// Biến toàn cục kiêm hàm số
				const float PI = 3.14;

				void computeDiskArea() {
					// Tính diện tích hình tròn có bán kính = 5
					// với số PI được khai báo là hằng số ở toàn cục
					float area = PI * 5 * 5;
				}

----------------------------------------

* Lưu ý: biến toàn cục có thể nằm lơ lửng vì nó chứa dữ liệu và dữ liệu đó có thể chưa cần sử dụng đến. Nhưng với những câu lệnh thì lại khác, CPU chỉ bắt đầu từ hàm main() và thực thi trong main() theo thứ tự từ trên xuống dưới, nên những hàm khác phải được gọi tên ở bên trong main() để CPU có thể thấy và thực thi được.

	- Tất cả các câu lệnh tính toán, phép toán (cộng, trừ, nhân, chia...), xử lý thông tin (if-else, while, do-while, for...)... bắt buộc đều phải nằm trong hàm nào đó, không được đứng riêng lẻ ở ngoài hàm. Nếu viết câu lệnh ở bên ngoài hàm main() thì sẽ khiến CPU bị bối rối khi không biết phải chạy khi nào.

	- Khi khai báo biến toàn cục, ta cũng không được phép đứng ở bên ngoài hàm main() mà gán giá trị cho biến toàn cục sau khi đã khai báo, mà thay vào đó, ta có thể vừa khai báo và vừa lập tức gán giá trị.

	-> Biến toàn cục có thể nằm lơ lửng vì nó chỉ lưu giá trị để xử lý sau này. Nhưng tất cả các câu lệnh đều phải nằm trong hàm, không được viết lơ lửng vì CPU sẽ không biết phải bắt đầu từ đâu và làm sao để gọi được lệnh.

	Ví dụ:
		// Thông báo toàn cục rằng, trong tương lai
		// sẽ có hàm nào đó gán giá trị cho biến này
		int yob;

		// Gán giá trị ở đây là sai vì đây đã là một xử lý
		// (xử lý: đi tìm biến và đưa giá trị vào cho biến),
		// không còn là một câu lệnh khởi tạo để xin cấp một vùng RAM nữa,
		// mà câu lệnh này lại không nằm trong một hàm nào đó
		// nên CPU sẽ không biết phải làm sao để gọi được câu lệnh này
		yob = 2000;

		// Câu lệnh khởi tạo biến toàn cục hợp lệ
		int yob = 2000;

		int main(int argc, char *argv[]) {
			return 0;
		}

------------------------------------------------------------

[02. BIẾN CỤC BỘ - LOCAL VARIABLE]

	* Biến cục bộ (Local variable): biến được khai báo riêng bên trong hàm - "khu vực tự trị" của mỗi hàm.

		- Phạm vi sử dụng của biến bị giới hạn trong một hàm (bên trong cặp dấu ngoặc nhọn "{}") hoặc một câu lệnh (if, for...) - biến tạm, biến chỉ số (index), biến đếm...
	
		- Biến chỉ có ý nghĩa tại nơi mà nó được khai báo, khi ra bên ngoài sẽ trở nên vô nghĩa, những nơi khác cũng không có quyền can thiệp vào biến.
		
		- Từ đó sẽ giúp ta tránh được hiệu ứng lề. Nhưng nếu sử dụng con trỏ thì các hàm có thể can thiệp biến của nhau.

		-> Khai báo bên trong các hàm/câu lệnh, các hàm/câu lệnh khác không thể thấy và thay đổi giá trị được (trừ trường hợp sử dụng con trỏ).

		Ví dụ 1: nấu ăn xong, đồ ăn trong bếp chỉ thành viên trong gia đình mới có thể ăn.

		Ví dụ 2:
			void computeDiskArea() {
				// Tính diện tích hình tròn có bán kính = 5
				// với số PI được khai báo là biến cục bộ
				float PI = 3.14;
				float area = PI * 5 * 5;
			}

		Ví dụ 3: những nơi có thể khai báo biến cục bộ

			// 1. Bên trong một hàm
			//	Ví dụ 1: hàm computeDiskArea()
			void computeDiskArea() {
				// Biến PI và biến area được khai báo là biến cục bộ
				float PI = 3.14;
				float area = PI * 5 * 5;
			}

			//	Ví dụ 2: hàm main()
			int main(int argc, char *argv[]) {
				// Biến n được khai báo là biến cục bộ
				int n = 10;
				printf("n = %d", n);
			}


			// 2. Bên trong một câu lệnh nhỏ khác (vòng lặp)
			//	(Biến siêu cục bộ)
			int acc = 0

			// Biến i được khai báo là biến cục bộ
			// * Lưu ý: hạn chế khai báo trong vòng lặp
			//	    đối với những biến đếm
			//	    vì có thể sẽ gặp hiệu ứng lề
			//	    (lặp lại vòng lặp thì biến sẽ bị gán về giá trị cũ)
			for (int i = 1; i <= 10; i++)
				// int acc = 0; // KHÔNG NÊN
				acc = acc + i;


			// 3. Ngay trên đầu của hàm (sau tên của hàm)
			//	(Tham số đầu vào - Parameter/Argument)
			// Biến x được khai báo là biến cục bộ
			int f(int x) {
				...;
			}

------------------------------------------------------------

=> Hàm chỉ có thể thay đổi giá trị của biến toàn cục (global variable) và biến cục bộ (local variable) của chính nó, nhưng không có quyền thay đổi giá trị biến cục bộ (local variable) của hàm khác, trừ trường hợp sử dụng con trỏ.

------------------------------------------------------------

* Lưu ý: tuy được phép nhưng nếu cố tình đặt tên biến cục bộ (local) trùng với tên biến toàn cục (global) thì sẽ gây ra hiệu ứng lề (side effect), đó là khi lấy biến ra để gán giá trị hoặc xử lý thì sẽ có nguy cơ không lấy chính xác giá trị cần, vì hàm sẽ ưu tiên biến cục bộ (Ưu tiên người nhà - Con Ông Cháu Cha - Hide a Global Variable).

------------------------------------------------------------

Trong lập trình hướng đối tượng, hiểu một cách đơn giản thì các biến toàn cục cùng với phần thân hàm sẽ được gom lại và để ở một tập tin riêng, gọi là lớp (class), để từ lớp đó mà có thể tạo ra nhiều đối tượng (object).

--------------------------------------------------------------------------------

[TRUYỀN GIÁ TRỊ VÀO HÀM]

** Kỹ thuật đưa giá trị vào hàm thông qua đầu vào của hàm:

------------------------------------------------------------

[01. TRUYỀN THAM TRỊ - PASS BY VALUE]

	* Truyền tham trị (Pass by value): đưa một giá trị thuần nào đó (số, chữ...) với những kiểu dữ liệu quen thuộc (int, double, char...) vào cho hàm (thông qua tên hàm) vì hàm chỉ cần giá trị.

		- Tạo ra một vùng nhớ khác, đưa một bản sao hoàn chỉnh của giá trị vào vùng nhớ mới và chỉ tiến hành xử lý trên vùng nhớ mới này.

		- Vùng nhớ ban đầu hoàn toàn không bị ảnh hưởng dù cho giá trị ở vùng nhớ mới bị thay đổi, vì đây đã là hai vùng độc lập hoàn toàn.

		- Thường sử dụng khi ta chỉ có nhu cầu in giá trị ra màn hình hoặc mượn giá trị để đi tính một giá trị khác.

		-> Chỉ cần truyền/đưa-nhận giá trị, không cần quan tâm đến tên của biến hoặc địa chỉ ở đâu.
			(Tham trị: tham số ở đây chỉ đơn giản là giá trị thông thường.)
			(Miễn trừ trách nhiệm.)

		Ví dụ 1: khi được ai đó mượn tiền, người cho mượn sẽ cầm tiền trên tay và đưa trực tiếp tiền mặt cho người cần mượn.
				-> Nhận được ngay tiền mặt.

		Ví dụ 2: giống như việc sao chép một loại văn bản, sau khi đưa bản sao, dù bản sao có thay đổi thì bản gốc cũng không bị ảnh hưởng.
				-> Hai phiên bản độc lập.

		Ví dụ 3: ba mẹ mua cho người con chiếc xe giống hệt như chiếc mà ba mẹ đang sử dụng. Dù người con có đem xe đi độ, đi đua hoặc đi bán thì cũng chỉ ảnh hưởng đến chiếc xe của người con, chứ không ảnh hưởng đến chiếc xe của ba mẹ.
				-> Một bản sao độc lập của chiếc xe, có thể lập tức sử dụng mà không lo ảnh hưởng đến nhau.

----------------------------------------

	Ví dụ: cách truyền tham trị vào hàm

		int f(int x);

		int main() {
			// Cách 1: truyền trực tiếp
			f(5); // 5^2 = 5 * 5 = 25

			// Cách 2: truyền thông qua bàn phím
			int x;
			printf("Please input a number");
			scanf("%d", &x);

			int result = f(x);
			printf("The result: %d", result);
		}

		// Biến x của hàm main() sẽ đưa GIÁ TRỊ cho biến x của hàm f()

		int f(int x) {
			// Cả x và y ở đây đều được gọi là biến cục bộ
			// Trong đó:
			//	- x là biến đầu vào (parameter/argument)
			//	- y là biến trung gian
			int y = x * x;
			return y;
		}

------------------------------------------------------------

[02. TRUYỀN THAM CHIẾU / THAM BIẾN - PASS BY REFERENCE / PASS BY POINTER]

		* Tham: tham khảo, xem thêm, hỏi thăm.
		* Chiếu: soi, rọi đến một chỗ khác ở xa.
	* Truyền tham chiếu / tham biến (Pass by reference / Pass by pointer): khi giá trị được đưa vào nơi xử lý lại là địa chỉ dẫn đến một nơi khác chứa giá trị thật sự.

		- Những thay đổi ở trong hàm cũng làm ảnh hưởng đến giá trị của nơi gọi hàm, vì vậy, thường sử dụng khi một hàm được giao trách nhiệm làm thay đổi giá trị nào đó (ở bên ngoài) - mượn hàm để làm thay đổi giá trị.

		- Đây là cách đưa con trỏ (pointer) - địa chỉ bộ nhớ vào cho hàm. Tham chiếu là khái niệm chỉ có ở C++.

		- Thường được thấy trong lập trình hướng đối tượng, khi tham số truyền vào hàm là một mảng/toạ độ thay vì một biến bình thường.

		-> Quan tâm đến tên của biến và địa chỉ ở đâu, đến địa chỉ sẽ lấy được giá trị.
			(Tham chiếu: tham số ở đây là địa chỉ và trỏ đến nơi thật sự chứa giá trị.)
			(Khi hai ta về một nhà.)

		Ví dụ 1: khi được ai đó mượn tiền, người cho mượn sẽ nói rằng đã số tiền đã được cất ở một địa điểm khác, sau đó đưa địa chỉ để người cần mượn tự đến và lấy tiền.
				-> Nhận được địa chỉ, chỉ đến nơi có tiền mặt.

		Ví dụ 2: giống như việc đi thi hộ, một khi đã đưa hết dụng cụ cần thiết để bước vào phòng thi, kết quả làm bài của người đi thi hộ như thế nào thì người thuê thi hộ phải chấp nhận như vậy.
				-> Tuy hai mà một.

		Ví dụ 3: ba mẹ mua đưa cho người con địa chỉ - nơi mà họ cất chiếc xe của họ. Vì vậy, mỗi lần người con cần sử dụng thì phải đến đúng địa chỉ đó để lấy. Nếu người con đem xe đi độ, đi đua hoặc đi bán thì đều sẽ ảnh hưởng đến chiếc xe của ba mẹ.
				-> Địa chỉ cất xe, cả nhà sẽ đến lấy, sử dụng chung và ảnh hưởng đến người khác nếu có thay đổi.

----------------------------------------

	Ví dụ: cách truyền tham trị vào hàm

		void f(int* x);

		int main(int argc, char *argv[]) {
	
			// Biến cục bộ trong hàm main()
			int x = 10;
			printf("In main(), before calling f(), x is: %d\n", x);
	
			// Đưa địa chỉ của biến x cho hàm f()
			// để thay đổi giá trị trong x trong hàm main()
			f(&x);
			printf("In main(), after calling f(), x finally is: %d\n", x);
	
			return 0;
		}

		void f(int* x) { // Biến cục bộ trong hàm f()
			// Vì đây là biến con trỏ, trỏ đến một nơi khác,
			// nên nếu trong hàm thực hiện phép toán
			// thì biến ở xa cũng sẽ bị ảnh hưởng
			*x = *x * *x; // (*x) = (*x) * (*x); -> Bình phương
		}

----------------------------------------

* Tham khảo thêm: https://youtu.be/XJKegdhmw4g?t=2895 (Cách truyền tham chiếu trên Stack).

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――
│	Tham trị: Hình nhân thế mạng	│
│	Tham chiếu: Đích thân tham gia	│
―――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[NGUYÊN MẪU HÀM - FUNCTION PROTOTYPE]

Nguyễn mẫu hàm (Function Prototype): cho biết rằng sẽ có những hàm gì - tên hàm/giàn khung, chỉ cho biết tên hàm, tham số đầu vào kèm kiểu dữ liệu trả về (nếu có) chứ chưa nói đến chức năng của hàm, những câu lệnh thật sự của hàm sẽ nằm ở một nơi khác.

	- Sử dụng khi muốn thông báo cho chương trình dịch rằng trong chương trình sẽ có sử dụng những hàm tự tạo (User-defined function / Custom function) mà không phải là những hàm có sẵn trong thư viện.

	- Thường được khai báo ở đầu chương trình - bên trên hàm main().

	- Nguyên mẫu hàm chỉ là giàn khung, còn những xử lý thật sự của hàm sẽ được viết ở một nơi khác được gọi là thân hàm (Body of function) hay còn được gọi là phần định nghĩa / cài đặt / triển khai / hiện thực của hàm (Implementation / Implement of function) - được đặt bên dưới hàm main().

	- Thậm chí, ta có thể không cần phải khai báo tên của các tham số, chỉ cần có: tên hàm, kiểu dữ liệu trả về của hàm, kiểu dữ liệu của tham số đầu vào - tham số hình thức, các toán tử con trỏ / tham chiếu (nếu có).

	-> Chứ ký / Dấu ấn hàm (Function Signature): tên của hàm, thông báo về ý tưởng của hàm sắp thiết kế.
		(Giàn khung ý tưởng, chưa có xử lý bên trong.)

	Ví dụ:
		// Nguyên mẫu hàm được khai báo bên trên hàm main()
		void printYob();
		void printLatestYob();
		void seeNothing();
		int isPrime(int ); // Không cần tên của tham số

		int main(int argc, char *argv[]) {
			// Những xử lý, gọi hàm trong hàm main()
		}

		// Phần thân hàm được triển khai bên dưới main()
		int isPrime(int n) {...}

Có thể không cần phải khai báo nguyên mẫu hàm bên trong code, nhưng như vậy sẽ khiến code không có tính định hướng.

Hơn hết, khi một số hàm có gọi đến những hàm khác bên trong, mà những hàm được gọi lại chưa được biên dịch vì chương trình được thực thi tuần tự (hàm được gọi nằm bên dưới hàm đi gọi), thì nguyên mẫu hàm sẽ giúp khắc phục tình trạng này.

Ngoài ra, toàn bộ tên hàm được khai báo trong phần nguyên mẫu hàm, nếu được đem sang để ở một tập tin riêng thì được gọi là thư viện .h (header - tựa đề).
	-> Thực chất thư viện .h là một tập tin, bên trong liệt kê tất cả các tên hàm.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Thông báo những thông tin chung			│
│	về những hàm sẽ sử dụng trong chương trình,	│
│	đồng thời giúp bỏ qua thứ tự xuất hiện của hàm	│
│	trong quá trình thiết kế hàm			│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[KHUÔN MẪU HÀM - FUNCTION TEMPLATE]

* Khuôn mẫu hàm (Function Template): cho phép định nghĩa ra những hàm tổng quát - hàm có thể thao tác cùng một lúc trên nhiều kiểu dữ liệu.

	- Chỉ hỗ trợ ở C++.

(Tham khảo thêm: https://youtu.be/xJqOiWR6oyc - Thien Tam Nguyen)

==========================================================================================

[CẤU TRÚC CỦA MỘT ỨNG DỤNG]

Cách tổ chức mã nguồn của một ứng dụng (được viết bằng ngôn ngữ C):

* Chỉ thị (Directive): đưa ra những chỉ dẫn để máy tính biết phải làm gì.

	// Khai báo thư viện (Library)
	#include<stdio.h>
	#include<stdlib.h>
	#include<thư-viện-nào-đó.h>

	// (Macro definition)
	#define

	// Khai báo hằng số (Constant)
	const int
	const double VAT = 0.08;
	const float PI = 3.14;

	// Khai báo biến toàn cục (Global variable)
	int yearofBirth = 2000;
	int currentYear = 2022;
	char letter = '$';

	// Khai báo nguyên mẫu hàm (Prototype)
	int getFactorial (int x);
	void printMenu();

	// Hàm main()
	int main(...) {
		khai báo biến cục bộ trong hàm;
		int choice;

		lệnh xử lý gì đó;
		if-else;
		while();
		do {} while();
		for();

		cácHàmNhàLàm();
		cácHàmLàmSẵn();
		void printMenu();
		int getFactorial();

		return 0;
	}

	// Khai báo hàm (Function)
	int getFactorial (int x) {
		// Thân hàm - lệnh chi tiết bên trong của hàm (Body of function)
		// Phần hiện thực của hàm (Implementation/Implement of a function)
		khai báo biến cục bộ trong hàm;
		int choice;

		các lệnh xử lý gì đó;
		code tính n giai thừa ở đây;
		code của hàm sẽ do ta viết ở đây;

		gọi hàm khác ở đây;

		return giá-trị-nào-đó;
	}

	void printMenu() {
		// Thân hàm - lệnh chi tiết bên trong của hàm (Body of function)
		// Phần hiện thực của hàm (Implementation of a function)
		khai báo biến cục bộ trong hàm;
		code của hàm sẽ do ta viết ở đây;
	}

==========================================================================================

[MẢNG - ARRAY]

	* Giá trị vùng RAM có thể là:
		- Giá trị thuần, quen thuộc: con số, chữ, chuỗi (int, long, float, char...).
		- Giá trị đặc biệt: con trỏ (pointer).

* Nhắc lại về biến: biến là một vùng RAM được đặt tên, được sử dụng để lưu giá trị và phục vụ cho việc xử lý.

	- Theo vòng đời tồn tại của biến, vì giá trị của biến có thể bị thay đổi, nên biến sẽ chỉ giữ giá trị của lần sửa đổi gần nhất và giá trị của những lần sửa đổi trước đó sẽ bị mất đi.
	
	- Điều này có nghĩa là tại một thời điểm, biến chỉ lưu trữ được một giá trị, không thể lưu được nhiều giá trị dù cho có cố tình thay đổi.

	-> Muốn lưu được nhiều giá trị để sử dụng lại sau này thì sử dụng nhiều biến (mỗi biến lưu cố định một giá trị).
		-> Sử dụng nhiều biến đồng nghĩa với nhu cầu tính toán, thống kê... cũng nhiều theo.

--------------------------------------------------------------------------------

Về nguyên tắc, khi khai báo biến sẽ có hai cách:

----------------------------------------

	1. Lẻ (bán ít - khai báo ít/rời rạc): khai báo thủ công từng biến một. Tuy có thể khai báo nhiều biến cùng một lúc với cùng một kiểu dữ liệu, nhưng chưa chắc sẽ nằm gần nhau trong RAM và sẽ rất tốn sức khi số lượng biến nhiều (ví dụ: cần vài trăm, vài nghìn... biến).

		Ví dụ 1: để lưu được 10 cột đỉểm của một môn học.

			// Col (column): các cột điểm
	
			// Khai báo lẻ từng biến một,
			// tuy tốn thời gian và công sức,
			// nhưng dễ hiểu và được sử dụng trực tiếp tên biến
			float col1, col2, col3, col4, col5,
			      col6, col7, col8, col9, col10;

		Ví dụ 2: một Trung tâm Dự báo khí tượng thuỷ văn cần lưu được lưu lượng mưa trong một năm, thập kỷ (10 năm), thế kỷ (100 năm)... để theo dõi sự biến đổi của khí hậu nhằm hỗ trợ cho nông nghiệp.

			// Vol (volume): vũ lượng (lượng mưa)

			// Khai báo lượng mưa trong năm (không nhuận),
			// lưu theo từng ngày để so sánh giữa các năm
			float vol1, vol2, vol3, vol4, vol5,
			      vol6, ..., vol365;
				// Nếu cần đến 365 biến
				// thì phải khai báo thủ công 365 lần

----------------------------------------

	2. Sỉ (bán nhiều - khai báo nhiều/một loạt): sử dụng khi cần khai báo cùng một lúc nhiều biến có cùng kiểu dữ liệu, để lưu những giá trị khác nhau mà không tốn sức, lại còn nhanh gọn hơn và có thể tận dụng tốt vòng lặp (for, while, do-while).

		Ví dụ: để lưu được 10 cột đỉểm của một môn học

			// Giống cách khai bảo lẻ bên trên ở điểm
			// vẫn sẽ có được 10 biến độc lập nhau,
			// nhưng cách khai báo sẽ nhanh và cũng khó hiểu hơn,
			// muốn có bao nhiêu biến thì chỉ cần
			// thay đổi giá trị trong cặp ngoặc vuông [số-biến]
			float col[10];

			// Toàn bộ biến sẽ có cùng một tên,
			// nên sẽ phân biệt giữa các biến cùng tên này bằng chỉ số phụ
			// để cho biết rằng đây là biến thứ mấy, bắt đầu từ [0]
			col[0] = 10.0;
			col[1] = 9.0;
			col[2] = 8.0;
			...;
			col[9] = 8.0; // Biến cuối cùng

------------------------------------------------------------

* Lưu ý:
	- Việc sử dụng mảng chỉ cải thiện về cách nhập nhiều biến (về cách khai báo) để được hiệu quả hơn, còn về mặt lưu trữ thì đều tốn một vùng RAM tương đương nhau.

		Ví dụ:
			// Khai báo biển lẻ
			int col1, col2, col3;
			//	-> Vẫn là 3 biến col
			//	   với tổng số Byte tiêu tốn là 12 Byte (3 biến * 4 Byte)

			// Khi báo mảng sỉ
			int col[3]
			//	-> Vẫn là 3 biến col ([0], [1], [2])
			//	   với tổng số Byte tiêu tốn là 12 Byte (3 biến * 4 Byte)

	- Tuỳ vào phong cách khai báo mảng, những phần tử đã được khai báo mà chưa được gán giá trị sẽ mang giá trị rác hoặc được mặc định gán bằng 0.

--------------------------------------------------------------------------------

[CHI TIẾT VỀ MẢNG]

	* Trong cuộc sống, bè mảng gồm những cây tre luồng, tre lồ ô, tre bương... đã già, được kết lại với nhau thành một khối từ ba đến bốn cái đều nhau để làm mạn, sau đó dùng dây cước, dây mây hoặc dây song kết buộc thật chặt.

* Mảng (Array): hay còn được gọi là danh sách đặc.

	- Là kỹ thuật lưu trữ và xử lý rất nhiều biến (dữ liệu) trong RAM cùng một lúc (không phải từng biến đơn lẻ).
	
	- Là cách thức đem rất nhiều dữ liệu từ bên ngoài vào trong máy tính để sắp xếp, tìm kiếm, lọc...

	Ví dụ: lưu trữ và xử lý những dữ liệu cùng kiểu
		- Danh sách sinh viên của một trường Đại học.
		- Danh sách nhân viên của một công ty.
		- Danh sách bệnh nhân của một bệnh viện.
		- Danh sách đơn hàng của một siêu thị.
		- Danh sách giao dịch của một ngân hàng.
			-> Có nhiều dữ liệu và cần nhiều biến để lưu trữ.

* Trong lập trình, mảng là kỹ thuật khai báo và xếp cùng một lúc nhiều biến giống nhau (cùng kiểu dữ liệu) ở sát nhau trong RAM, được đặt cùng một tên - lấy tên mảng làm tên chung.

	- Điều này sẽ giúp cho việc khai báo và lưu trữ một loạt các biến được nhanh và đỡ tốn sức hơn.

	- Nhưng đánh đổi thì tên của từng biến trong mảng sẽ phức tạp hơn và phải phân biệt giữa các biến trong mảng bằng chỉ số phụ / thứ tự biến (index).

	- Vì mảng sẽ nằm liên tiếp nhau, nên dù vẫn đủ bộ nhớ nhưng các ô nhớ lại không nằm liên tiếp nhau, thì sẽ không thể cấp phát được. Lúc này, ta sẽ sử dụng danh sách liên kết (Linked List).

	-> Mảng là kỹ thuật khai báo cùng một lúc nhiều biến có cùng kiểu dữ liệu, xếp sát nhau trong RAM, với cùng một tên gọi và phân biệt nhau bằng chỉ số phụ/thứ tự biến (index).
		(Nhiều biến = Nhiều giá trị, Mảng chứa nhiều biến = Mảng chứa nhiều giá trị.)

Khi nói về biến đơn giản, ta thường nghĩ ngay đến duy nhất một giá trị nào đó. Nhưng khi nói về mảng, ta lại nghĩ ngay đến một loạt các giá trị.
	-> Mảng là tập hợp nhiều giá trị.

	Ví dụ: khi nói về sữa đóng hộp
		- Lẻ: một hộp sữa -> Một hộp duy nhất.
		- Sỉ: một lốc sữa -> Gồm nhiều hộp sữa hợp thành.

	- Tính từ 0, mỗi biến nhỏ trong mảng được gọi là một phần tử mảng (element). Ngoại trừ việc có thêm tên gọi mới, còn lại, biến trong mảng cũng bình đẳng giống như mọi biến bình thường khác.
		-> Trong mảng, phần tử là biến, bắt đầu tính từ 0 thì vì 1 như thông thường.

	- Mặc dù biến không được phép trùng tên, nhưng các biến/phần tử trong mảng lại có cùng một tên và khác chỉ số phụ (index). Lúc này, thứ không được phép trùng lại là tên mảng (không thể khai báo hai mảng cùng tên, dù có khác kiểu dữ liệu).
		-> Các biến/phần tử trong mảng tuy có cùng tên gọi nhưng sẽ khác chỉ số phụ.

	- Vì có cùng phần tên mảng và chỉ khác phần số phụ (index), nên khi làm việc với mảng thì ta sẽ sử dụng vòng lặp (for, while, do-while). Nếu biến/phần tử trong mảng có chỉ số bắt đầu từ 0 thì ta chỉ duyệt đến < (số-phần-tử - 1).
		-> Nhà có 5 nàng tiên, nếu chị cả tên 0 thì cô em út phải tên là 4.

	=> Mảng là kỹ thuật khai báo nhiều biến (phần tử mảng):
		- Cùng lúc.
		- Cùng tên.
		- Cùng kiểu dữ liệu.
		- Cùng được xếp liên tiếp, sát nhau trong RAM.

		Ví dụ:
			int main(int argc, char *argv[]) {

				// Khai báo mảng col[] có 10 phần tử (biến)
				float col[10];
	
				// Sử dụng vòng lặp for
				// để hỏi địa chỉ của 10 phần tử mảng
				printf("The address of all if elements in the array:\n");
				for (int i = 0; i < 10; i++)
					printf("The address of col[%d] is %u\n", (i + 1), &col[i]);
				return 0;
			}

			// Địa chỉ của 10 phần tử sẽ nằm cạnh nhau
			// và cách nhau 4 Byte (kiểu dữ liệu float)

			// The address of col[1] is 6684144
			// The address of col[2] is 6684148
			// The address of col[3] is 6684152
			// The address of col[4] is 6684156
			// The address of col[5] is 6684160
			// The address of col[6] is 6684164
			// The address of col[7] is 6684168
			// The address of col[8] is 6684172
			// The address of col[9] is 6684176
			// The address of col[10] is 6684180

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Mảng là tập hợp gồm nhiều biến được khai báo cùng lúc,	│
│	có cùng một kiểu dữ liệu, có cùng một tên mảng		│
│	và cùng được xếp liên tiếp, sát nhau trong RAM.		│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

[LỪA ĐẢO CHỈ SỐ / THỨ TỰ PHẦN TỬ CỦA MẢNG]

Mảng trong các ngôn ngữ lập trình thường được tính từ 0, trừ một số ngôn ngữ như Pascal thì sẽ tính từ 1. Vì vậy, khi in ra thì chỉ số/thứ tự cũng sẽ bắt đầu từ 0. Để việc hiển thị được thân thiện với người dùng hơn khi chỉ số/thứ tự in ra bắt đầu từ 1 thay vì 0 giống như trong máy tính, nhưng vẫn chọn đúng phần từ trong mảng thì ta cần phải linh hoạt ±1 cho chỉ số phụ/thứ tự biến trong lúc viết để phần tử trong mảng vẫn bắt đầu từ 0.
	-> Giúp cho việc hiển thị được thân thiện hơn đối với người sử dụng (user).

	Ví dụ 1: lừa đảo chỉ số/thứ tự, chỉ số/thứ tự khi được in ra sẽ bắt đầu từ 1

		float col[10];
	
		printf("Please input 10 grade (0..10) of the C class\n");

		// Khởi tạo chỉ số bằng 0
		for (int i = 0; i < 10; i++) {
			printf("Input grade[%d]: ", (i + 1));   // Lừa đảo chỉ số mảng
								// bằng cách + 1
			scanf("%f", &col[i]);

	Ví dụ 2: lừa đảo chỉ số/thứ tự, chỉ số/thứ tự khi được in ra sẽ bắt đầu từ 1
	
		float col[10];

		printf("The address of all if elements in the array:\n");

		// Khởi tạo chỉ số bằng 1
		for (int i = 1; i <= 10; i++)
			printf("The address of col[%d] is %p\n", i, &col[i - 1]); // Lừa đảo chỉ số mảng
										  // bằng cách - 1

* Lưu ý: trong câu lệnh printf(), biến i chỉ được phép tham gia vào biểu thức (công thức tính toán) chứ bản thân nó không được thay đổi giá trị, nếu vô tình thay đổi thì nó sẽ khiến biến đếm nhảy số (bỏ qua số) và không còn đúng nữa. Vì vậy, không được sử dụng phép tăng/giảm tự thân (++ và --) để lừa đảo chỉ số mà chỉ nên lấy biến i và cộng hoặc trừ với một con số khác.

------------------------------------------------------------

[TÊN MẢNG & CON TRỎ]

Mặc định, biến không được phép đặt trùng tên, vì như vậy sẽ rất khó để phân biệt giữa các biến. Nhưng mảng là trường hợp đặc biệt khi tên mảng là tên sử dụng chung cho tất cả các biến (phần tử mảng). Lúc này, để phân biệt giữa các phần tử trong mảng với nhau, ta sử dụng chỉ số phụ / thứ tự biến (index).

	Ví dụ 1: khi trong lớp có hai học sinh / sinh viên trùng tên nhau hoàn toàn, để gọi đúng người
		- tênRiêng [1] và tênRiêng [2]
		- tênRiêng [A] và tênRiêng [B]
		- tênRiêng [nam] và tênRiêng [nữ]
		- tênRiêng [cao] và tênRiêng [thấp]
		- tênRiêng [gầy] và tênRiêng [béo]
		- ...
			-> Đặt tên phụ để dễ phân biệt.

	Ví dụ 2: khi các phần tử trong mảng có cùng một tên
		float col[3];

		// Ta sẽ có 3 biến: col[0], col[1], col[2]
		// 	với [0], [1], [2] là các chỉ số phụ / thứ tự biến (index)
		//
		// Tên mảng lúc này là: col
		// Tên biến / phần tử lúc này là: col[0], col[1], col[2]

----------------------------------------

Ngoài ra, ngôn ngữ C còn ngầm định một biến ẩn - tên mảng (biến ma cô). Theo đó, tên mảng là một biến rất đặc biệt và bị ẩn, không lưu giá trị bình thường (int, long, float, double, char...) như bao biến khác, mà lại đi lưu địa chỉ của biến/phần tử (Byte) đầu tiên trong mảng mà nó đang quản lý (ví dụ: a[0]).
	* Byte đầu tiên: cũng giống như địa chỉ nhà (có bao gồm số nhà), không cần biết nhà có chiều dài và chiều rộng là bao nhiêu, chỉ cần quan tâm nhà nằm ở địa chỉ bao nhiêu (số nhà là bao nhiêu). Vì mỗi nhà chỉ có duy nhất một địa chỉ, nên nếu có được địa chỉ nghĩa là đi đến được căn nhà đó (với số nhà tương ứng).

Nói cách khác, tên mảng chính là con trỏ (pointer) - Reference Variable, chỉ khác là nó sẽ mặc định có sẵn sau khi khai báo mảng.

	- Đối với mảng tĩnh (static array), vì tên mảng không phải là con trỏ thuần chủng / chính hãng mà chỉ là con trỏ biến thể / giả, nên chỉ sử dụng để lưu địa chỉ của phần tử đầu tiên trong mảng và vĩnh viễn không thể thay đổi/lưu thành địa chỉ của bất kì phần tử nào khác trong mảng, mục đích là để đảm bảo sự ổn định trong việc quản lý các phần tử của mảng.
	
	- Cũng do đó, tên mảng không thể tham gia vào phép tăng/giảm tự thân (++ và --), mà chỉ có thể tham gia vào các phép toán thông thường (cộng, trừ...). Còn với biến con trỏ thuần chủng / chính hãng, tuy phải gán giá trị thủ công (ví dụ: tênBiếnConTrỏ = &tênBiếnThôngThường), nhưng lại có thể thay đổi địa chỉ và tham gia vào bất kì phép toán nào nếu muốn, kể cả phép tăng/giảm tự thân vì nó đã là một vùng RAM riêng.

	-> Tên mảng giống như giáo viên chủ nhiệm, quản lý toàn bộ học sinh trong lớp thông qua chỉ duy nhất địa chỉ của lớp trưởng.
		(Giảng viên chỉ lưu số điện thoại và địa chỉ nhà của một mình lớp trưởng - người đứng đầu lớp, để tiện cho việc liên lạc mỗi khi có thông tin cần thông báo cho cả lớp.)

=> Tên mảng (khi đứng một mình) chính là con trỏ (biến ma cô), là một biến trỏ đến địa chỉ của một vùng RAM, nhưng lại nói về một dãy RAM gồm nhiều biến liên tiếp nhau.
	(int a[]; = int* a; = Biến lưu địa chỉ)

	Ví dụ:
		// Khai báo con trỏ thông thường
		int *a = &biếnThôngThường;

		// Khai báo mảng
		int a[] = {5, 10, 15, 20, 25};
		// Lúc này, tên mảng là "a"
		// và có thể sử dụng như biến con trỏ
		// 	Sử dụng:	int a (tên mảng, bỏ []) = int *a (con trỏ)
		//	Lấy giá trị:	    a[0]		=     *biếnThôngThường

Vì bản thân tên mảng là biến để lưu địa chỉ, nên khi in ra, chỉ cần sử dụng printf("%d") để in giá trị này ra và ta sẽ thấy được địa chỉ của phần tử đầu tiên trong mảng mà không cần phải sử dụng %u như biến thông thường (???).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Tên mảng là con trỏ, lưu địa chỉ của phần tử đầu tiên trong mảng	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

[GÁN GIÁ TRỊ CHO MẢNG]

Có ba cách để khai báo và gán giá trị cho mảng (khởi tạo mặc định): thường được sử dụng khi muốn kiểm tra nhanh cho chương trình.

----------------------------------------

	1. Khai báo số lượng phần tử trước và sau đó mới gán giá trị cho từng phần tử riêng lẻ, những phần tử còn lại sẽ nhận giá trị rác nếu chưa được gán giá trị.
		-> Xin số lượng phần tử trước, gán giá trị cho từng phần tử sau.

		Ví dụ: khi báo số lượng phần tử trước, gán giá trị sau.

			float col[5];
			col[0] = 10;
			col[1] = 9;
			// Trong trường hợp này,
			// col[2], col[3], col[4] sẽ nhận giá trị rác

----------------------------------------

	2. Khai báo số lượng phần tử và song song gán giá trị theo kiểu tập hợp, những phần tử chưa được gán giá trị chắc chắn sẽ bằng 0 chứa không mang giá trị rác.
		-> Xin số lượng phần tử, đồng thời gán giá trị cho một loạt các phần tử.

		Ví dụ: vừa khai báo số lượng phần tử, vừa khởi tạo giá trị.

					[0]  [1]  [2]  [3]  [4]  [5]
			float col[10] = {1,   1,   2,   3,   5,   8};
			// Gán trước giá trị cho 6 phần tử đầu tiên,
			// các phần tử [6], [7], [8], [9] còn lại sẽ đều được gán bằng 0

----------------------------------------

	3. Khai báo nhưng không nói rõ mảng sẽ có bao nhiêu phần tử và gán giá trị cho từng phần tử theo kiểu tập hợp. Lúc này, tổng số lượng phần tử đã được gán giá trị sẽ tương đương với tổng số lượng phần tử của mảng.
		-> Không cần xin số lượng phần tử, chỉ cần gán giá trị cho các phần tử.

		Ví dụ: không cần khai báo số lượng phần tử, chỉ cần khởi tạo giá trị.

			float col[] = {1, 1, 2, 3, 5, 8};
			// Gán sẵn giá trị cho 6 phần tử,
			// mảng sẽ tự động cấp số lượng phần tử
			// dựa theo số lượng giá trị đã gán

			// Lúc này, ta có thể thủ công
			// xác định kích thưởng của mảng theo công thức
			int soLuongPhanTu = sizeof(a) / sizeof(a[0]);

----------------------------------------

* Lưu ý: Đối với mảng tĩnh (static array), nếu muốn quy định số lượng phần tử của mảng bằng một giá trị nào đó do người dùng nhập thay vì sử dụng giá trị mặc định, thì số lượng phần tử phải cố định.

	Ví dụ:
		// Số lượng phần tử phải là hằng số
		const int MAX_SIZE = 100;
		#define MAX_SIZE 100
			// Số lượng phần tử tối đa mà một mảng được cấp phát
			// khi vừa được nạp

		// Không thể sử dụng một biến thông thường
		int n = 100;

		int arr[MAX_SIZE]; // Được phép
		int arr[n]; // KHÔNG được phép

--------------------------------------------------------------------------------

[HÀM TẠO GIÁ TRỊ NGẪU NHIÊN - RAND()]

* rand(): là hàm trả về một giá trị số nguyên ngẫu nhiên trong khoảng từ 0 đến RAND_MAX.

	- RAND_MAX: hằng số có giá trị phụ thuộc vào nhiều yếu tố (ví dụ: hệ điều hành, trình biên dịch...) và có giá trị ít nhất là 32767.

	- Hàm rand() không cần tham số đầu vào.

	- Vì không theo thời gian thực, nên các lần chạy chương trình khác nhau sẽ cho ra cùng một giá trị.
		+ Kết hợp thêm hàm srand() và tham số time(0) (hoặc time(NULL)) để tạo ra những giá trị ngẫu nhiên theo thời gian thực.
		+ Cần khai báo thêm thư viện time.h (ngôn ngữ C) và ctime (ngôn ngữ C++).

	- Có thể quy định / giới hạn khoảng giá trị mong muốn:
		+ Trong đoạn [0, n - 1]: rand() % n
		+ Trong đoạn [a, b]: rand() % (b - a + 1) + a

--------------------------------------------------------------------------------

[THUẬT TOÁN TƯƠNG TÁC TRÊN MẢNG]

------------------------------------------------------------

[TÌM PHẦN TỬ TRONG MẢNG]

Cho mảng: -5, 10, 100, -50, 100, 1001, 1

Ví dụ: Tìm số 10 trong mảng số vừa được nhập từ bàn phím.
	-> Duyệt qua từng phần tử trong mảng để so sánh giá trị của nó với 10.

----------------------------------------

[TÌM GIÁ TRỊ LỚN NHẤT & NHỎ NHẤT]

Ví dụ: Tìm giá trị lớn nhất trong mảng.

	int timGiaTriLonNhatTrongMang(int a[], int n)
	{
		// Giả sử phần tử đầu tiên của mảng
		// là phần tử lớn nhất
		int giaTriLonNhat = a[0];

		// Đi từ phần tử kế tiếp đến cuối mảng
		// để kiểm tra xem điều giả sử có sai
		for(int i = 1; i < n; i++)

			// Nếu có phần tử nào lớn hơn phần tử đầu tiên
			if(a[i] > giaTriLonNhat)

				// Lập tức "đổi ngôi vị" giá trị lớn nhất
				giaTriLonNhat = a[i];

		return giaTriLonNhat;
	}

------------------------------------------------------------

[SẮP XẾP MẢNG]

Cho mảng: -5, 10, 100, -50, 100, 1001, 1

Sắp xếp tăng dần: con số nhỏ nhất phải nằm ở đầu mảng.

* Đổi chỗ: vị trí vùng RAM của hai biến sẽ vẫn như cũ, nhưng giá trị của hai biến sẽ được hoán đổi cho nhau. Lúc này, chỉ cần thêm sự hỗ trợ của duy nhất một vùng RAM (có cùng kiểu dữ liệu với hai biến cần được hoán đổi) để làm biến trung gian.
	-> Sử dụng biến trung gian để lưu lại giá trị của một trong hai biến trước khi hoán đổi.

	Ví dụ: sắp xếp tăng dần (số nhỏ xếp ở bên trái)

		// Hàm hoán đổi hai biến,
		// sử dụng hàm void vì có đến tận hai giá trị trả về

		// Sử dụng hai biến con trỏ cho hàm hoán đổi,
		// để nếu bên trong hàm có hoán đổi giá trị
		// thì nơi gọi hàm cũng sẽ được thay đổi theo
		void swap(int* a, int* b) {
			int t = *a;	// Biến t chỉ là biến trung gian
			*a = *b;
			*b = t;

			// Kịch bản:
			// 1. Trước khi bị gán đè, a đã kịp gửi giá trị của mình sang cho t.
			// 2. Ngay khi vừa gửi giá trị sang cho t, a đã bị b gán đè mất.
			// 3. Sau đó, giá trị của b đã bị t (hiện thân của a) gán đè trở lại.
		}


		// Hàm sắp xếp tăng dần
		int a[] = {5, -10, 15, -20, 25};

		// Lấy a[0] làm mốc, xem như là số nhỏ nhất,
		// sau đó đem đi so sánh từ a[1] đến cuối
		//	-> Sử dụng vòng lặp

		for (i = 0..gần-cuối)
			for (j = i + 1..cuối)

				// Nếu a[0] vốn trước đó được xem là nhỏ nhất,
				// nay lại có phần tử nào đó nhỏ hơn cả nó
				// thì lập tức xem phần tử mới xuất hiện đó
				// là phần tử nhỏ nhất
				nếu (a[0] > a[các-phần-tử-còn-lại])

					// Gọi hàm swap() để hoán đổi vị trí
					// mỗi khi có số nào đó < a[0]
					swap();


* Thuật toán "Nước lên, thuyền lên - Đối thủ xứng tầm" - Đổi chỗ trực tiếp (Interchange sort): nước (i), thuyền (j)
	// Duyệt từ đầu đến gần cuối mảng (vì phần tử cuối đã "nằm đúng vị trí")
	for (int i = 0; i < phần-tử-cuối-của-mảng - 1 (phần-tử-áp-chót); i++)

		// Lấy vị trí cần kiểm tra, đem đi so sánh với những phần tử phía sau
		// (phần "i + 1" để đảm bảo không cần phải tự kiểm tra với chính mình)
		for (int j = i + 1; j < phần-tử-cuối-của-mảng; j++)

			// Lúc này:
			//	a[i] - phần tử bên trái
			//	a[j] - phần tử bên phải
			// Hoán đổi nếu thấy dấu hiệu "bất thường" - nghịch thế
			if (a[i] > a[j])
				swap();

----------------------------------------

	=> Bản chất chỉ là so sánh và đổi chỗ nếu thấy không ổn.

------------------------------------------------------------

[THÊM & XOÁ PHẦN TỬ TRONG MẢNG]

* Công thức chung: Áp dụng chung cho cả thêm và xoá phần tử trong mảng.
	1. Liệt kê sự khác nhau của các phần tử giữa hai mảng.
	2. Xác định chiều chạy / duyệt phần tử (trái -> phải / phải -> trái).
	3. Tìm thuật toán.

Vì tính chất liên tiếp với nhau trong bộ nhớ, các phần tử trong mảng sẽ:

----------------------------------------

[THÊM PHẦN TỬ]

	1. Dịch chuyển về phía sau nếu muốn thêm phần tử.
		- Tính từ vị trí cần thêm, toàn bộ các phần tử phía sau sẽ đều bị lùi theo, còn các phần tử phía trước sẽ không bị ảnh hưởng.
		- Vì bản chất là gán đè các giá trị, nên phần tử cuối mảng sẽ phải là phần tử lùi về đầu tiên.
		-> Dồn các phần tử về bên phải - lùi về phía sau.

		* Thuật toán:
			1. Sử dụng vòng lặp để dịch chuyển các phần tử về phía sau (bắt đầu từ vị trí cần thêm trở về sau).
				- Phần tử cuối cùng của mảng (n - 1) sẽ là phần tử lùi về đầu tiên.
				- Lần lượt các phần tử tiếp theo cũng sẽ lùi về theo cho đến khi nào gặp vị trí cần thêm thì mới dừng.
				- Biến bước nhảy sẽ giảm dần vì ta đang lùi về.

			2. Kết thúc vòng lặp, gán giá trị vào vị trí cần thêm.
				- Vị trí cần thêm có thể:
					+ Ở đầu mảng (nằm đè lên phần tử ở vị trí thứ [0]).
					+ Ở cuối mảng (nằm hẳn phía cuối, nằm sau phần tử ở vị trí thứ [n - 1] -> vị trí cần thêm: [n]).

			3. Tăng kích thước thực tế của mảng lên.

		Ví dụ 1: Thêm một giá trị vào một vị trí nào đó (từ [0] -> [n]) trong mảng.

			// Vì có cập nhật lại số lượng phần tử thực tế,
			// nên biến số lượng phải được truyền tham chiếu
			void themMotPhanTuVaoMang(int a[], int *soLuongPhanTuThucTe, int viTriCanThem, int giaTriCanThem)
			{
				// Sử dụng vòng lặp để lùi phần tử,
				// bắt đầu từ cuối mảng đến đúng vị trí cần thêm
				for(int i = soLuongPhanTuThucTe - 1; i >= viTriCanThem; i--)
				
					// Lấy giá trị của phần tử tại ô phía trước
					// để gán cho ô phía sau,
					// vì phần tử phía sau phải chừa chỗ
					// thì phần tử phía trước mới có thể chèn vô được
					a[i + 1] = a[i];
		
				// Thoát khỏi vòng lặp - kết thúc việc dời chỗ,
				// bắt đầu đưa giá trị cần thêm vào vị trí cần thêm
				a[viTriCanThem] = giaTriCanThem;
	
				// Cập nhật lại số lượng phần tử thực tế
				// do đã có thêm phần tử
				soLuongPhanTuThucTe++;		
			}

		Ví dụ 2: Thêm một giá trị vào phía sau bất kì phần tử nào là số chẵn trong mảng.

			void themPhanTuVaoSauTatCaCacSoChan(int a[], int *soLuongPhanTuThucTe, int giaTriCanThem)
			{
				// Duyệt từ đầu đến cuối mảng
				for(int i = 0; i < soLuongPhanTuThucTe; i++)

					// Nếu bắt gặp phần tử nào là số chẵn
					// thì sẽ lập tức thêm vào phía sau (bên phải)
					// phần tử chẵn đó
					if (a[i] % 2 == 0)
					{
						// Tận dụng lại hàm thêm một phần tử,
						// nhưng lúc này, giá trị sắp được thêm vào mảng
						// sẽ nằm ở vị trí i + 1
						// vì ta đang thêm vào phía sau (bên phải)
						themMotPhanTuVaoMang(a, soLuongPhanTuThucTe, i + 1, giaTriCanThem);

						// Vì phần tử vừa thêm vào sẽ nằm ở phía sau (bên phải)
						// nên cần nhảy thêm một bước để né phần tử vừa thêm ra,
						// giúp tránh việc phần tử vừa được thêm cũng là số chẵn
						// và sẽ dẫn đến trường hợp cũng chỉ vì là số chẵn
						// mà giá trị lại tiếp tục được thêm vào phía sau chính mình
						i++;
					}
			}

----------------------------------------

[XOÁ PHẦN TỬ]

	2. Dịch chuyển về phía trước nếu muốn xoá phần tử.
		- Tính từ vị trí cần xoá, toàn bộ các phần tử phía sau sẽ đều bị dồn lên phía trước, còn các phần tử phía trước sẽ không bị ảnh hưởng.
		- Vì bản chất là gán đè các giá trị, nên phần tử (phía sau) gần nhất với phần tử cần xoá sẽ phải là phần tử dồn lên đầu tiên.
		-> Dồn các phần tử về bên trái - tiến lên phía trước.

		* Thuật toán:
			1. Sử dụng vòng lặp để dịch chuyển các phần tử lên phía trước (bắt đầu từ vị trí cần xoá trở về sau).
				- Phần tử nằm ngay phía sau phần tử cần xoá sẽ là phần tử đầu tiên tiến lên.
				- Lần lượt các phần tử tiếp theo cũng sẽ tiến lên theo cho đến khi nào hết mảng thì mới dừng.
				- Biến bước nhảy sẽ tăng dần vì ta đang tiến lên.
				- Vị trí cần xoá có thể:
					+ Ở đầu mảng (nằm đè lên phần tử ở vị trí thứ [0]).
					+ Ở cuối mảng (nằm đè lên phần tử ở vị trí thứ [n - 1]).

			2. Giảm kích thước thực tế của mảng xuống (phần tử "đã từng" là cuối cùng vẫn còn đấy, nhưng không được in ra, tạo nên cảm giác có một phần tử nào đó đã bị xoá).

		Ví dụ 1: Xoá một phần tử tại một vị trí nào đó (từ [0] -> [n - 1]) trong mảng.

			// Vì có cập nhật lại số lượng phần tử thực tế,
			// nên biến số lượng phải được truyền tham chiếu
			void xoaPhanTuTheoViTri(int a[], int *soLuongPhanTuThucTe, int viTriCanXoa)
			{
				// Sử dụng vòng lặp để dồn phần tử,
				// bắt đầu từ phần tử nằm kế vị trí cần xoá đến cuối mảng
				for(int i = viTriCanXoa + 1; i < soLuongPhanTuThucTe; i++)
		
					// Lấy giá trị của phần tử tại ô phía sau
					// để gán cho ô phía trước,
					// do mảng lúc này đang duyệt từ vị trí
					// của phần tử nằm phía sau vị trí cần xoá,
					// nên ta sẽ bắt đầu gán đè từ vị trí bắt đầu duyệt
					// lên vị trí cần xoá
					// và sau đó cứ tiếp tục gán đè đến cuối mảng
					a[i - 1] = a[i];
		
				// Thoát khỏi vòng lặp - kết thúc việc dồn chỗ,
				// phần tử cần xoá đã bị phần tử phía sau nó gán đè lên
	
				// Cập nhật lại số lượng phần tử thực tế
				// do đã có xoá phần tử
				soLuongPhanTuThucTe--;
			}

		Ví dụ 2: Xoá một hoặc nhiều phần tử theo một giá trị nào đó.

			void xoaPhanTuTheoGiaTri(int a[], int *soLuongPhanTuThucTe, int giaTriCanXoa)
			{
				// Duyệt từ đầu đến cuối mảng
				for(int i = 0; i < soLuongPhanTuThucTe; i++)

					// Khi tìm thấy vị trí có chứa giá trị cần xoá
					if(a[i] == giaTriCanXoa)
					{
						// Tận dụng lại hàm xoá theo vị trí
						// và vị trí cần xoá cũng chính là vị trí
						// tìm thấy giá trị
						xoaPhanTuTheoViTri(a, n, i);

						// Lùi về và kiểm tra tiếp phần tử vừa dồn lên
						// có phải là giá trị cần xoá hay không
						// để tránh việc các phần tử cần xoá nằm liên tiếp nhau
						i--;
					}
			}

----------------------------------------

	=> Bản chất chỉ là gán đè các phần tử.

------------------------------------------------------------

[TÁCH & GỘP MẢNG]

----------------------------------------

[TÁCH CÁC SỐ ÂM TRONG MẢNG RA MỘT MẢNG MỚI]

	Ví dụ: Tách các phần tử âm trong mảng gốc sang một mảng phụ.

		// Mảng phụ sẽ là mảng bị thay đổi,
		// vì vậy phải truyền tham chiếu
		void tachSoAmRaKhoiMang(int mangGoc[], int soLuongPhanTuCuaMangGoc,
					int mangPhu[], int *soLuongPhanTuCuaMangPhu)
		{
			// Ban đầu, trong mảng phụ
			// chưa có phần tử nào là số âm
			soLuongPhanTuCuaMangPhu = 0;

			// Duyệt từ đầu đến cuối mảng gốc
			// để tìm ra các số âm
			for(int i = 0; i < soLuongPhanTuCuaMangGoc; i++)

				// Nếu phát hiện
				// có một phần tử nào đó trong mảng gốc là số âm
				if(mangGoc[i] < 0)
				{
					// Đưa giá trị âm sang mảng phụ,
					// đồng thời tăng số lượng phần tử của mảng phụ lên 1
					mangPhu[soLuongPhanTuCuaMangPhu] = mangGoc[i];
					soLuongPhanTuCuaMangPhu++;
				}
		}

----------------------------------------

[GỘP CÁC PHẦN TỬ VÀO CUỐI MẢNG]

	Ví dụ: Gộp các phần tử của mảng phụ vào cuối của mảng gốc.

		// Mảng chính sẽ là mảng trực tiếp bị thay đổi,
		// vì vậy phải truyền tham chiếu
		void gopPhanTuVaoCuoiMang(int mangGoc[], int *soLuongPhanTuCuaMangGoc,
					  int mangPhu[], int soLuongPhanTuCuaMangPhu)
		{
			// Biến tạm để lưu lại số lượng phần tử
			// của mảng gốc trước khi gộp
			int soLuongPhanTuCuaMangGocTam = soLuongPhanTuCuaMangGoc;

			// Tăng số lượng phần tử của mảng gốc lên
			// (lấy số lượng phần tử của mảng phụ
			//	cộng dồn vào số lượng phần tử của mảng gốc)
			soLuongPhanTuCuaMangGoc = soLuongPhanTuCuaMangGoc + soLuongPhanTuCuaMangPhu;

			// Bắt đầu duyệt từ phần tử cuối cùng của mảng gốc (trước khi gộp)
			// đến phần tử cuối cùng của mảng gốc (sau khi đã gộp)
			for(int i = soLuongPhanTuCuaMangGocTam; i < soLuongPhanTuCuaMangGoc; i++)

				// Khi này, hai mảng đang cách nhau số lượng phần tử
				// đúng bằng số lượng phần tử của mảng gốc
				mangGoc[i] = mangPhu[i - soLuongPhanTuCuaMangGocTam];
		}

--------------------------------------------------------------------------------

[MẢNG TĨNH & MẢNG ĐỘNG - STATIC ARRAY & DYNAMIC ARRAY]

Có hai kiểu mảng trong ngôn ngữ C:

	1. Mảng tĩnh (Static Array).
		- Là con trỏ ngầm định, lưu địa chỉ và trỏ đến phần tử đầu tiên trong mảng.
		- Nhưng không được phép trỏ đi nơi khác - Tên mảng là con trỏ hằng.
		- Khi truyền vào hàm như tham số, được phép bỏ đi cặp dấu ngoặc vuông [] nếu muốn, vì dù sao vẫn là con trỏ.

	2. Mảng động (Dynamic Array).
		- Là con trỏ tường minh, lưu địa chỉ và trỏ đến vùng Byte đầu tiên trong một loạt cụm các Byte liên tiếp nhau trên RAM.
		- Nhưng được phép trỏ thoải mái sang những vùng nhớ khác nhau, vì đây là con trỏ "chính hãng".
		- Khi truyền vào hàm như tham số, được phép sử dụng cặp dấu ngoặc vuông [] dù khi khai báo không hề xuất hiện cặp dấu ngoặc vuông [] nào.

	-> Khi truyền vào hàm:

		- Thoải mái sử dụng *tênMảng hoặc đi kèm với cặp dấu ngoặc vuông [].

			Ví dụ: có thể linh hoạt trong việc sử dụng.
				*a ≈ a[0]
				a[i] ≈ *(a + i)

		- Truyền mảng vào hàm chính là truyền tham chiếu.

			Ví dụ: các cách truyền mảng vào hàm.
				vodi f(int *a);
				vodi f(int a[]);
				vodi f(int a[10]); // Có thể loại bỏ số lượng phần tử

------------------------------------------------------------

	[MẢNG TĨNH - STATIC ARRAY]

		// int col[5];
		// int col[5] = {1, 2};
		// int col[] = {5, 10, 15};

	  -------			│		│
	a |	|――――――――――――――――	│―――――――――――――――│
	  -------		│	│	0	│ a[4]
	  Con trỏ giả /		│	│―――――――――――――――│
	  Con trỏ hằng		│	│	0	│ a[3]
				│	│―――――――――――――――│
				│	│	0	│ a[2]
				│	│―――――――――――――――│
				│	│	0	│ a[1]
				│	│―――――――――――――――│
	a[0] = 68;		│	│	68	│ a[0]
				―――――――>│―――――――――――――――│	6.000.000
					│		│

Mảng tĩnh là mảng được khai báo bên trong hàm, được cấp phát theo một thuật toán riêng là LIFO và được chứa trong vùng nhớ Stack (Stack Segment) trên RAM vì được khai báo trong hàm.

	- Số lượng phần tử tối đa của mảng cố định trong suốt quá trình chương trình đang được thực thi.

	- Cần phải dự trù trước số lượng phần tử tối đa có thể sử dụng, sau đó mới khai báo số lượng phần tử thực tế cần sử dụng.
		+ Nếu dự trù quá nhiều sẽ gây lãng phí khi sử dụng không hết.
		+ Nếu dự trù quá ít sẽ khiến mảng không còn khả năng mở rộng.

	- Nhưng sẽ dễ dàng trong việc thêm hoặc xoá phần tử, miễn không vượt quá số lượng phần tử tối đa của mảng.

	Ví dụ:
		// Cách 1: báo kích thước trước, gán giá trị sau
		float col[100];
		col[0] = 1;
		col[1] = 2;

		// Cách 2: vừa khai báo kích thước, vừa gán giá trị
		float col[3] = {1, 2};

		// Cách 3: không cần khai báo kích thước, chỉ cần gán giá trị
		float col[] = {1, 2, 3, 4};

			=> Toàn bộ biến đều nằm trong Stack.

------------------------------------------------------------

	[MẢNG ĐỘNG - DYNAMIC ARRAY]

		// int* p = (int*)malloc(5 * sizeof(int));
		// int* p = (int*)calloc(5, sizeof(int));

	  ―――――――			│		│
	a │	│――――――――――――――――	│―――――――――――――――│
	  ―――――――		│	│	0	│ a[4]
	  Con trỏ thật		│	│―――――――――――――――│
				│	│	0	│ a[3]
				│	│―――――――――――――――│
				│	│	0	│ a[2]
				│	│―――――――――――――――│
	*(a + 1) = 69;		│	│	69	│ a[1]
				│	│―――――――――――――――│
	a[0] = 68;		│	│	68	│ a[0]
				―――――――>│―――――――――――――――│	6.000.000
					│		│

Khai báo kiểu con trỏ nhưng lại sử dụng ngoặc vuông [] và được chứa "trôi nổi" ở đâu đó trong vùng nhớ Heap (Heap Segment) trên RAM.

	- Số lượng phần tử của mảng có thể thay đổi trong suốt quá trình chương trình đang được thực thi.

	- Không cần phải dự trù số lượng phần tử tối đa có thể sử dụng, chỉ việc khai báo số lượng thực tế là sẽ được cấp một vùng nhớ có kích thước đúng bằng với nhu cầu sử dụng.

	- Sẽ khó khăn hơn trong việc thêm hoặc xoá phần tử vì số lượng phần tử chỉ vừa đủ để sử dụng, ta phải tạo thêm hoặc xoá bớt ô nhớ trong vùng nhớ (không phải tạo mới vùng nhớ).

	Ví dụ:
		// Cách 1: nhớ số Byte của kiểu dữ liệu và tính toán số Byte cần cấp phát
		int* p = (int*)malloc(20);

		// Cách 2: chỉ cần nhớ số Byte của kiểu dữ liệu, không cần tính toán
		int* p = (int*)malloc(5 * 4);

		// Cách 3: không muốn nhớ hay tính toán gì
		int* p = (int*)malloc(5 * sizeof(int));

			=> Chỉ vùng được tạo bằng malloc() mới được nằm trong Heap, vùng con trỏ vẫn sẽ nằm trong Stack.

==========================================================================================

[CON TRỎ - POINTER]

Sử dụng biến để lưu những giá trị thông thường (int, long, float, double, char...) trong RAM.
	-> "Cách lưu địa chỉ của một biến khác trong RAM?"

Muốn lưu được địa chỉ bộ nhớ (địa chỉ vùng RAM) của một biến nào đó khác để có thể tham chiếu đến trong tương lai, ta cần phải có một loại biến đặc biệt để tránh nhầm lẫn với loại biến thông thường sử dụng để lưu giá trị chữ, số...

	- Đây là một biến lưu địa chỉ vùng RAM (Byte đầu tiên) - miền giá trị, gián tiếp trỏ đến giá trị của một biến khác thay vì trực tiếp lưu một giá trị thông thường.
		* Miền giá trị của biến con trỏ: địa chỉ ô nhớ của biến mà con trỏ đang trỏ đến (dãy 8 chữ số hệ 16).

	- Khi đi đến địa chỉ được ghi trong biến, ta sẽ nhận được giá trị thực sự. Mọi chỉnh sửa do biến tham chiếu đến thực hiện đều sẽ ảnh hưởng đến giá trị của biến gốc.
		* Biến tham chiếu: tên phụ/tên thứ hai/tên giả/biệt danh (alias) để gọi cho một biến (tên khác của biến gốc).

	-> Con trỏ là một biến với vùng RAM chứa giá trị đặc biệt, lưu địa chỉ của một biến khác (miền giá trị), mà khi đến đúng địa chỉ (được ghi trong vùng RAM của biến đặc biệt đó) thì ta mới thật sự nhận được giá trị.
		(Khi tìm đến địa chỉ ghi trong giá trị đặc biệt này, ta sẽ nhận được giá trị thật sự của nó.)

=> Biến con trỏ là quyển danh bạ, lưu địa chỉ và phải đến đúng địa chỉ đó thì mới lấy được giá trị.
	(Đứng núi này trông núi nọ - đứng con trỏ này trông giá trị nọ
				   - đứng ở nơi này nhưng tác động đến dữ liệu của nơi khác.)

	* Cú pháp:
		// 1. Để khai báo biến con trỏ, ta sử dụng kiểu-dữ-liệu* 
		//    và truyền vào địa chỉ của biến thông thường bằng kí tự '&'

			<kiểu-dữ-liệu>* <tênBiếnĐịaChỉ> = &<tênBiếnThôngThường>
			     	 int*	  conTrỏ	= &địaChỉVùngRAM
			     	char*	  conTrỏ	= &vịTríVùngRAM
			       float*	  conTrỏ	= &toạĐộVùngRAM
			     danh-bạ*     tênNgườiQuen  = &sốĐiệnThoạiNgườiQuen

		// 2. Để truy xuất được giá trị của nơi mà biến con trỏ đang trỏ đến,
		//    ta sử dụng *tênBiếnConTrỏ

			*<tênBiếnĐịaChỉ> = <một-biểu-thức-tính-toán-nào-đó>
			     *thuan      =      *thuan + 1000

		// 3. Để xem địa chỉ của nơi mà biến con trỏ đang trỏ đến,
		//    ta chỉ đơn giản là sử dụng tênBiếnConTrỏ kết hợp với %u

			%u kết hợp với <tênBiếnĐịaChỉ>
			printf("Address = %u\n", thuan);

		Ví dụ:
			int address = 6000010;
			// Đây được hiểu là một số nguyên với giá trị là 6.000.010,
			// chỉ là một giá trị bình thường và được sử dụng để tính toán,
			// chứ không phải là địa chỉ của một vùng RAM nào đó

			// Câu hỏi: làm sao để biết đấy là địa chỉ vùng RAM của một biến nào đó khác
			//	    chứ không phải chỉ là một con số nguyên thông thường?

			// Một loại biến mới lạ, không lưu những giá trị bình thường
			// có thể trực tiếp sử dụng được ngay (int, float, char...),
			// mà đóng vai trò như một quyển danh bạ
			// để lưu toạ độ của nơi thật sự chứa giá trị
			int* pointer = &address;

			// Có thể tưởng tượng giống như việc dịch chuyển tức thời:
			//	int*	: tạo ra cổng/khoan dịch chuyển
			//	pointer	: tên/kí hiệu/mã số riêng của cổng/khoan dịch chuyển
			//	&address: truyền vị trí của địa điểm cần đến

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Con trỏ là một biến để lưu địa chỉ của một biến khác	│
│	và sau đó tham chiếu đến để lấy được giá trị thực sự	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Con trỏ = Tham chiếu = Đứng từ đây mà tương tác với nơi khác	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CHI TIẾT VỀ CON TRỎ]

	* Point (động từ): chỉ.
	* Pointer (danh từ): chỉ một điểm ở xa.

Trong máy tính, dung lượng RAM nếu đổi ra Byte sẽ rất nhiều (8GB ≈ 8.000.000.000 Byte). Với không gian rộng lớn như vậy, ta phải có cách để quản lý và tương tác với vùng RAM mong muốn.
	-> Con trỏ là kỹ thuật giúp nhảy đến một vùng RAM bất kì khi đã biết được toạ độ.

Biến con trỏ là biến lưu toạ độ (địa chỉ vùng RAM) của biến khác - nơi mới thật sự chứa giá trị. Một khi đã lần theo địa chỉ và lấy được giá trị của vùng RAM, ta có quyền sửa giá trị bên trong vùng RAM đó. Vì vậy, sử dụng biến con trỏ là để can thiệp vào giá trị của một biến khác thông qua địa chỉ.
	-> Biến sẽ trỏ đến biến khác và can thiệp dữ liệu.
		(Hai biến cùng trỏ vào một vùng giá trị.)

Biến con trỏ vẫn là một biến và vẫn có địa chỉ riêng. Nhưng địa chỉ của con trỏ ít được quan tâm cho đến khi sử dụng mảng của con trỏ. Vì vậy, ở thời điểm hiện tại, ta chỉ quan tâm con trỏ đang chứa địa chỉ của biến nào khác.

Biến thông thường thì sẽ có khác nhau về kích thước tuỳ theo kiểu dữ liệu của biến (int, long, float, double, char...), nhưng biến địa chỉ thì luôn chiếm một vùng RAM cố định tuỳ theo trình biên dịch và kiến trúc của hệ điều hành. Nếu sử dụng Windows 32 bit thì biến con trỏ chỉ chiếm 4 Byte (4 * 8 bit), nếu sử dụng Windows 64 bit thì biến con trỏ sẽ chiếm 8 Byte (8 * 8 bit).

Mỗi biến thông thường sẽ có một kiểu dữ liệu và một biến địa chỉ riêng đi kèm. Vì vậy, để lưu được trọn vẹn địa chỉ của biến thông thường bằng một biến con trỏ, thì tốt nhất ta phải khai báo cả hai cùng một kiểu dữ liệu.

	- Việc gán sẽ được thực hiện thông qua toán tử gán '=' và chỉ gán được khi dữ liệu của đôi bên là tương ứng (một bên chấp nhận đón nhận địa chỉ và một bên chấp nhận cho đi địa chỉ).
		+ Biến thông thường sẽ phải sử dụng toán tử '&' vì con trỏ chỉ nhận địa chỉ.
		+ Hai con trỏ với nhau thì chỉ cần sử dụng tên biến con trỏ là đủ để đến gán.

	- Việc gán cũng sẽ hình thành một mối liên kết giữa đôi bên, khi một bên có sự thay đổi thì bên còn lại cũng sẽ bị ảnh hưởng theo.

	-> Để lưu trọn vẹn địa chỉ của biến nào đó bằng một biến con trỏ thì sử dụng kiểu dữ liệu tương ứng.
		(Địa chỉ của con trỏ thực chất là địa chỉ của biến mà nó đang trỏ đến.)

	Ví dụ:
		// Biến thông thường là biến số nguyên
		int biếnThôngThường = giá-trị;		// 4 Byte

		// Biến địa chỉ có cùng kiểu dữ liệu là số nguyên
		// với biến thông thường
		int* biếnĐịaChỉ = &biếnThôngThường;	// 8 Byte

Vì con trỏ vẫn là một biến, nên nó có quyền tham gia vào các phép toán. Sau khi khai báo biến con trỏ, ta có thể sử dụng tên của con trỏ (theo cú pháp *tênBiếnConTrỏ) để tương tác với giá trị mà không cần sử dụng đến tên biến thông thường.
	-> Thông qua con trỏ, một biến thông thường lúc này sẽ có hai tên.

	Ví dụ:
		int biếnThôngThường = 5000;
		int* biếnĐịaChỉ = &biếnThôngThường;

		// Sử dụng bằng tên biến thông thường để tính toán
		biếnThôngThường = biếnThôngThường - 1000;

		// Sử dụng bằng tên biến con trỏ để tính toán
		*biếnĐịaChỉ = *biếnĐịaChỉ - 1000;

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Khi nói về tênBiếnThôngThường chính là nói về giá trị			│
│	Khi nói về &biếnThôngThường chính là nói về địa chỉ vùng RAM		│
│	Khi nói về *biếnĐịaChỉ chính là nói về giá trị trong địa chỉ vùng RAM	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

* Tham khảo thêm: https://youtu.be/jsW8WcjE1o8 (Techmaster | Con trỏ, giá trị và địa chỉ)

------------------------------------------------------------

[TÓM TẮT CÚ PHÁP ĐỂ LÀM VIỆC VỚI CON TRỎ]

Đối với biến thông thường, khi đã có được giá trị là ta có thể trực tiếp sử dụng. Nhưng đối với biến con trỏ thì lại chưa sử dụng được ngay, vì nó chỉ đang là toạ độ của biến khác. Vì vậy, muốn sử dụng thì bắt buộc phải đi đến nơi được mô tả trong địa chỉ.

* Toán tử dấu hoa thị '*' (Dereference Operator / Indirection Operator): toán tử 1 ngôi, thường được sử dụng với con trỏ.
	- Khi khai báo: một con trỏ sẵn sàng lưu địa chỉ của một biến khác.
	- Khi đã tham chiếu: lần theo địa chỉ và để lấy được giá trị thật sự.
		+ Dereferencing là việc sử dụng biến con trỏ để lấy ra hoặc thay đổi giá trị mà con trỏ đó trỏ đến.

* Cú pháp để làm việc với con trỏ:

	- Để lưu địa chỉ	:	kiểu-dữ-liệu*		(ví dụ: int*)
	- Để lấy địa chỉ	:	&tênBiếnThôngThường	(ví dụ: &yearOfBirth)
	- Để đi đến địa chỉ	:	*tênBiếnConTrỏ		(ví dụ: *address)

		Ví dụ: cho hai biến, biến thông thường "biếnThôngThường" và biến địa chỉ "biếnĐịaChỉ" đều có cùng một kiểu dữ liệu là số nguyên (int)

			// Lấy địa chỉ của biến thông thường
			// và lưu vào con trỏ biếnĐịaChỉ
			int* biếnĐịaChỉ = &biếnThôngThường;

			// 1a. Tương tác với giá trị của riêng biếnThôngThường
			printf("%d\n", biếnThôngThường);

			// 1b. Tương tác với giá trị của biếnThôngThường
			//     thông qua con trỏ biếnĐịaChỉ
			printf("%d\n", *biếnĐịaChỉ);

			// 2a. Xem địa chỉ của riêng biếnThôngThường
			printf("%u\n", &biếnThôngThường);

			// 2b. Xem địa chỉ của biếnThôngThường
			//     thông qua con trỏ biếnĐịaChỉ
			printf("%u\n", biếnĐịaChỉ);

			// 2c. Xem địa chỉ của riêng con trỏ biếnĐịaChỉ
			printf("%u\n", &biếnĐịaChỉ);

			// Kết luận:
			//	[Để lấy giá trị] biếnThôngThường = *biếnĐịaChỉ (cho ra cùng một giá trị)
			//	[Để lấy địa chỉ] &biếnThôngThường = biếnĐịaChỉ (cho ra cùng một địa chỉ)

--------------------

* Lưu ý: Cú pháp *biếnĐịaChỉ để lần theo địa chỉ và đi đến nơi chứa giá trị của biếnThôngThường cũng giống như dấu chấm trong lập trình hướng đối tượng.

	Ví dụ: So sánh cách sử dụng giữ lập trình hướng thủ tục (POP) và lập trình hướng đối tượng (OOP).
		// Lập trình hướng thủ tục (POP)
		*biếnĐịaChỉ = 10;

		// Lập trình hướng đối tượng (OOP)
		biếnĐịaChỉ.thuộcTính = 10;

----------------------------------------

Khi mới khai báo biến con trỏ - chỉ mới có địa chỉ, chưa hề có vùng nhớ để lưu giá trị. Vì vậy, để con trỏ có thể phát huy được tác dụng:

	1. "Sương gió phủ đời trai" - Phải được "nương tựa" vào một vùng nhớ có sẵn của một biến khác.

	2. "Có làm thì mới có ăn" - Chủ động cấp phát một vùng nhớ riêng cho con trỏ.

	-> Phải cấp phát vùng nhớ cho con trỏ trước khi sử dụng.

	Ví dụ 1: Nương tựa vào một biến khác.
		int a;
		int* b;

		// SAI - vì con trỏ chưa nó nơi nương tựa
		*b = 69;

		// ĐÚNG - vì lúc này con trỏ đã có nơi nương tựa
		b = &a;
		*b = 69;

	Ví dụ 2: Tự làm, tự ăn.
		int* a;
		a = (int *)malloc(20);
		*a = 69;

* Lưu ý: đối với cách 1 - sống nhờ, cả vùng nhớ gốc và con trỏ đang trỏ đến vùng nhớ ấy đều nằm trong Stack.

	- Điều này có nghĩa là vùng nhớ đang được hệ điều hành quản lý, chứ không phải là vùng nhớ do người dùng tự quản lý (vùng Heap). Vì vậy, ta không được phép sử dụng cơ chế chủ động giải phóng vùng nhớ giống như cách 2 - tự thân.

	Ví dụ: cố tình giải phóng vùng nhớ cho con trỏ.

		int a = 10;
		int *b = &a;

		free(a);

------------------------------------------------------------

[DỜI VÙNG RAM MÀ CON TRỎ ĐANG LƯU TRỮ]

Khi có hai biến ở sát nhau, nếu sử dụng phép tăng/giảm tự thân (++ và --) lên biến con trỏ, tuỳ vào kiểu dữ liệu đã khai báo trước đó, mỗi lần di chuyển sẽ di chuyển nhiều Byte cùng một lúc (di chuyển đến vùng RAM chứa biến kế tiếp) chứ không phải chỉ di chuyển cố định 1 Byte địa chỉ.
	-> Dời toạ độ đến vùng RAM kế tiếp tuỳ theo kiểu dữ liệu (nhảy sang biến khác).

	Ví dụ:
		int biếnA = 5000;
		int biếnB = 4000;
		int* biếnConTrỏ;

		// Ghi rõ trỏ đến biến a
		biếnConTrỏ = &biếnA;

		// Không ghi rõ sẽ trỏ đến biến b,
		// nhưng chắc chắn sẽ trỏ đến vùng RAM kế tiếp
		// mà ở trong ví dụ này là vùng RAM của biến b
		biếnConTrỏ++;

--------------------

* Lưu ý: toán tử tăng/giảm tự thân (++ và --) sẽ có độ ưu tiên cao hơn toán tử *. Vì vậy, nếu chỉ muốn tăng/giảm giá trị của biến thay vì thay đổi (nhảy) địa chỉ thì ta phải sử dụng thêm dấu ngoặc tròn để thay đổi độ ưu tiên.

	Ví dụ:
		int a = 10;
		int* b = &a;

		// Nếu chỉ muốn tăng giá trị của biến b
		*b++;	// SAI - vì toán tử tăng/giảm tự thân có độ ưu tiên cao hơn,
			//	 nên sẽ nhảy sang địa chỉ kế tiếp trước,
			//	 rồi sau đó mới tăng giá trị lên

		(*b)++; // ĐÚNG - vì sẽ đi đến địa chỉ chứa giá trị trước,
			//	  rồi sau đó mới tăng giá trị lên

----------------------------------------

Địa chỉ vùng RAM cũng chỉ là một con số được On/Off trong RAM, nên nó vẫn có thể được lưu nào biến như bình thường.

	- Mặc dù biến con trỏ chỉ lưu toạ độ địa chỉ, nhưng khi sử dụng địa chỉ (khi lấy giá trị) thì nó sẽ dựa vào kiểu dữ liệu của nó (tuỳ loại con trỏ) và của biến mà nó trỏ đến để lấy chính xác dữ liệu.

	- Ngoài việc khai báo một biếnĐịaChỉ có cùng kiểu dữ liệu với biếnThôngThường, ta vẫn có thể khai báo khác kiểu dữ liệu. Nếu biếnĐịaChỉ có kiểu dữ liệu khác với kiểu dữ liệu của biếnThôngThường, biếnĐịaChỉ sẽ sử dụng một số Byte nhiều hơn hoặc ít hơn cần thiết để lấy và hiển thị dữ liệu.

		-> Với mỗi loại con trỏ khác nhau, nó sẽ tìm cách lấy giá trị của biến mà nó đang trỏ đến theo kiểu dữ liệu.

	Ví dụ: Hack RAM
		// Biến gift lưu giá trị thập phân 16164,
		// khi đổi sang nhị phân sẽ là 0000 0000    0000 0000    0011 1111    0010 0100
		/*
			Trong bảng mã ASCII:
				- Kí tự '?'
					+ Theo kiểu thập phân: 63
					+ Theo kiểu nhị phân: 0011 1111
				
				- Kí tự '$'
					+ Theo kiểu thập phân: 36
					+ Theo kiểu nhị phân: 0010 0100

			Như vậy, ta sẽ có từng cụm 4 Byte nhị phân của con số 16164 như sau:
				0000 0000    0000 0000    0011 1111    0010 0100
				    0		 0	     63		  36
		*/
		int gift = 16164;

		// Biến con trỏ hack có kiểu dữ liệu là kí tự (char)
		// trong khi biến gift lại có kiểu dữ liệu là số nguyên (int)
		char* hack = &gift; // char* hack = (char*)&gift;

		// Hỏi xem hack đang trỏ đến giá trị cụ thể nào
		printf("Gift (Hack) = %c\n", *hack); // '$' = 0010 0100 = 36
	
		// Xem địa chỉ hiện tại của hack
		printf("'%c' address = %u\n", *hack, hack); // '$' address = 6684172
	
		// Di chuyển vùng RAM kế tiếp
		// (Chỉ có thể di chuyển 1 Byte
		// vì kiểu dữ liệu char chiếm 1 Byte)
		hack++;
	
		// Hỏi xem hack đang trỏ đến giá trị cụ thể nào
		printf("Finally, gift (Hack) = %c\n", *hack); // '?' = 0011 1111 = 63
	
		// Xem địa chỉ hiện tại của hack
		printf("'%c' address = %u\n", *hack, hack); // '?' address = 6684173

		// Kết luận: vì có kiểu dữ liệu là char (1 Byte)
		//	     nên con trỏ hack mỗi lần lấy giá trị
		//	     thì chỉ có thể lấy tối đa được đúng 1 Byte,
		//	     mặc dù biến gift có kiểu dữ liệu là int (4 Byte)

--------------------------------------------------------------------------------

[HOÁ TRANG / ÉP KIỂU DỮ LIỆU - TYPE CASTING / TYPE-CONVERSION]

Ép kiểu dữ liệu là việc chuyển đổi một kiểu dữ liệu này thành một kiểu dữ liệu khác (mặc một bộ trang phục để đóng giả làm một người khác).

Cũng giống như việc làm bánh, mặc kệ cho bột bánh ở hình dạng và trạng thái nào, sau khi đổ bánh vào khuôn và nướng lên thì sẽ cho ra hình dạng mong muốn.

* Cú pháp: (kiểu-dữ-liệu) <biểu-thức / tênBiến>

	Ví dụ:
		// Khi báo một biến pi kiểu double
		double pi = 3.14;

		// Khai báo biến trung gian để ép kiểu của biến pi thành int
		int casting = (int)pi;

		// In ra giá trị của biến pi sau khi đã ép kiểu
		printf("Pi = %d\n", casting);

		// Kết quả in ra sẽ là 3 vì đây là số nguyên
		// và phần thập phân phía sau của số pi sẽ bị mất

------------------------------------------------------------

	[BIẾN ĐỊA CHỈ VÙNG RAM THÀNH GIÁ TRỊ THÔNG THƯỜNG]

Địa chỉ của biến là một con số, mang trong mình hai ý nghĩa: con số thông thường, toạ độ vùng RAM. Tất nhiên, con số thì chưa chắc đã là địa chỉ của biến.

// "Nhưng nếu có một con số và muốn nói rằng nó là toạ độ của một biến khác?"

Theo quan điểm thông thường, để lấy được địa chỉ thì phải sử dụng &tênBiến. Nhưng bây giờ, nếu không sử dụng &tênBiến để lấy địa chỉ (có thể vì tênBiến đang nằm ở một ứng dụng độc lập khác), mà bằng một cách nào đó, chẳng hạn như quét vùng RAM, để có được trong tay một con số và muốn nói rằng nó là địa chỉ?

Để nói rằng một con số nào đó thật sự là địa chỉ của một biến, ta cũng ép kiểu dữ liệu (casting), nhưng lúc này sẽ ép về kiểu dữ liệu kiểu con trỏ.

	Ví dụ:
		int yob = 2000;
		int* thuan;

		// Biến yob có địa chỉ: 6684180
		printf("The address of yob: %u\n", &yob);

		// Truyền địa chỉ kiểu số nguyên (int) vào biến con trỏ

		// * Ép kiểu dữ liệu để thông báo rằng con số nguyên này
		//   thực chất là một địa chỉ để cất vào biến con trỏ int*
		thuan = (int*)6684180;

		// In ra giá trị của biến con trỏ
		// để xem địa chỉ có thật sự được cất vào biến chưa
		printf("The value of yob (via thuan) now is: %d\n", *thuan); // 2000
	
		// Sửa giá trị của biến
		*thuan = 2022;
		printf("Finally, the value of yob now is: %d\n", yob); // 2022

----------------------------------------

* Con trỏ vô kiểu / Con trỏ void (Void Pointer): là một con trỏ không có kiểu dữ liệu nhất định.

	- Con trỏ thông thường chỉ có thể trỏ đến những biến có cùng kiểu dữ liệu (int* -> int, double* -> double...), nhưng riêng con trỏ void lại có thể lưu được địa chỉ của bất kì kiểu dữ liệu nào (int, double, char...).

		Ví dụ: Con trỏ void có thể lưu địa chỉ của bất kì kiểu dữ liệu nào.
			int a = 10;
			char b = 'x';
		
			// Con trỏ void có thể lưu địa chỉ
			// của biến số nguyên 'a'
			void *p = &a;
		
			// Con trỏ void có thể lưu địa chỉ
			// của biến kí tự 'b'
			p = &b;

	- Có thể được ép kiểu thành bất kì kiểu dữ liệu nào.

		Ví dụ: Ép kiểu dữ liệu cho con trỏ.
			int a = 10;
			void *p = &a;
			printf("%d", *(int *)p);

	- Thường được sử dụng trong cấp phát động bằng (malloc(), calloc()...) để cấp phát một vùng nhớ thuộc bất kì kiểu dữ liệu nào. Trước khi sử dụng vùng nhớ này, chỉ cần ép kiểu lại cho vùng nhớ sao cho giống với kiểu dữ liệu của con trỏ là được.

	- Không được phép trực tiếp truy cập hoặc thay đổi giá trị (Dereference) mà biến con trỏ đang trỏ đến. Muốn trực tiếp sử dụng thì phải ép kiểu dữ liệu của con trỏ về một kiểu dữ liệu nào đó.

		Ví dụ: Không được phép sử dụng giá trị của con trỏ void.
			int a = 10;
			void *ptr = &a;

			// Thông báo lỗi
			// Compiler Error: 'void*' is not a pointer-to-object type
			printf("%d", *ptr);

			// Trả về kết quả là 10
			printf("%d", *(int *)ptr);

	- C tiêu chuẩn không cho phép sử dụng các phép tính số học với con trỏ void, nhưng Trình biên dịch C của GNU (GNU C Compiler - GCC) thì có.

		Ví dụ: Truy xuất đến phần tử kế tiếp trong mảng.
			int a[2] = {1, 2};
			void *ptr = &a;
			ptr = ptr + sizeof(int);
			printf("%d", *(int *)ptr);

	-> Con trỏ "ba phải" có thể trỏ đến bất kì kiểu dữ liệu nào, miễn có ép lại kiểu dữ liệu sau khi nhận.

--------------------------------------------------------------------------------

[CÁC DẠNG CON TRỎ]

------------------------------------------------------------

1. Con trỏ tường minh (Explicit): là một con trỏ tự do và có thể thoải mái sử dụng trong các phép tính toán (cộng, trừ...) và phép tăng/giảm tự thân (++ và --) để thay đổi vị trí toạ độ của địa chỉ trong RAM.
	-> Con trỏ thật, có thể linh hoạt trỏ sang vùng khác.

		Ví dụ:
			// Khai báo con trỏ thường
			int address = 6000010;
			int* pointer = &address;

			// Khai báo mảng động
			int* a = (int*)malloc(5 * sizeof(int));
			int* a = (int*)calloc(5, sizeof(int));

------------------------------------------------------------

2. Con trỏ không tường minh / ngầm định (Implicit) - Con trỏ hằng (Constant pointer):
	- Mảng là một dạng con trỏ hằng, tên con trỏ phụ thuộc vào tên mảng.
	- Dù vẫn là con trỏ nhưng lại không được tự do, vì nó còn phải quản lý nhiều biến/phần tử khác.
	- Nhiệm vụ của con trỏ là luôn phải trỏ vào phần tử đầu tiên a[0] trong mảng, nên không được phép sử dụng phép tăng/giảm tự thân (++ và --), nhưng vẫn được quyền tham gia vào các phép toán (cộng, trừ...) để thay đổi vị trí toạ độ của địa chỉ trong RAM.

	-> Con trỏ giả, bị cấm trỏ đi sang vùng khác.

		Ví dụ:
			// Khai báo mảng tĩnh
			int a[5];
			int a[5] = {1, 2};
			int a[] = {5, 10, 15, 20};

--------------------------------------------------------------------------------

[TÍNH ỨNG DỤNG THỰC TẾ CỦA CON TRỎ]

Ứng dụng của con trỏ là để lưu giá trị xử lý ở trong hàm và đẩy ra bên ngoài mà không cần phải thông qua return. Vì hàm sau khi xử lý xong chỉ có thể trả về một giá trị duy nhất tương ứng và trùng với kiểu dữ liệu của hàm, nên nếu muốn trả về nhiều dữ liệu hơn thì việc sử dụng con trỏ là một trong nhiều cách.

Ngoài ra, khái niệm con trỏ còn được được ứng dụng trong công cụ Cheat Engine, sử dụng để gian lận trong các trò chơi. Khi những thông số trong trò chơi là những biến và được lưu trong RAM với kiểu dữ liệu double. Công cụ Cheat Engine sẽ đóng vai trò như một con trỏ và quét vùng RAM của trò chơi để lấy ra được toạ độ của thông số trong trò chơi cần chỉnh sửa. Sau đó khai báo một biến con trỏ để lưu toạ độ đó và chỉnh sửa giá trị mới bằng *biếnConTrỏ.
	-> Con trỏ giúp tham chiếu đến một vùng RAM ở xa để sử dụng và chỉnh sửa giá trị nếu muốn.
		(Quét vùng RAM để lấy toạ độ, gán toạ độ vào biến địa chỉ bằng kỹ thuật ép kiểu dữ liệu.)

Tuy nhiên, trong thực tế, Windows sẽ cấm hai ứng dụng khác nhau có thể xâm phạm vào vùng RAM của nhau, giúp bảo vệ các ứng dụng. Nhưng Windows lại có cơ chế cho phép khai thác phần lõi, can thiệp vào các kernel bên trong của hệ điều hành bằng cách cung cấp một loạt các hàm API (những hàm đặc biệt được làm sẵn). Vì vậy, ta vẫn có thể can thiệp vào vùng RAM của một ứng dụng khác nếu như ta biết cách sử dụng.

------------------------------------------------------------

[TRUYỀN THAM CHIẾU]

Trong khi truyền tham trị, giá trị truyền vào hàm sẽ là một bản sao, mỗi chỉnh sửa trong bản sao sẽ không làm ảnh hưởng đến bản gốc.

Nhưng trong truyền tham trị, ta không đưa giá trị thông thường vào, mà lại đưa toạ độ địa chỉ vào hàm (và hàm cũng không nhận giá trị thông thường). Sau khi hàm nhận được địa chỉ, nó đi đến địa chỉ để lấy giá trị và xử lý, rồi mới trả ngược lại kết quả cho nơi gọi hàm.
	-> Đưa địa chỉ vào cho hàm để hàm xử lý và làm thay đổi giá trị ở nơi gọi hàm.

Ngoài ra, con trỏ còn có thêm tác đụng khi nhiều nơi cùng nắm một con trỏ chung, nếu một nơi sửa giá trị ở con trỏ chung đấy, thì mọi nơi giữ giá trị đấy đều sẽ đồng loạt được cập nhật.

--------------------------------------------------------------------------------

Trong lập trình hướng đối tượng, dấu chấm là tham chiếu, hay cũng chính là con trỏ.

--------------------------------------------------------------------------------

Cũng giống như địa chỉ IP (Internet Protocol), được sử dụng để kết nối giữa những máy tính với nhau và mỗi máy sẽ có một địa chỉ riêng để phân biệt, khởi đầu sẽ là 32 bit (4 Byte).

Trong lập trình, các Byte thường đi được chia thành từng cụm 8 Byte.

==========================================================================================

[MẢNG & CON TRỎ - THAM CHIẾU]

Mảng (mảng tĩnh & mảng động), con trỏ và truyền tham chiếu cũng là đầu vào của hàm, tất cả đều có quan hệ với nhau.

	- Khi một hàm nhận tham số đầu vào là mảng, vì tên mảng cũng được xem là một biến và đây còn là biến tham chiếu, nên khi đưa tên mảng vào hàm sẽ được xem là con trỏ.
		+ Không cần khai báo kích thước (tối đa) của mảng khi thiết kế tham số đầu vào.
		+ Không cần sử dụng cặp dấu ngoặc vuông "[]" khi truyền mảng làm đối số vào hàm.

	- Vì là con trỏ - truyền tham chiếu, nên mọi thay đổi của mảng trong hàm đều sẽ được cập nhật lại cho nơi gọi hàm.

	-> Khi mảng được truyền vào hàm thì đây là truyền tham chiếu.

--------------------------------------------------------------------------------

* Các ký pháp khi sử dụng mảng & con trỏ:

	1. Ký pháp chỉ số: a[i];

	2. Ký pháp độ dời: *(a + i);

--------------------------------------------------------------------------------

* Có ba cách để sử dụng con trỏ.

Giả sử có một con trỏ 'p' kiểu số nguyên (int).

	// Một biến con trỏ
	// cần được truyền vào toạ độ/địa chỉ/vị trí vùng RAM
	int* p;

------------------------------------------------------------

	1. Trỏ đến một toạ độ của biến lẻ:

		// Ba biến lẻ, không nằm liên tiếp nhau trong RAM
		int tt = 5000;		-> p = &tt;	// 6.000.000
		int td = 4000;		-> p = &td;	// 6.000.050
		int yob = 2000;		-> p = &yob;	// 6.000.100

			// Để lấy giá trị của biến con trỏ
			*p = tt = 5000;
			*p = td = 4000;
			*p = yob = 2000;

------------------------------------------------------------

	2. Trỏ đến một toạ độ của phần tử đầu tiên trong mảng:

		// Cho một mảng gồm 5 phần tử được xếp liên tiếp nhau
		int a[] = {5, 10, 15, 20, 25};

			-------
		a[4]	|  25 |
			-------	   7.000.016
		a[3]	|  20 |
			-------	   7.000.012
		a[2]	|  15 |
			-------	   7.000.008
		a[1]	|  10 |
			-------	   7.000.004
		a[0]	|  5  |
			-------	   7.000.000

		// Vì a = &a[0] (lưu địa chỉ)
		p = a;		// 7.000.000
		p = &a[0]	// 7.000.000

		// Để lấy giá trị của biến con trỏ
		*p = a[0] = 5

------------------------------------------------------------

	3. Trỏ đến một toạ độ của vùng nhớ động (mảng động) - Heap:

		// Xin cấp 20 Byte (5 biến * 4 Byte) liền nhau
		// để chứa dữ liệu
		p = (int*)malloc(20);	// Trả về toạ độ đầu dãy: 8.000.000
		p = (int*)malloc(20);	// (của Byte đầu tiên trong cụm 4 Byte kiểu int),
					// giống với toạ độ của phần tử đầu mảng

			-------
		a[4]	|  25 | ~~~~~~~~~~~~~~~~~~~~~~~ p[4] = 25	| *(p + 4) = 25
			-------	   8.000.016
		a[3]	|  20 | ~~~~~~~~~~~~~~~~~~~~~~~ p[3] = 20	| *(p + 3) = 20
			-------	   8.000.012
		a[2]	|  15 | ~~~~~~~~~~~~~~~~~~~~~~~ p[2] = 15	| *(p + 2) = 15
			-------	   8.000.008
		a[1]	|  10 | ~~~~~~~~~~~~~~~~~~~~~~~ p[1] = 10	| *(p + 1) = 10
			-------	   8.000.004
		a[0]	|  5  | ~~~~~~~~~~~~~~~~~~~~~~~ p[0] = 5	| *(p + 0) = 5
			-------	   8.000.000

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Con trỏ chỉ cần trỏ đến một địa chỉ là được,	│
│	không quan tâm địa chỉ đó là của biến đơn,	│
│	mảng tĩnh hay mảng động	(đầu dãy của mảng)	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[CÁC LOẠI VÙNG RAM CỦA ỨNG DỤNG - MEMORY ALLOCATION / MEMORY LAYOUT]

Một ứng dụng bất kỳ, khi muốn thực thi được thì bắt buộc phải được nạp vào RAM. Từ đó, CPU chỉ đi vào RAM để đọc lệnh và thực thi chứ không thực thi lung tung ở những nơi khác.

Khi nhấn nút biên dịch (Compile), toàn bộ câu lệnh/mã nguồn (trong tập tin .c) do con người viết đều sẽ được chuyển thành tập tin nhị phân và được đóng gói lại thành tập tin .exe (tập tin có thể thực thi được). Khi thực thi (Run) tập tin .exe, tập tin sau đó sẽ được tải/đưa vào RAM và chiếm một vùng nhớ nhất định để máy tính có thể đọc, hiểu và thực thi theo được.

Trong một ứng dụng, sau khi thực thi/khởi chạy, ngôn ngữ lập trình sẽ xin hệ điều hành cấp một vùng nhớ trên RAM. Nhưng để CPU biết cần phải làm những câu lệnh gì thì vùng RAM ấy sẽ được chia thành bốn khu vực (segment) khác nhau:

--------------------------------------------------------------------------------

[1. CODE / TEXT SEGMENT: CHỨA TOÀN BỘ CÂU LỆNH]

Toàn bộ các hàm/câu lệnh (mã máy) đã được biên dịch (gói trong tập tin .exe) đều sẽ nằm ở đây để CPU biết cần phải làm gì. Khi thực thi tập tin .exe, CPU sẽ vào vùng này, đi tìm và sau đó đọc và thực thi theo những gì đã được ghi trong hàm main() - đưa câu lệnh vào RAM.
	-> Vùng chứa những hàm/câu lệnh (mã máy - nhị phân) để CPU biết cần phải làm gì tiếp theo.

	Ví dụ:
		// Hàm main()
		int main(int argc, char *argv[]) {
			int x = 10;
			f(x);

			// những câu lệnh khác bên trong hàm;

			return 0;
		}

--------------------------------------------------------------------------------

[2. DATA SEGMENT: CHỨA BIẾN TOÀN CỤC]

Vùng dữ liệu để sử dụng chung, những biến tĩnh (static) và những biến được khai báo toàn cục (có sẵn ngay khi chương trình được nạp, vượt ra khỏi phạm vi của hàm) sẽ không nằm chung với những câu lệnh đã được biên dịch ở vùng code segment, mà sẽ nằm riêng ở khu vực này. Mục đích là để dễ dàng quản lý và sử dụng, vì đây là những biến mà hàm nào cũng có thể nhìn thấy được.
	-> Vùng chứa biến toàn cục và biến tĩnh.

	Ví dụ:
		// Khai báo hằng số PI ở toàn cục
		const float PI = 3.14;

		// Khai số nguyên yob ở toàn cục
		int yob = 2000;
		int main(int argc, char *argv[]) {...}

--------------------------------------------------------------------------------

[3. STACK SEGMENT: NGĂN XẾP CHỨA TOÀN BỘ BIẾN CỤC BỘ]

Là vùng nhớ đã có sẵn tên, do hệ điều hành kiểm soát, bố trí vùng RAM và quản lý vô cùng nghiêm ngặt, con người không có quyền can thiệp hay kiểm soát.

	- Toàn bộ những biến được khai báo trong nội bộ hàm (kể cả hàm main()) / câu lệnh (cục bộ) - thuộc những kiểu dữ liệu cơ bản, dù là biến thường hay biến con trỏ, đều sẽ nằm riêng ở đây.

	- Tốc độ cấp phát sẽ nhanh hơn so với Heap vì kích thước của vùng nhớ là cố định.
	
	- Có kích thước hạn chế nhưng linh hoạt, hàm sử dụng đến đâu thì biến mới được cấp đến đấy và sẽ được tự động biến mất / dọn dẹp (deallocated) sau khi kết thúc hàm để giải phóng bộ nhớ. Vì vậy, nên tránh khai báo mảng với nhiều phần tử (ví dụ: 3000 phần tử) bên trong các hàm.

	-> Vùng chứa những biến cục bộ của hàm, được cấp trong quá trình sử dụng.
		=> Bố trí (allocate) một vùng được quy hoạch bài bản trên RAM.

	Ví dụ:
		// Biến x và y được khai báo cục bộ
		void f(int x) {
			int y;
			những câu lệnh khác bên trong hàm;
		}

Vùng nhớ trên Stack sẽ được cấp phát / hoạt động theo nguyên tắc LIFO (Last In, First Out) - hẻm cụt: biến nào được khai báo gần nhất thì sẽ được lấy ra để sử dụng trước.

Quản lý các hàm và các biến ra/vô một cách rất nghiêm ngặt.

Biến con trỏ trong vùng Stack có thể trỏ đến biến cục bộ, trỏ nội bộ bên trong vùng Stack này, hoặc có thể trỏ ra bên ngoài vùng khác (vùng Heap) - cách làm việc với vùng nhớ động.
	* Con trỏ cũng chỉ là biến và có thể linh hoạt nằm ở bất kì vùng nào (Data / Stack / Heap Segment), tuỳ vào biến mà nó đang trỏ đến.

Lời gọi hàm (hàm này gọi đến hàm khác) cũng sẽ được nằm trong Stack. Và do vùng RAM này đã được hệ điều hành quản lý và kiểm soát, nên sau khi hàm vừa thực thi xong và kết thúc, những biến cục bộ có liên quan đến hàm sẽ lập tức được hệ điều hành tự động dọn dẹp.

Nằm ở địa chỉ khoảng 6.000.000. Vùng Stack có kích thước cố định, nên nếu bị đầy/tràn (overflow) thì ứng dụng sẽ không thể hoạt động được.
	- Thường xảy ra khi có nhiều hàm lồng nhau được gọi hoặc một câu lệnh đệ quy bị lặp vô hạn.
	- Một số ngôn ngữ cho phép mở rộng thêm kích thước cố định của Stack.

--------------------------------------------------------------------------------

[4. HEAP SEGMENT: VÙNG NHỚ ĐỘNG]

		* Khai phá/Khai khẩn: làm cho vùng đất hoang vu hoặc những tài nguyên đang còn tiềm ẩn trở thành sử dụng được.
	* Khai hoang vùng RAM: công cuộc mở mang, khai phá vùng RAM.

Là vùng nhớ biến động (dynamic zone), tự do và không có tên, riêng biệt với những vùng nhớ thông thường khác (trong vùng Data và Stack).

	- Hệ điều hành sẵn sàng cấp cho người dùng mỗi khi có yêu cầu.
	
	- Do con người chủ động kiểm soát khi có thể tự xin cấp một vùng RAM với dung lượng mong muốn để lưu dữ liệu, mà không cần phải khai báo biến và đặt tên cho vùng RAM này (vì ta đang xin cấp phát một vùng RAM - nhiều Byte, sau đó sử dụng một biến khác để trỏ đến, chứa không phải xin cấp phát một biến).

	- Là một vùng nhớ có dung lượng rộng hơn Stack nhưng tốc độ cấp phát sẽ chậm hơn.

	- Mục đích của việc xin cấp phát là để lưu dữ liệu chứ không phải để lưu các câu lệnh.
	
	- Sau khi cấp phát thành công, vùng RAM tự do này sẽ trả về toạ độ vị trí của Byte đầu tiên, việc quản lý địa chỉ/toạ độ này sẽ thông qua con trỏ (pointer).
	
	- Dù câu lệnh xin cấp phát sẽ nằm trong hàm, mà theo lý thuyết thì hết hàm thì vùng nhớ cũng phải được tự động giải phóng, nhưng vùng nhớ động này lại là một ngoại lệ. Con người phải tự giải phóng khi không còn nhu cầu sử dụng, vì vùng RAM này không còn thuộc quản lý của hệ điều hành.

	-> Vùng nhớ tự do để chứa những dữ liệu, được cấp phát động và sử dụng như biến, cần một biến con trỏ được khai báo trong hàm (cục bộ) - trong Stack, để trỏ đến vùng RAM tự do này.
		=> Bố trí (allocate) một vùng trôi nổi (dynamic) trên RAM.

Nếu theo lập trình hướng đối tượng, đây là nơi để lưu trữ các dữ liệu kiểu đối tượng (object). Còn với những ngôn ngữ lập trình không phải hướng đối tượng, đây sẽ là nơi cho phép chủ động xin cấp một vùng RAM (với số Byte tuỳ chọn) để chứa những dữ liệu tuỳ thích, chứa những biến riêng mà không phải là biến toàn cục hay biến cục bộ. Nhưng đây không được xem là khai báo biến mà chỉ đơn giản là xin vùng nhớ để chứa dữ liệu.

----------------------------------------

* Lưu ý: trong Heap, ta sẽ xin cấp phát một vùng nhớ với một số Byte nào đó, không phải xin cấp phát biến.

	- Vì khai báo biến là khai báo bên trong hàm, chỉ định rõ tên biến và kiểu dữ liệu cần xin cấp phát.

	- Còn vùng RAM được cấp phát động trong Heap sẽ không có tên và phải sử dụng một con trỏ trong Stack để trỏ đến.

------------------------------------------------------------

Vì đây là vùng nhớ mà ta phải chủ động đặt tên, nên để xin được những vùng RAM trong đây thì cần phải có những câu lệnh đặc biệt:

	* malloc và calloc: kỹ thuật sử dụng bộ nhớ động, chủ động xin RAM cấp cho một dãy Byte liên tiếp nhau theo ý muốn bằng con trỏ (pointer) và quản lý bằng địa chỉ.

		- Được gói trong thư viện stdlib.
	
		- Sau khi cấp phát thì hệ điều hành và những ứng dụng khác sẽ không được xâm phạm đến vùng này.

		- Sau khi khai báo xong, hàm sẽ nhận về toạ độ/địa chỉ của Byte đầu tiên trong tổng số Byte đã xin cấp phát.

		- Có hình thức giống như mảng khi vùng nhớ được xếp liên tiếp nhau, vì vậy, tên biến con trỏ cũng được sử dụng để quản lý địa chỉ của phần tử đầu tiên trong toàn bộ phần tử.
		
			+ Nhưng không giống như mảng khi mảng chỉ là một con trỏ giả, biến malloc vẫn là một con trỏ thuần chủng khi được khai báo với dấu *.
			
			+ Vì vậy, khi tham gia vào một phép tăng/giảm tự thân (được phép nhưng vẫn không nên) hoặc một phép tính thông thường (cộng, trừ...), thì nó sẽ dịch chuyện một số Byte tương ứng với kiểu dữ liệu đã khai báo.

		- Nên xin cấp phát theo bội số của kiểu dữ liệu mà con trỏ đang trỏ đến, vì RAM được sử dụng để chứa dữ liệu, mà dữ liệu thì lại được lưu trữ theo kiểu dữ liệu. Giúp an toàn hơn trong việc di chuyển giữa các vùng nhớ.

		- Do ta tự lấy số Byte của vùng nhớ được cấp phát và đem đi chia cho bội số của kiểu dữ liệu nên mới nghĩ rằng được cấp phát theo biến, chứ thực chất chỉ là cấp phát nguyên một vùng nhớ.

			Ví dụ: nếu có một mảng kiểu số nguyên (int) gồm 5 phần từ
				5 biến x 4 Byte = 20 Byte.

		-> Xin cấp một vùng RAM với kích thước tuỳ chọn, nhận về giá trị là địa chỉ của Byte đầu tiên, sau đó đưa địa chỉ đấy cho con trỏ và quản lý giống như mảng.
			(Khai báo bằng con trỏ nhưng lại sử dụng giống như mảng.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Hàm trả về địa chỉ của một vùng nhớ tự do,	│
│	con trỏ sẽ trỏ đến và tương tác trong vùng này	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

		* malloc (Memory Allocation): là một hàm/lệnh để xin một vùng RAM ở Heap (khai hoang vùng RAM).

			- Vùng RAM này có thể đang chứa giá trị rác.

			- Đảm bảo rằng tốc độ sẽ nhanh hơn so với calloc() khi không phải thiết lập lại giá trị khởi tạo về 0.

			-> Xin cấp một vùng RAM với kích thước tuỳ chọn, nhưng trong vùng RAM ấy có thể sẽ chứa rác.
				(Xin vùng RAM, nhưng không cần dọn dẹp.)

			* Cú pháp:
					kiểu-dữ-liệu* biếnConTrỏ = (ép-kiểu-dữ-liệu*)malloc(cụm-byte-theo-kiểu-dữ-liệu);

				Ví dụ:
					// Để xin cấp phát một vùng đủ chứa 5 phần tử,
					// cần nhớ số Byte của một phần tử theo kiểu dữ liệu
					// và sau đó nhân cho số lượng phần tử
					//	Ta có: 5 (phần tử) * 4 (Byte) = 20 Byte
					int* p = (int*)malloc(20);

					// Nếu không muốn tính toán
					// thì chỉ cần nhớ số Byte của kiểu dữ liệu
					int* p = (int*)malloc(5 * 4);

					// Nếu không muốn nhớ hay tính toán gì
					int* p = (int*)malloc(5 * sizeof(int));

			       Nằm trong Stack | Nằm trong Heap

----------------------------------------

		* calloc (Contiguous Allocation / Clear Allocation / Count Allocation): cũng vẫn là một hàm/lệnh để xin một vùng RAM ở Heap (khai hoang vùng RAM).

			- Nhưng lúc này, khi cấp phát RAM, bên trong vùng RAM sẽ thiết lập lại giá trị khởi tạo về 0 (đã được quy hoạch) thay vì giá trị rác như malloc(), cũng chính vì vậy mà nó sẽ chạy chậm hơn so với malloc.

			- Câu lệnh xin vùng RAM cũng khác biệt khi có đến hai tham số đầu vào, còn lại thì toàn bộ cách sử dụng gần như đều sẽ giống với malloc() khi đều xin một vùng RAM tự do và quản lý bằng con trỏ.

			-> Xin cấp một vùng RAM với kích thước tuỳ chọn, nhưng toàn bộ giá trị khởi tạo sẽ được gán về 0.
				(Xin vùng RAM, nhưng yêu cầu phải sạch.)

			* Cú pháp:
					kiểu-dữ-liệu* biếnConTrỏ = (ép-kiểu-dữ-liệu*)malloc(số-lượng-phần-tử-muốn-xin, cụm-byte-theo-kiểu-dữ-liệu).

				Ví dụ:
					// Chỉ cần xin cấp phát 5 phần tử,
					// và nhớ số Byte của một phần tử theo kiểu dữ liệu
					int* p = (int*)calloc(5, 4);

					// Chỉ cần xin cấp phát 5 phần tử,
					// và không cần nhớ số Byte của một phần tử theo kiểu dữ liệu
					int* p = (int*)calloc(5, sizeof(int));

----------------------------------------

		* realloc (Re-allocation): xoá, thay đổi, xin cấp phát lại để mở rộng thêm vùng RAM/tái cấu trúc vùng RAM.

			- Nếu con trỏ chưa hề được cấp phát vùng nhớ, hàm này sẽ tự động cấp phát luôn một vùng nhớ mới.
				+ Sử dụng số 0 (hoặc NULL) để thay thế cho vị trí của con trỏ cần cấp phát.
				+ Vẫn sẽ mang sẵn giá trị rác giống như malloc() nếu không gán giá trị cho vùng nhớ sau khi đã cấp phát.

			- Nếu con trỏ đã có sẵn vùng nhớ, hàm sẽ cấp phát lại vùng nhớ cho con trỏ - nới rộng / thu hẹp hoặc thậm chí xoá vùng nhớ.
				+ Sử dụng tên của một con trỏ đã có sẵn vùng nhớ để cấp phát lại.
				+ Nếu trước đó chưa có vùng nhớ, mà cố tính cấp phát lại, thì sẽ gặp thông báo lỗi.

			-> Xin cấp một vùng RAM với kích thước tuỳ chọn hoặc thậm chí tái cấu trúc vùng RAM.
				(Ngoài việc xin vùng RAM, còn có thể thay đổi.)

			* Cú pháp:
					kiểu-dữ-liệu* biếnConTrỏ = (ép-kiểu-dữ-liệu*)realloc(con-trỏ-cần-cấp-phát, cụm-byte-theo-kiểu-dữ-liệu).

				Ví dụ:
					// Nếu chưa có vùng nhớ, muốn cấp phát mới
					int* p = (int*)realloc(0, 5 * sizeof(int));

					// Nếu đã có vùng nhớ, nhưng muốn thay đổi
					int* p = (int*)realloc(p, 10 * sizeof(int));

					// Nới rộng thêm một ô nhớ trong vùng nhớ cấp phát động
					// trước khi thêm một phần tử vào mảng
					realloc(p, (soLuongPhanTuThucTe + 1) * sizeof(int));

					// Thu hẹp một ô nhớ trong vùng nhớ cấp phát động
					// sau khi đã xoá một phần tử trong mảng
					realloc(p, (soLuongPhanTuThucTe - 1) * sizeof(int));

----------------------------------------

		* free: biến con trỏ vì được khai báo trong hàm nên khi hàm kết thúc sẽ được giải phóng khỏi vùng Stack, nhưng vùng nhớ trong Heap thì vẫn còn trong RAM và vẫn lưu đầy đủ các giá trị kể cả khi ứng dụng đã tắt.
		
			- Vì vậy, phải sử dụng thêm câu lệnh để giải phóng vùng nhớ đã xin cấp phát trước đó trong Heap sau khi đã kết thúc hàm, nếu không, vùng nhớ trong Heap sẽ trở thành "mồ côi" vì đã bị mất đi con trỏ trong Stack.

			- Đây chỉ là câu lệnh thông báo / tuyên bố không còn như cầu sử dụng (nhưng giá trị tại vùng nhớ vẫn còn được lưu lại), bộ nhớ chỉ thực sự được giải phóng khi hệ điều hành đã thu hồi lại vùng nhớ và sau đó đem đi cấp phát cho một tiến trình khác (không dọn dẹp ngay mà vẫn đem đi cấp để tiết kiệm công sức).

			-> "Ăn quả nhớ kẻ trồng cây" - Xin cấp phát thì phải tự giải phóng.
				(Hãy giải phóng vùng RAM mà tênBiếnConTrỏCấpPhátĐộng đang trỏ đến.)

			* Cú pháp:
					free(tênBiếnConTrỏCấpPhátĐộng);

				Ví dụ:
					// Xin vùng nhớ Heap 24 Byte để lưu 6 giá trị
					// với kiểu dữ liệu là số nguyên
					// (6 biến * 4 Byte (int) = 24 Byte)

					// Nhận về địa chỉ/toạ độ của Byte đầu tiên,
					// giống như phần tử đầu tiên trong mảng,
					// sau đó đưa địa chỉ cho con trỏ p
					int* p = (int*)malloc(24);

					// Con trỏ p vẫn là con trỏ thuần
					// vì nó có thể trỏ đến địa chỉ của một biến đơn lẻ
					// hoặc trỏ đến phần từ đầu tiên trong cả một mảng

					// Khi khai báo biến con trỏ kết hợp với hàm malloc:
					// 	- Biến "p" sẽ nằm trong Stack
					// 	- Vùng RAM chứa 24 Byte lại nằm trong Heap

					// Vì biến "p" được khai báo trong nội bộ hàm
					// nên nó sẽ nằm ở trong Stack,
					// nhưng lại có câu lệnh xin cấp phát vùng nhớ động
					// nên sẽ có một vùng RAM (dạng mảng) trong Heap
					// và vùng này không thuộc sự quản lý của hệ điều hành,
					// nên hệ điều hành không thể tự giải phóng
					// Vì vậy, sau khi sử dụng xong (khi kết thúc hàm)
					// thì phải có câu lệnh giải phóng vùng RAM
					// để trả lại bộ nhớ cho hệ điều hành

					// Khi kết thúc hàm, biến con trỏ "p" sẽ lập tức
					// được hệ điều hành giải phóng khỏi vùng Stack,
					// nhưng vùng nhớ Heap thì vẫn còn tồn tại
					// và vẫn đang lưu đầy đủ tất cả các giá trị
					// Vì vậy, phải có thêm câu lệnh giải phóng vùng RAM
					// mà biến con trỏ "p" đang trỏ đến sau khi chạy xong
					// để trả lại cho hệ điều hành khi không còn sử dụng
					free(p);

			- Khi giải phóng, vùng nhớ nào được cấp phát sau cùng sẽ được giải phóng đầu tiên.

				Ví dụ: cấp phát sau cùng, giải phóng đầu tiên
					int *a;
					int *b;
					int *c;

					free(c);
					free(b);
					free(a);

------------------------------------------------------------

	* Trong lập trình hướng đối tượng (C++, Java...).

		* new: xin cấp phát động vùng nhớ cho con trỏ.

			* Cú pháp:
				// Biến đơn
				kiểu-dữ-liệu* biếnConTrỏ = new kiểu-dữ-liệu-mà-biến-con-trỏ-đang-trỏ-đến;

				// Mảng
				kiểu-dữ-liệu* biếnConTrỏ = new kiểu-dữ-liệu-mà-biến-con-trỏ-đang-trỏ-đến[số-lượng-phần-tử-của-mảng-cấp-phát-động];

			Ví dụ 1: trong ngôn ngữ lập trình C++.
				// Cấp phát động một biến con trỏ "P"
				// có kiểu dữ liệu số nguyên (int)
				int* p;

				// Trỏ đến vùng nhớ
				// để chứa một biến đơn số nguyên
				p = new int;

				// Trỏ đến một vùng nhớ
				// để chứa một biến đơn số nguyên có giá trị là 5
				p = new int(5);

				// Trỏ đến một vùng nhớ
				// để chứa một mảng gồm n phần tử là số nguyên
				p = new int[n];

			Ví dụ 2: trong ngôn ngữ lập trình Java.
				Student x = new Student(...);
				// Biến con trỏ (biến đối tượng) "x"
				// trỏ đến một đối tượng (Object) Student

				// Nếu biến con trỏ "x" được khai báo trong hàm
				// thì nó sẽ nằm trong vùng nhớ Stack,
				// còn new (tương đương với malloc)
				// chắc chắn sẽ nằm ở trong vùng nhớ Heap

----------------------------------------

		* delete: có công dụng tương tự như free trong ngôn ngữ C. Trong ngôn ngữ C++, toán tử này có nhiệm vụ hủy bỏ biến đã tạo và thu hồi vùng nhớ.

			* Cú pháp:
					// Biến đơn
					delete biếnConTrỏ;
					
					// Mảng - Huỷ cấp phát động
					delete [] biếnConTrỏ;
					// Đưa con trỏ về trạng thái rỗng
					a = nullptr; // a = NULL;
						     // a = 0;

		* Garbage Collection / Garbage Collector (GC): Cơ chế tự động huỷ vùng RAM của một số ngôn ngữ lập trình (ví dụ: Java, C#...).
			- Lúc này, hệ điều hành sẽ tự động huỷ sau một khoảng thời gian được đã được cấu hình sẵn hoặc ta có thể chủ động muốn huỷ lúc nào thì huỷ.
			- Trong khi đó, các biến thông thường chỉ được huỷ khi kết thúc hàm.

------------------------------------------------------------

Tham khảo thêm: https://daynhauhoc.com/t/cap-phat-bo-nho-dong-trong-c-malloc-hay-calloc/6429/38

------------------------------------------------------------

	[RÒ RỈ BỘ NHỚ - MEMORY LEAK]

	Vùng nhớ được cấp phát động thông qua những câu lệnh cấp phát động (malloc(), calloc()...) được lưu trữ và quản lý trong Heap, do người dùng tự quản lý và hệ điều hành thì lại không được quyền thu hồi vùng nhớ này.
	
		- Khi hàm kết thúc thì biến con trỏ trong Stack sẽ được tự động giải phóng, vì đây là vùng do hệ điều hành quản lý.
		
		- Vùng Heap thì hoàn toàn ngược lại, nếu người dùng không chủ động huỷ vùng nhớ, mà sau đó còn chạy ứng dụng lặp lại nhiều lần, khiến vùng Heap sẽ liên tục tăng dần và dung lượng RAM bị giảm dần, nhưng hệ điều hành lại không có cách nào để thu hồi được, thì sẽ gây ra hiện tượng rò rỉ bộ nhớ (Memory leak).
		
		- Lúc này, chỉ còn cách là khởi động lại máy tính để hệ điều hành giành lại quyền kiểm soát như ban đầu, nhưng nếu vẫn cố chấp chạy lại ứng dụng sau khi đã khởi động thì tình trạng rò rỉ bộ nhớ vẫn sẽ tiếp tục xảy ra.

		-> Xảy ra hiện tượng "người đầu bạc tiễn kẻ đầu xanh", mất dần RAM vì vùng nhớ tự do trong Heap chỉ biết lặng nhìn biến con trỏ trong Stack bị hệ điều hành thu hồi sau khi hàm kết thúc.
			(Không giải phóng vùng nhớ Heap, thay vào đó cứ liên tục sử dụng sẽ dẫn đến rò rỉ.)

----------------------------------------

	[SỰ PHÂN MẢNH - FRAGMENTATION]

Vùng Heap có thể gặp vấn đề về phân mảnh vì dữ liệu được lưu trữ theo dạng khối (block) và không nằm liền kề / liên tiếp nhau (hoặc bị ngắt quảng).

	- Khi nằm rời rạc, giữa hai khối sẽ tạo ra một khoảng trống.

	- Sự phân mảnh diễn ra khi khi dung lượng trống giữa các khối quá ít, mặc dù tổng dung lượng trống vẫn còn nhiều, nhưng lại không tìm được khối trống nào có dung lượng vừa đủ với kích thước cần lưu trữ.

--------------------------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Biến được khai báo trong hàm sẽ nằm trong vùng Stack,	│
│	vùng nhớ được cấp phát động sẽ nằm trong vùng Heap	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

==========================================================================================

[CHUỖI - STRING]

Chuổi chẳng qua chỉ là một nhóm kí tự đứng sát nhau và tạo thành một câu văn (chuỗi - string).

	Ví dụ:
		SOS
		Ét o ét // Trong bảng mã ASCII, dấu cách / khoảng trắng cũng là một kí tự

Trong lập trình, chỉ có mảng mới có thể đứng sát nhau trong RAM.

	- Trong ngôn ngữ lập trình C không có khái niệm kiểu dữ liệu chuỗi.
	
	- Nếu muốn lưu trữ được nhóm kí tự đứng sát nhau này để có thể in ra trong tương lai, thì cần phải sử dụng mảng kí tự.

	- Vì vậy, chuỗi là một mảng kí tự - mảng một chiều (phân biệt với mảng số nguyên, mảng số thực...).

	- Số lượng phần tử thực tế của mảng kí tự luôn ít hơn một, vì phải chừa ra một phần tử để chứa một kí tự vô cùng đặc biệt - kí tự '\0' (NULL).

Để lưu một chuỗi (mảng kí tự) với chiều dài không cố định (ví dụ: tên người...) cần phải có một kí tự đặc biệt để đánh dấu việc kết thúc của chuỗi mà không gây nhiễu (hiểu lầm, cản trở, dư thừa) cho chuỗi vì xuất hiện những kí tự không mong muốn.

	- Vì độ dài của mỗi chuỗi là khác nhau, nên cần một dấu hiệu để kết thúc chuỗi để tránh phải duyệt từ đầu đến cuối mảng (khi cấp phát số lượng phần tử nhiều hơn cần thiết).

	- Việc sử dụng những kí tự vô hình (ví dụ: khoảng trắng, xuống dòng...) sẽ bất tiện khi dù không hiện thị ra nhưng vẫn sẽ chiếm chỗ.
	
	- Vì vậy, kí tự '\0' (NULL) được sử dụng vì nó không ảnh hưởng đến nội dung, không cản tầm nhìn và cũng không chiếm chỗ.

	-> Chuỗi là một mảng kí tự và bắt buộc phải kết thúc bằng kí tự '\0' (NULL) để biết điểm dừng, nếu không thì chỉ là một mảng thông thường.
		(Chuỗi gần giống như mảng kí tự, nhưng mảng kí tự chưa chắc đã là chuỗi vì đôi khi không kết thúc bằng '\0'.)

		Chuỗi ≈ Mảng kí tự

	Ví dụ: khai báo một mảng kí tự.
		char name[] = {'S', 'O', 'S', '\0', '$', '#'};
		//             ------------- Chuỗi ≈ Mảng kí tự
		//             ----------------------------- Mảng kí tự ≠ Chuỗi

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Chuỗi là một mảng kí tự và kết thúc bằng kí tự '\0' (NULL)	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

Vậy, khi khai báo một vùng RAM rất rộng để lưu chuỗi vì có thể sẽ có những chuỗi rất dài, nhưng đôi khi vì khai báo nhiều mà lại không sử dụng hết. Nếu muốn biết nên dừng ở đâu và đánh dấu kết thúc chuỗi trong mảng, mà không phải tốn công đi quét hết toàn mảng, ta sử dụng kí tự '\0' (NULL), vì đây là kí tự duy nhất không hiển thị nhưng cũng không chiếm chỗ.

	Ví dụ:
		// Khi khai báo: char name[50];
		// Trong RAM sẽ có 50 Byte liên tiếp nhau
		// để lưu được 50 kí tự,

		// Nhưng vì một mảng sẽ có độ dài/ngắn khác nhau
		// nên để biết phải in mảng đến đâu thì dừng
		// ta sử dụng kí hiệu '\0' để đánh dấu

		// Mỗi kí tự sẽ được sử dụng theo hai cách (đầu tiên)
		//	1. Mã số ASCII: số nguyên - thập phân.
		//	2. Trực tiếp bản thân kí tự: kí tự nháy đơn.
		//	3. Byte trong RAM: số nhị phân.

		// Vì vậy, kí tự NULL cũng được biểu diễn là:
		//	1. Số: 0
		//	2. Kí tự: '\0'
		//	3. Byte: 0000 0000


		// Đây là chuỗi vì có kết thúc bằng '\0',
		// nhưng vẫn có thể xem đây là mảng
		// nếu in chuỗi/mảng này ra bằng %s
		// thì cũng chỉ in đến khi gặp số ASCII 0
		// tương đương với kí tự '\0' là dừng
		// mà không quan tâm đến phần còn lại có gì
		char name[50] = {'S', 'O', 'S', '\0', '$', '#'};
		
		// Đây không phải là chuỗi, mà chỉ là mảng thông thường,
		// nếu in mảng ra bằng %s thì sẽ in đến hết chiều dài mảng
		// hoặc đến khi gặp số ASCII 0
		// tương đương với kí tự '\0' thì dừng
		char name[50] = {'S', 'O', 'S', '$', '#'};

		// Trong quá trình in từng kí tự trong mảng
		// bằng %c và vòng lặp for,
		// nếu duyệt lố số phần tử được xin cấp phát trong mảng
		// thì những phần tử chưa được gán giá trị sẽ mang giá trị rác
		
		// Nếu vô tình và may mắn gặp một số ASCII 0
		// tương đương với kí tự '\0' ở giữa đường thì mới dừng
		// còn không sẽ bị lặp vô tận

--------------------------------------------------------------------------------

[CHI TIẾT VỀ KÍ TỰ NULL - CÓ LẼ TA NÊN DỪNG LẠI]

Để nạp được thẻ cào điện thoại, các nhà mạng di dộng đã quy ước.

	* Cú pháp (ví dụ: Viettel): *Con-số-tuỳ-loại-thuê-bao*Mã-số-thẻ-cào#
			- Đối với thuê bao trả trước: 100*1234 56789 98765 4321#
			- Đối với thuê bao trả sau: 199*1234 56789 98765 4321#
				(Trong đó, dấu '#' là kí hiệu để kết thúc chuỗi,
				 kết hợp với '100*' hoặc '199*' để nhà mạng biết
				 phải xử lý thông tin được gửi đến như thế nào.)

Có những kí tự để báo hiệu một điều gì đó, có thể hữu hình hoặc vô hình đối với mắt người:

	* Trong thực tế:
		- Cờ đen ở bãi tắm để báo hiệu rằng vùng nước ở khu vực ấy rất nguy hiểm (có xoáy nước...).
		- Biển cảnh báo đặt trên sàn nhà tại những nơi trơn trượt.
		- Biển báo giao thông để báo hiệu cách lưu thông trên đường.
		- Gương cầu được gắn trên các con đường để báo hiệu rằng đường ở đây rất cong.
		-> Là một dấu hiệu để cảnh báo, nhưng đồng thời cũng vì sự hiện diện của nó mà sẽ làm cản trở tầm nhìn. Các kí hiệu sẽ gây chắn tầm nhìn, làm xấu đi bức tranh tổng thể và mất đi nét thiên nhiên tự nhiên.

	* Trong máy tính & lập trình:

		- ' ': khoảng trắng - giúp hai kí tự đứng gần nhau được giãn cách ra.

			+ Kí tự này có tồn tại nhưng lại không làm ảnh hưởng đến nội dung, không cản tầm nhìn nhưng vẫn sẽ chiếm một khoảng không để ngăn cách đôi bên.
		
			+ Chỉ hiện nguyên hình trong một số ngữ cảnh, ví dụ: được quét chọn, đặt hai kí tự có thể hiển thị được ở hai bên, sử dụng tính năng hiển thị dấu định dạng / dấu phân đoạn (Formatting Mark / Paragraph Mark / Pilcrow)...

			+ Nếu sử dụng để kết thúc một chuỗi thì không sao, nhưng khi nối hai chuỗi lại với nhau thì khoảng trắng sẽ hiện nguyên hình và bộc lộ sự hạn chế.

		- '\0': kí tự NULL - dùng như một cờ/cột mốc/dấu hiệu để đánh dấu việc kết thúc chuỗi trong RAM, trên ổ đĩa.

			+ Kí tự này không làm ảnh hưởng đến nội dung, không cản tầm nhìn và cũng không chiếm chỗ, được đánh dấu việc kết thúc của một vùng RAM.

			+ Cũng giống như thần thánh, tuy không thấy, nhưng vẫn có sức ảnh hưởng.

		-> Là một dấu hiệu cũng để cảnh báo, tuy có tồn tại, nhưng lúc này lại vô hình đối với mắt nhìn của con người, giúp đảm bảo yếu tổ mỹ quan.

=> Kí tự để đánh dấu việc kết thúc (≈ escape character), nhưng lại vô hình, không chiếm chỗ và cũng không được tính là một kí tự/thành phần của chuỗi.
	(Có lẽ ta nên dừng lại.)

------------------------------------------------------------

Để hiện thị được trong máy tính, mỗi kí tự đầu sẽ được chuyển đổi thành nhị phân:

(Nhị phân)	(Thập phân/Mã ASCII)	(Kí tự cho sự tồn tại - vô hình/hữu hình)
0000 0000		0		'\0' (NULL)	-> Vô hình
0000 1010		10		'\n' (Enter)	-> Vô hình
0010 0000		32		' ' (Space)	-> Vô hình
0011 0000		48		'0'		-> Hữu hình
0100 0001		65		'A'		-> Hữu hình
0110 0001		97		'a'		-> Hữu hình

	* Đối với kí tự '\0' (NULL), tín hiệu tồn tại trong máy tính sẽ là 0000 0000, tương ứng với màn hình không hiển thị gì cả. CPU cũng biết đây là điểm dừng khi gặp 0000 0000. Vì vậy mà chuỗi khi in ra sẽ không bị nhiễu (hiểu lầm, cản trở, dư thừa) vì xuất hiện những kí tự không mong muốn.

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Kí tự NULL để đánh dấu sự kết thúc mà không gây nhiễu	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[SỰ TƯƠNG QUAN GIỮA CHUỖI, MẢNG & CON TRỎ]

Cách để lưu được một chuỗi kí tự vào trong RAM, liên quan đến mảng và con trỏ.

Tất cả các hàm liên quan đến xử lý chuỗi đều luôn nhận tham số đầu vào là tên mảng / con trỏ (char*) - truyền tham chiếu, thay vì sử dụng cặp dấu ngoặc vuông [].

	- Vì bản chất con trỏ cũng chỉ đơn giản là tên của một mảng nhưng được bỏ ngoặc vuông [] đi, bên trong chứa địa chỉ của phần tử đầu tiên trong mảng.

	- Nghĩa là chỉ cần nhận vào toạ độ của một biến kiểu char, không cần quan tâm toạ độ này là biến đơn hay là một mảng kí tự (chỉ cần biến đầu dãy).
	
	- Một khi đã truyền vào toạ độ của biến đầu tiên trong mảng ki tự thì cũng tự động suy ra được những phần tử còn lại - kế tiếp trong mảng, vì chúng nằm chung một dãy Byte (đứng đầu dãy là biết được toàn dãy) bằng phép tăng tự thân.

	Vì: int* a (con trỏ) = int a (tên mảng, bỏ []) = biến để lưu địa chỉ

		-> Tất cả các hàm liên quan đến chuỗi đều là truyền tham chiếu, việc truyền tên mảng vào cho hàm chính là truyền con trỏ.

		Ví dụ: hai cách khai báo khác nhau, nhưng chung một ý nghĩa và cách sử dụng

			// Sử dụng mảng
			void strcpyCust(char dest[], char src[]) {...}

			// Sử dụng con trỏ
			void strcpyCust(char* dest, char* src) {...}

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Chuỗi = Mảng = Con trỏ / Tên chuỗi = Tên mảng = Con trỏ	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

* Các cách để khai báo chuỗi và đưa dữ liệu vào.

----------------------------------------

1. Khai báo chuỗi và gán sẵn giá trị trong lúc khai báo:

	Ví dụ 1: cách 1 - khai báo từng kí tự/phần tử trong mảng

		// Cũng giống như mảng, khi khai báo,
		// ta có quyển chỉ định trước số lượng phần tử tối đa
		// hoặc để trống và chương trình sẽ tự động xác định độ dài

		//int   a[] = { 1,   2,   3,    4,   5,   6};
		char name[] = {'S', 'O', 'S', '\0', '$', '#'};
		//	       ------------- Chuỗi
		//	       ----------------------------- Mảng

		// Ngoài ra, còn có thể sử dụng mã số ASCII
		// để thay thế cho kí tự
		//char name[] = {65, 'O', 'S', 0, '$', '#'}; // AOS

		// * In chuỗi
		printf("Your name: %s\n", name);
		// %s sẽ tự đi vào vùng RAM của tên chuỗi / tên mảng
		// và tự động sử dụng dấu * để đi đến địa chỉ,
		// sau đó quét chuỗi / mảng cho đến khi gặp kí tự NULL
		// như báo hiệu rằng: "Đã kết thúc chuỗi" thì dừng,
		// không cần phải đi hết mảng
		// vì mảng được sử dụng cho tối đa
		// (%s chỉ chơi với NULL để kết thúc)

		// * In mảng
		// Vì đây cũng là mảng kí tự
		// nên để in được những kí tự còn lại ở phía sau NULL,
		// thì chỉ cần sử dụng for
		// để duyệt qua từng phần tử trong mảng
		// rồi kết hợp với %c để in như bình thường
		// (%c sẽ chơi với từng kí tự một đến hết mảng)
		printf("Your name (printed by using for):\n");
		for (int i = 0; i < 6; i++)
			printf("%c", name[i]); // a[i], p[i]

	Ví dụ 2: cách 2 - gán cả cụm bằng dấu nháy đôi ""

		// Thay vì sử dụng dấu nháy đơn ''
		// để khai báo từng kí tự trong chuỗi
		// (từng phần tử trong mảng),
		// ta có thể sử dụng dấu nháy đôi ""
		// để gán nhanh giá trị cho chuỗi

		// * In chuỗi
		// Lúc này, C sẽ tự động chèn thêm kí tự NULL
		// vào cuối chuỗi (không phải cuối mảng)
		// và vẫn chỉ tốn đúng bằng số kí tự đã gán
		char name[] = "E't-o-e't"; // 9 kí tự
		printf("Your name: %s", name);

----------------------------------------

2. Khai báo chuỗi và nhập dữ liệu vào từ bàn phím:

		// Chỉ đưa địa chỉ của phần tử đầu tiên trong mảng
		// nhưng lại có thể nhận vào cả một chuỗi,
		// đó là vì ta đang có một mảng liên tiếp và có sẵn rất nhiều Byte,
		// nên mỗi phần tử trong mảng sẽ tự động nhận một kí tự
		// (tự động đổ một loạt kí tự vào dãy biến gần nhau)
		// và tự động chèn kí tự '\0' (NULL) vào cuối chuỗi

		char name[50];
	
		printf("Input your name: ");
		scanf("%s", name);

		// Trong quy tắc của câu lệnh scanf()
		// ta có thể nhập cùng một lúc nhiều biến (char, int, float...),
		// và sử dụng dấu khoảng trắng (space)
		// để ngăn cách giữa các biến với nhau khi nhập vào,
		// sử dụng dấu xuống dòng (enter)
		// để kết thúc việc nhập cho từng biến hoặc toàn bộ biến
		// 	-> Dấu khoảng trắng (space) và xuống dòng (enter)
		//	   sử dụng để ngăn cách các giá trị được nhập vào của biến

	Ví dụ 1: cách 1 - nhập đến khi gặp khoảng trắng thì dừng

		// Nếu cũng chỉ sử dụng câu lệnh scanf(%s) đơn thuần
		// để nhập vào một chuỗi (ví dụ: tên người...) từ bàn phím,
		// thì các khoảng trắng xuất hiện trong chuỗi
		// sẽ khiến câu lệnh chỉ lấy phần đằng trước khoảng trắng đầu tiên
		// mà loại bỏ phần còn lại nằm sau khoảng trắng đầu tiên,
		// phần chuỗi bị bỏ lại sẽ nằm trong bộ đệm bàn phím (buffer)
		scanf("%s", name);

	Ví dụ 2: cách 2 - nhập tự do nhưng có giới hạn độ dài tuỳ theo kích thước khai báo

		// Để thông báo rằng câu lệnh nhập này
		// chỉ tập trung vào kí tự xuống dòng (enter)
		// là kí tự duy nhất để kết thúc việc nhập,
		// còn những kí tự khác đều sẽ không quan tâm đến
		scanf("%[^\n]", name);
		// Nhập vào và nhận tất cả các kí tự,
		// ngoại trừ kí tự '\n' - kí tự xuống hàng (enter)

		// Quy định số lượng kí tự tối đa muốn lấy
		// (ví dụ: tối đa 69 kí tự)
		scanf("%69[^\n]", name);

	Ví dụ 3: cách 3 - nhập tự do và không giới hạn độ dài

		// Sử dụng cặp lệnh mới (để tương tác với chuỗi):
		//	gets(char *);	: nhập vào (tương đương với scanf()) và không giới hạn độ dài nhập nên sẽ khá nguy hiểm vì có thể sẽ bị đè phần phía sau, nhưng sẽ giúp đa dạng trong việc nhập
		//	puts(char *);	: in ra (gần tương đương với printf()) và tự động xuống dòng (con trỏ sẽ nằm ở dòng bên dưới, trong khi với printf() thì con trỏ sẽ nằm kế bên chuỗi vừa in ra.)

		// Câu lệnh nhập vào, tương đương với scanf()
		gets(name);
		// In ra (trong trường hợp này là chuỗi vừa nhập)
		// rồi sau đó tự động xuống dòng,
		// gần tương đương với printf()
		puts(name);

----------------------------------------

3. Khai báo chuỗi và gán giá trị giữa hai chuỗi cho nhau:

	Ví dụ 1: cách 1 - sử dụng hàm strcpy() có sẵn

		// Dấu bằng '=' chỉ có thể được dùng ngay lúc khai báo,
		// khi gán giá trị giữa các biến đơn
		// hoặc khi sử dụng con trỏ thuần chủng
		char n1[50] = "Ahihi"; // Gán ngay lúc khai báo

		// Ta không thể khai báo trước rồi sau đó mới gán giá trị cho chuỗi / mảng,
		// vì dấu bằng '=' không cho phép gán nhiều giá trị cùng một lúc
		// (liên quan đến việc gán nhiều biến)
		// và chuỗi / mảng khi này lại đang cần nhận vào một địa chỉ

		// Lúc này, chuỗi / mảng đang cần nhận vào một địa chỉ,
		// mà bản thân tên chuỗi / mảng cũng đang chứa địa chỉ của phần từ đầu tiên,
		// vậy mà lại cố gắng tìm cách thay thế địa chỉ này bằng một chuỗi khác
		char name1[50];
		name = "Ahihi"; // Không được

		// Hai biến đơn có thể gán trực tiếp giá trị cho nhau,
		// nhưng hai mảng (con trỏ) thì lại không thể,
		// vì đây là con trỏ giả và được sử dụng để quản lý mảng
		// nên không thể trỏ đến nơi nào khác ngoài trỏ đến "nhà" của mình,
		// nếu thật sự trỏ đến nơi khác thì sẽ khiến các phần tử còn lại bị bơ vơ
		// (lỡ sinh ra ở đâu thì bắt buộc phải gắn liền với nơi ấy)
		name = n1; // Không được
		// (Nhưng con trỏ thuần chủng thì lại có thể trỏ đến bất cứ đâu,
		//  kể cả vùng nhớ động - Heap)

		// Để tiện lợi, ta sẽ sử dụng hàm có sẵn
		// để sao chép giá trị của chuỗi
		strcpy(name, n1);
		// Vào mảng n1 và sao chép từng kí tự trong mảng
		// rồi đưa sang cho mảng name, kể cả kí tự NULL ở cuối mảng

	Ví dụ 2: cách 2 - sử dụng vòng lặp for để gán từng kí tự (biến đơn)

		// Sao chép từng giá trị đơn của biến trong mảng này
		// gán sang cho biến trong mảng kia

		// - Con trỏ (pointer): trỏ biến đầu mảng
		//
		// - Biến con trỏ dest (destination)
		// sẽ trỏ vào biến đầu mảng cần nhận dữ liệu vào
		// để tiến hành sao chép
		// và trả về kết quả sau khi đã sao chép
		// (Nơi thiếu và cần nhận về)
		//
		// - Biến con trỏ src (source)
		// sẽ trỏ vào biến đầu mảng đang có dữ liệu
		// và cần đưa cho ai đó
		// để đối phương thực hiện sao chép
		// (Nơi có và cần cho đi)
		void strcpyCust(char* dest, char* src) {

			// Đi từ đầu đến cuối chuỗi gốc (chuỗi gửi dữ liệu)
			// (Dấu <= để đảm bảo cả kí tự NULL cũng được đưa sang)
			for (int i = 0; i <= strlen(src); i++)

				// Sao chép từng kí tự từ bên src để đưa sang dest
				dest[i] = src[i];
		}

------------------------------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――
│	%s: Đi đến khi nào gặp NULL thì dừng	│
│	%c: Đi đến hết mảng kí tự		│
―――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CÁC KỸ THUẬT THAO TÁC GIỮA KÍ TỰ VÀ CHUỖI]

------------------------------------------------------------

[IN KÍ TỰ VÀ CHUỖI]

* Chi tiết các cách để in ra một chuỗi:

	Ví dụ: khai báo một mảng bằng dấu nháy kép "", sau đó tìm cách in ra kí tự đầu tiên và toàn bộ chuỗi

		char name[50] = "thuan";

		// Vì name bây giờ đã là một chuỗi
		// chứ không còn là kí tự
		// (%c nhận vào một kí tự hoặc mã ASCII)

		// 01. Nên nếu sử dụng tênChuỗi + %c
		//     thì sẽ nhận về một địa chỉ trong RAM,
		//     nhưng không thể in ra địa chỉ bằng %c
		printf("The original name: %c\n", name);	// In ra: kí tự '░'

		// 02. Còn nếu sử dụng *tênChuỗi + %c
		//     thì sẽ nhận về một giá trị (ở đây là một kí tự)
		printf("The original name: %c\n", *name);	// In ra: kí tự 't'

		// 03. Còn nếu sử dụng *tênChuỗi + %c + for
		//     và kết hợp thêm hàm strlen() bên trong for
		//     thì có thể duyệt và in ra toàn bộ kí tự
		printf("The original name: ");
		for (int i = 0; i < strlen(name); i++)
			printf("%c", *(name + i));		// In ra: mảng kí tự "thuan"
	
		// 04. Trong khi đó, nếu chỉ sử dụng tênChuỗi + %s
		//     thì mặc dù giá trị truyền vào vẫn là con trỏ (tên chuỗi)
		//     chứa địa chỉ của phần từ đầu tiên trong mảng,
		//     nhưng %s vẫn sẽ tự động đi đến địa chỉ
		//     và chuyển đổi thành giá trị
		//     (ở đây là chuyển đổi từng kí tự một để ra được chuỗi)
		//      vì mảng là một dãy Byte liên tiếp
		printf("The original name: %s\n", name);	// In ra: chuỗi "thuan"

------------------------------------------------------------

[XOÁ KÍ TỰ TRONG CHUỖI]

* Giả sử có một chuỗi đang bị thừa kí tự:

	char a[50] = "A1hihi";

	* Mảng trước khi xoá kí tự thừa
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	│  A  │  1  │  h  │  i  │  h  │  i  │  \0 │     │ ... │     │     │
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	  [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]         [48]  [49]


		* Thuật toán: tìm vị trí cần xoá và dời những vị trí còn lại phía sau lên (domino).

			// Cách đơn giản
			for (vị-trí-cần-xoá -> cuối-chuỗi)

				// Phần tử muốn xoá sẽ được thế chỗ bằng phần tử phía sau,
				// nhưng chỉ thay thế về mặt giá trị
				// chứ không thể thay thế về mặt địa chỉ
				// vì toạ độ của biến vẫn sẽ nằm cố định trong RAM

				// Phần tử phía sau tạo một bản sao của chính mình,
				// sau đó gán đè lên phần tử phía trước
				// Tính từ chỗ muốn xoá trở về sau,
				// luôn luôn có một kí tự bị lặp lại hai lần
				//	Ví dụ: sau lần lặp đầu tiên (a[1] = a[2])
				//		- Chuỗi gốc: A1hihi
				//		- Chuỗi sau xoá: Ahhihi
				s[i] = s[i + 1];

					a[1] = a[2];
					a[2] = a[3];
					a[3] = a[4];
					a[4] = a[5];
					a[5] = a[6];	// NULL
					// Lúc này, trong RAM sẽ có đến hai kí tự NULL


	* Mảng sau khi xoá kí tự thừa
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	│  A  │  h  │  i  │  h  │  i  │  \0 │  \0 │     │ ... │     │     │
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	  [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]         [48]  [49]

----------------------------------------

* Xoá toàn bộ số hoặc kí tự lạ trong chuỗi:

	- Bản chất của việc xoá là phải xác định được vị trí cần xoá, sau đó dồn phần tử phía sau lên để đè mất phần tử phía trước đó.

		+ Nếu sử dụng phương pháp xoá truyền thống thì vị trí xoá sẽ được tăng sau mỗi lần gán đè giá trị. Điều này sẽ không thành vấn đề khi chỉ có duy nhất một vị trí cần xoá hoặc các giá trị cần xoá nằm rời rạc nhau trong mảng.

		+ Nhưng nếu có từ hai vị trí cần xoá trở lên và chúng lại nằm kế nhau, việc sử dụng lại cách truyền thống sẽ gây thiếu sót khi vị trí mới được gán đè lại là một kí tự cần xoá, nhưng chỉ số duyệt của biến xoá đã được tăng lên trước đó rồi.

	-> Liên tục kiểm tra điều kiện xoá tại một vị trí cho đến khi không thoả điều kiện.


	char a[50] = "A111H";

	* Mảng trước khi xoá kí tự thừa
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	│  A  │  1  │  1  │  1  │  H  │  \0 │     │ ... │     │     │
	―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
	  [0]   [1]   [2]   [3]   [4]   [5]   [6]         [48]  [49]


		* Thuật toán:
			1. Tìm vị trí cần xoá và dời những vị trí còn lại phía sau lên (domino).
			2. Nhưng sau đó không vội tăng vị trí cần xoá lên mà vẫn kiểm tra lại điều kiện xoá tại vị trí cần xoá một lần nữa.
			3. Liên tục kiểm tra lại cho đến khi hết thoả điều kiện.
			-> Không chủ quan, vẫn phải kiểm tra tại một vị trí nhiều lần.

			// Duyệt từng phần tử của mảng
			// để kiểm tra xem có phải là số để xoá hay không
			for (int i = 0; i < strlen(s); i++) {

				// Nếu mở rộng thành bài xoá toàn bộ kí tự lạ
				// không thuộc A-Z và a-z
				// (kiểm tra phủ định trong khoảng A-Z và a-z)
				// if (!(tolower(s[i]) >= 'a' && tolower(s[i]) <= 'z'))

				// Nếu là con số từ 0..9
				// thì xứng đáng bị xoá
				// tại vị trí [i] trở về sau
				if (s[i] >= '0' & s[i] <= '9') {

					// Duyệt từng phần tử để dồn mảng (xoá),
					// xoá từ vị trị tìm thấy trở về sau
					
					
						a[j] = a[j + 1];

					// Nếu hết vòng for (j) này
					// thì i chắc chắn sẽ được tăng lên (tự động)
					// và sẽ gây ra hiện tượng có xoá nhưng bị sót
					// khi phần tử mới dồn lên cũng là một con số

					// Tình trạng này chỉ xảy ra
					// khi có các con số đừng kế nhau trong chuỗi,
					// mà ta lại chỉ duyệt một lần tại một vị trí
					// để tìm con số đó và sau đó lập tức dồn lên

					// Để tránh việc phần tử vừa dồn lên
					// cũng lại là một phần tử cần được xoá
					// (trà trộn, lách luật),
					// nếu kiểm tra không kĩ chắc chắn sẽ bị sót

					// Vì vậy, nếu có xoá
					// thì vẫn sẽ dồn phần tử phía sau lên phía trước,
					// nhưng sẽ không tăng biến đếm i
					// để đề phòng tại vị trí vừa xoá
					// lại là một con số mới được dồn lên
					
					i--;
					// Chỉ thực hiện khi có xoá và dồn phần tử
				}
			}


	* Mảng sau khi xoá kí tự thừa
	―――――――――――――――――――――――――――――――――――――――――――――――――
	│  A  │  H  │  \0 │  \0 │     │ ... │     │     │
	―――――――――――――――――――――――――――――――――――――――――――――――――
	  [0]   [1]   [2]   [3]   [4]         [48]  [49]

------------------------------------------------------------

[SO SÁNH CHUỖI]

* Các phép so sánh: >, >=, <, <=, ==, !=

--------------------

1. So sánh các giá trị đơn: có thể sử dụng các phép so sánh để so sánh các đại lượng / con số / biến đơn - chỉ có duy nhất một giá trị (kiểu int, float...).

	Ví dụ:
		int a = 5;
		int b = 10;

			a > b // Thực tế: sai rồi

			a > b // Máy tính: 0 (False)

--------------------

2. So sánh các kí tự: vì kí tự bản chất đằng sau vẫn là con số nguyên (mã ASCII) và chiếm 1 Byte, nên việc so sánh hai kí tự đồng nghĩa với việc so sánh mã ASCII của chúng.

	- Mỗi kí tự sẽ có một mã số ASCII để "chống lưng".

	- Vì bản chất vẫn là hai số nguyên, ta hoàn toàn có thể sử dụng các toán tử so sánh.
	
	-> So sánh các kí tự thực chất là so sánh hai số nguyên trong bảng mã ASCII.

	Ví dụ: các con số chống lưng trong bảng mã ASCII
		'A' = 65
		'a' = 97
			-> 'a' > 'A' (97 > 65)

		'!' = 33
		'#' = 35
			-> '#' > '!' (35 > 33)

--------------------

3. So sánh các chuỗi kí tự: vì bản chất thực sự của chuỗi / mảng là con trỏ là chứa địa chỉ vùng nhớ, nên không thể áp dụng các phép toán để so sánh lên chuỗi.

	- Nếu so sánh thì ta chỉ đang so sánh hai địa chỉ của hai con trỏ và kết quả chắc chắn sẽ không bằng nhau khi đây là hai chuỗi / mảng độc lập.
	
	- Về tổng quát, khi tương tác với tên chuỗi / mảng, ta bắt buộc phải sử dụng các hàm được cung cấp sẵn hoặc tự xây dựng các hàm.

	- Để xây dựng được các hàm tương tác được với chuỗi / mảng thì ta phải đi sâu vào bên trong chuỗi / mảng và tương tác với từng phần tử bên trong.

	-> Phải sử dụng hàm chuyên biệt để tương tác với từng phần tử bên trong chuỗi / mảng, không được sử dụng trực tiếp tên mảng / chuỗi vì đây là con trỏ.

	Ví dụ:
		char s1[50] = "Ahjhj";
		char s2[50] = "Ahjhj";

		// s1 và s2 là tên mảng - biến con trỏ,
		// trỏ đến phần tử đầu tiên trong mảng
		// (chứa toạ độ/địa chỉ)

		// Mảng không phải là biến đơn mà là biến con trỏ,
		// nên không có quyền thay đổi địa chỉ
		// và cũng không cần phải đem đi so sánh,
		// vì địa chỉ của chúng vốn đã luôn luôn khác nhau
		
		// Kết quả của phép so sánh hai tên mảng
		// * Quy ước:
		//	- Đúng: 1 (True)
		//	- Sai: 0 (Fasle)
		//		-> Luôn luôn sai vì hai mảng khác địa chỉ
		int r = s1 == s2;
		printf("r1 = %d\n", r); // 0 - điều đương nhiên

		// Nhưng lại có thể so sánh
		// về các giá trị nằm bên trong mảng
		// bằng cách sử dụng các hàm

	* Hàm so sánh chuỗi:
		strcmp: so sánh chuỗi, có phân biệt kí tự hoa và thường.
		stricmp: so sánh chuỗi và không quan tâm kí tự hoa hay thường.
			* Ignore case: so sánh chỉ quan tâm đến chữ cái nói chung và không quan tâm đến chữ hoa hay chữ thường.
				- Vì chỉ quan tâm đến mặt chữ, nên kí tự 'a' hay 'A' đều được xem là như nhau và bằng nhau.
				- Đây là điều mà đối với những phép toán thông thường sẽ không có, nhưng ở trong chuỗi lại có.

		* Quy ước của hàm: lấy chuỗi bên trái làm mốc, sau khi tính hiệu của hai phần tử trong mảng sẽ có được ba giá trị trả về (không quan tâm hơn/kém nhau bao nhiêu đơn vị).
			1. Chuỗi trái > Chuỗi phải ->  1 (lớn hơn / thắng - dương)
			2. Chuỗi trái = Chuỗi phải ->  0 (bằng nhau / huề - bằng 0)
			3. Chuỗi trái < Chuỗi phải -> -1 (nhỏ hơn / thua - âm)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Vì tên chuỗi là con trỏ để lưu toạ độ, nên khi làm việc với chuỗi		│
│	phải sử dụng các hàm chuyên biệt để tương tác với từng phần tử bên trong.	│
│	(Không được trực tiếp sử dụng phép gán hoặc các toán tử so sánh lên con trỏ)	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

----------------------------------------

[CHI TIẾT THUẬT TOÁN SO SÁNH HAI CHUỖI]

* Thuật toán so sánh: so sánh từ kí tự của cả hai chuỗi với nhau.
	1. Trong hai chuỗi, lấy một chuỗi làm mốc (ví dụ: chuỗi bên trái).
	2. So sánh hai chuỗi từ trái sang phải, dựa theo mã ASCII, lấy từng kí tự ở cùng vị trí thứ [i] tương đương nhau của hai chuỗi ra để so sánh.
	3. Nếu thấy được sự khác biệt thì dừng và đi thẳng đến kết luận (mà không cần quan tâm phần còn lại).

* Lưu ý:
	- Cần kiểm tra xem chuỗi có phân biệt chữ hoa và thường hay không.
	- Chuỗi dài hơn không có nghĩa là sẽ lớn hơn.

	Ví dụ 1: lớn hơn về mặt hiển thị (hình ảnh) - chiếm nhiều pixel hơn, nhưng lại bé hơn trong bảng mã ASCII
		Chuỗi 1: Ahjhj
		Chuỗi 2: AHjhj
			Dừng lại tại vị trí [2] để xem xét
			Vì kí tự 'h' > 'H' (104 > 72)
				-> Chuỗi 1 > Chuỗi 2

	Ví dụ 2: tuy chuỗi ngắn hơn nhưng lại lớn hơn về vị trí trong bảng mã ASCII
		Chuỗi 1: aHJHJ
		Chuỗi 2: Ahjhj
			Dừng lại tại vị trí [1] để xem xét
			Vì kí tự 'a' > 'A' (97 > 65)
				-> Chuỗi 1 > Chuỗi 2

	Ví dụ 3: thiếu kí tự đồng nghĩa với kí tự bé nhất - kí tự '\0' (NULL)
		Chuỗi 1: Zz
		Chuỗi 2: Z
			Dừng lại tại vị trí [2] để xem xét
			Tuy giống như kí tự đầu là 'Z',
			nhưng kí tự [2] của chuỗi 2 lại là NULL (90 > 0)
				-> Chuỗi 1 > Chuỗi 2

	Ví dụ 4: không phân biệt hoa và thường (Ignore case)
		Chuỗi 1: ahjhj
		Chuỗi 2: AHJHJ
			Dừng lại tại vị trí [1] để xem xét
			Vì không phân biệt hoa và thường
				-> Chuỗi 1 = Chuỗi 2

==========================================================================================

[MẢNG HAI CHIỀU]

Ứng dụng: khi tên của mỗi người là một mảng và được ghép lại từ nhiều kí tự. Vì vậy, cần thêm rất nhiều mảng để có thể lưu được danh sách sinh viên.
	(Mảng của các mảng.)

* Sắp xếp tên sinh viên:

	// So sánh không quan tâm đến hoa hoặc thường
	if (stricmp(ten1, ten2) == 1) // tên 1 > tên 2
		swap(ten1, ten2);

==========================================================================================

[TẬP TIN / TỆP - FILE]

	* Thiết bị lưu trữ - Bộ nhớ thứ cấp (Secondary storage) / Bộ nhớ điện tĩnh/Bộ nhớ bất biến/Bộ nhớ không khả biến (Non-volatile memory): ổ đĩa (HDD, SSD, FDD), đĩa quang (CD, DVD), băng từ, băng giấy đục lỗ, thẻ bấm lỗ...

	* Bộ nhớ tạm thời - Bộ nhớ chính (Primary storage): ROM, RAM (DRAM), Cache (SRAM)...

Tuy cũng được sử dụng để lưu trữ, nhưng mỗi lần tắt máy hoặc cúp điện thì dữ liệu (biến, câu lệnh...) trong RAM sẽ bị mất, không giống như ổ đĩa khi có thể chứa dữ liệu (tập tin...) bền vững theo thời gian.

	- Vì vậy, việc sử dụng tập tin sẽ giúp ta có thể lưu trữ dữ liệu vĩnh viễn nếu muốn và có thể lấy ra sử dụng lại trong tương lai.
	
	- Ta có thể lưu lại dữ liệu từ RAM vào trong ổ đĩa (lúc này dữ liệu sẽ được gọi là tập tin) và có thể nạp dữ liệu từ ổ đĩa ngược lại vào RAM.

	-> Tập tin giúp lưu trữ dữ liệu một cách dài lâu.

*Tập tin (File): nơi lưu trữ thông tin, dữ liệu chuyên nghiệp (Database).

	Ví dụ: khi đăng ký tài khoản ở một Website.

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Tập tin giúp lưu trữ dữ liệu một cách dài lâu và bền vững	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------------------------------------------------------------------

[CHI TIẾT VỀ TẬP TIN]

Tập tin là một tập hợp dữ liệu / thông tin (dưới dạng các Byte / một dãy Byte / nhóm Byte) nằm bền vững trên các thiết bị lưu trữ bền vững:
	- Được sử dụng để chứa dữ liệu / chủ đề (văn bản, hình ảnh, âm thanh...) nhận được từ RAM.
		+ Tuy gồm nhiều Byte, nhưng lại không quan tâm việc có nằm liên tục nhau hay không.
	- Dữ liệu (File) sẽ được đặt cho một cái tên để phân biệt - Tên tập tin (File name).
	- Tên chung cho một nhóm tập tin, nằm ở một đoạn nào đó trên ổ đĩa - Thư mục (Folder / Directory).
		+ Có một địa chủ cụ thể và chi tiết giúp đi đến một tập tin, xuất phát từ tên ổ đĩa và đi theo từng mức của cây thư mục - Đường dẫn (Path).
	
	-> Một dãy các Byte được sử dụng để chứa dữ liệu.

	Ví dụ: có thể xem cấu trúc của một ổ đĩa (trên Windows) giống như một ngăn tủ chứa đồ.

					Tủ ≈ C: ------------------------> ổ đĩa (Drive)
		―――――――――――――――――――――――――――――――――――――――――――――――――
		│		ngan-tren\			│ ------> Thư mục (Folder / Directory)
		│	giay.file, dep.file, tat.file....	│
		│―――――――――――――――――――――――――――――――――――――――――――――――│
		│			│			│
		│			│			│
		│	ngan-trai\	│	ngan-phai\	│
		│	quan.file	│	ao.file ----------------> Tập tin (File)
		│			│			│
		│			│			│
		―――――――――――――――――――――――――――――――――――――――――――――――――

			C:\ngan-trai\quan.file -------------------------> Đường dẫn (Path)

----------------------------------------

* Lưu ý: khi làm việc với đường dẫn (Path).

	- Dấu '\' được sử dụng trong Windows. Nhưng khi lập trình trên Windows, dấu '\' sẽ được hiểu là một kí tự đặc biệt (ví dụ: \n, \t...), vì vậy phải sử dụng "\\" để nói về đường dẫn.

	- Dấu '/' được sử dụng trong Linux, macOS.

----------------------------------------

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Tập tin là một dãy các Byte trên thiết bị lưu trữ,	│
│	được sử dụng để chứa dữ liệu				│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

[NHẬP/XUẤT & ĐỌC/GHI - INPUT/OUTPUT & READ/WRITE]

Cả RAM và ổ đĩa đều có chung nhiệm vụ là để lưu trữ dữ liệu, chỉ khác là ổ đĩa có thể lưu bền vững còn RAM thì không.

	- CPU và RAM có mối quan hệ chặt chẽ khi CPU chỉ giao tiếp và tiến hành xử lý trên RAM.

	- CPU không tương tác trực tiếp với ổ đĩa. Vì vậy, dù dữ liệu đã được lưu bền vững, nhưng nếu muốn CPU thực hiện công việc gì thì ta vẫn phải đưa những câu lệnh tương ứng từ ổ đĩa vào RAM.

Vì vậy, nếu lấy RAM làm trung tâm:

	- Input: đưa dữ liệu từ các thiết bị nhập (ví dụ: bàn phím...) vào trong RAM.
		-> Từ quê lên phố - scanf() / getx()
			(Từ ngoài vào RAM.)

	- Ouput: in dữ liệu đang có trong RAM ra các thiết bị xuất (ví dụ: màn hình...).
		-> Bỏ phố về quê - printf() / putx()
			(Từ RAM ra ngoài.)

Tuy nhiên, RAM không bền vững. Vẫn lấy RAM làm trung tâm, nhưng ta cần có thêm tập tin và ổ đĩa:

	- Ouput / Write: dữ liệu từ RAM được tạo / cất / lưu / ghi ra ổ đĩa (Create / Save / Write | [Ctrl] + [S]).
		-> Đóng vai trò màn hình, in ra ổ đĩa - fprintf() / fputx().
			(Ghi xuống ổ đĩa - Từ RAM ra ngoài.)

	- Input / Read: dữ liệu từ ổ đĩa được mở / đọc / nạp / tải vào RAM (Load / Open / Read | [Ctrl] + [O]).
		-> Đóng vai trò bàn phím, nhập vào RAM - fscanf() / fgetx().
			(Đọc lên RAM - Từ ngoài vào RAM.)

	-> Khi làm việc với tập tin, thuật ngữ I/O & R/W sẽ thường xuyên được sử dụng.
		* I/O (Input/Ouput): Nhập/Xuất.
		* R/W (Read/Write): Đọc/Ghi.

(Khi lấy RAM làm trung tâm, tập tin đóng hai vai trò: vừa là bàn phím, vừa là màn hình.)

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Khi lấy RAM làm trung tâm:			│
│		- Input ≈ Read: đi vào RAM.		│
│		- Output ≈ Write: đi ra khỏi RAM.	│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――

------------------------------------------------------------

[TẬP TIN & CON TRỎ - FILE & POINTER]

Làm việc với tập tin là làm việc với con trỏ, vì:

	- Có nhiều Byte liên tiếp nhau (một dãy / một mảng các Byte) trên ổ đĩa để chứa dữ liệu.
		+ Muốn tương tác được với tập tin thì phải khống chế được đầu dãy Byte.
		+ Luôn luôn cần đến con trỏ để tương tác với mảng Byte.

	- Nhiều Byte liên tiếp nhau ~ Nhiều biến ~ Mảng ~ Con trỏ.

	-> FILE* f: kiểu dữ liệu mới - FILE*, f là tên biến con trỏ - trỏ đầu dãy Byte trên ổ đĩa chứa tập tin được sử dụng để lưu trữ dữ liệu (một đống Byte trên ổ đĩa thì cũng có địa chỉ và vẫn có thể sử dụng con trỏ để trỏ đến như bình thường).
		-> FILE* pointerF sẽ giúp ta tương tác với tập tin (dãy Byte).

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
│	Vì là một dãy các Byte, nên khi tương tác với tập tin,	│
│	bắt buộc phải tương tác với con trỏ			│
―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

--------------------

* Lưu ý: sẽ có tình huống khi không xin được con trỏ.
	- Nghĩa là con trỏ f không thể trỏ được vào dãy Byte của tập tin trên ổ đĩa.
	- Có liên quan đến sự xung đột của hệ điều hành.
	- Lúc này, f == NULL.

----------------------------------------

Tập tin nằm trong ổ đĩa, mà ổ đĩa lại được xem là thiết bị ngoại vi và được hệ điều hành quản lý (thay vì được CPU quản lý). Vì vậy, để tương tác được với tập tin thì ta phải xin phép hệ điều hành.

	* Thông báo về mục đích tương tác với tập tin:

		- Hàm mở (Open) tập tin: fopen(đường-dẫn-chứa-tập-tin, chế-độ-mở);
			(Thông báo với hệ điều hành rằng ta muốn mở tập tin để tương tác.)

			* Chế độ mở (Mode): mở tập tin để làm gì? Những cách để mở?

				- Read (r): mở ra và đưa vào RAM để đọc một tập tin đã có sẵn.

					+ "r+": là chế độ nâng cao, kết hợp vừa mở để đọc và song song với đó là ghi.

				- Write (w): mở ra để chuẩn bị đưa xuống ổ đĩa...
					+ Nếu chưa có thì sẽ tạo mới (xin một vùng Byte để lưu dữ liệu).
					+ Nếu đã có rồi thì xoá sạch dữ liệu cũ, sau đó tạo mới từ đầu và lưu lại.

				- Append (a): mở ra để chuẩn bị đưa xuống ổ đĩa...
					+ Nếu chưa có thì sẽ tạo mới.
					+ Nếu đã có rồi thì giữ nguyên dữ liệu cũ và chỉ lưu nối đuôi.

		- Hàm đóng (Close) tập tin: fclose(biến-con-trỏ-f-trỏ-đến-đầu-dãy-byte);
			(Trả [tập tin???] lại cho hệ điều hành.)

			- fclose() giống việc việc free() con trỏ, kết thúc và trả lại cho hệ điều hành.

	* Thực hiện những thao tác cơ bản để tương tác với tập tin:

		1. Các hàm ghi dữ liệu xuống ổ đĩa (Write ≈ Output).

		2. Các hàm tải dữ liệu lên RAM (Read ≈ Input).

		-> Một loạt các hàm với chữ 'f...(f...)' xuất hiện để làm việc với tập tin (ví dụ: fgetx(), fputx(), fscanf(), fprintf()...).

------------------------------------------------------------

[CÁC LOẠI TẬP TIN]

Dù chỉ là một dãy Byte để lưu thông tin, nhưng tập tin vẫn được chia ra thành hai loại, tương ứng với 2 cách lưu trữ dữ liệu:

----------------------------------------

	1. Tập tin văn bản (Plain Text File): có đơn vị lưu trữ cơ bản là Byte. Mỗi Byte trong ô đĩa sẽ ánh xạ / tương ứng với một kí tự (là mã số ASCII) trong RAM.
		-> Mỗi Byte lưu mã ASCII của một kí tự.

		- Việc mở (Open / Read) tập tin để xem - đưa vào RAM, sẽ lập tức thấy ngay kí tự.
			+ Rất dễ để xem. Vì vậy, có thể xem nội dung bên trong bằng các trình soạn thảo văn bản đơn giản (ví dụ: Notepad, Sublime...), các IDE phức tạp hoặc thậm chí là bằng cửa sổ dòng lệnh (Command Prompt - CMD).
			+ Không bảo mật.
			+ Sẽ rất tốn về mặt lưu trữ.

		- Đơn vị cơ bản để tạo nên tập tin là Byte.
			+ Giống như mảng khi cần lưu bao nhiêu kí tự thì sẽ cần bấy nhiêu Byte.
			+ Nếu như mảng và chuỗi kết thúc bằng kí tự NULL, tập tin sẽ được kết thúc bằng kí tự EOF (End of File).
				* Giá trị trong RAM sẽ là -1 (1111 1111) - số bù 2 (đảo bit dương, sau đó +1).
				* Để đọc tập tin, vì bên trong thường có rất nhiều Byte, nên ta thường sẽ sử dụng vòng lặp (do-while) để đi qua từng kí tự (≈ từng Byte), sau đó lặp lại cho đến khi nào gặp kí tự kết thúc tập tin - EOF.


		* Để tương tác với tập tin văn bản, cần sử dụng các hàm:

		-----------------------------------------------------------------
		| READ (Mở để đọc - Đi vào RAM)	|WRITE (Mở để lưu - Đi khỏi RAM)|
		|-------------------------------+-------------------------------|
		| fgetc(f): đọc từng kí tự,	| fputc(f, kí-tự): ghi vào ổ đĩa|
		| trả về mã ASCII		|				|
		|-------------------------------+-------------------------------|
		| fgets(f...): đọc cả một câu	| fputs(f...): ghi cả một câu	|
		| (kết thúc bằng [Enter])	|				|
		|-------------------------------+-------------------------------|
		| fscanf(f,...): đọc từ tập tin	| fprintf(f...): ghi ra tập tin	|
		| và nạp vào RAM		| và lưu xuống ổ đĩa		|
		-----------------------------------------------------------------

			- Các hàm fgetx() sẽ tự động dời con trỏ sau khi đã đọc một kí tự.

			- Câu lệnh getchar() sẽ nhận một kí tự từ bàn phím và sau đó lập tức gán vào biến mà không cần phải nhấn [Enter] sau mỗi lần gõ giống như scanf().

----------------------------------------

	2. Tập tin nhị phân (Binary File):

		- Tương đương với việc mã hoá.

		- Nhiều Byte mới tạo ra thành một thứ gì đó (ví dụ: một kí tự).

------------------------------------------------------------

[TÓM TẮT CÁC BƯỚC ĐỂ LÀM VIỆC VỚI TẬP TIN]

* Các bước chính để làm việc với tập tin:

	1. Mở tập tin.
		-> Sử dụng hàm fopen(tập-tin-f, chế-độ-mở).

	2. Thao tác: xem-thêm-sửa-xoá.
		-> Sử dụng vòng lặp với điều kiện dừng: EOF & các hàm f...(f...).

	3. Đóng tập tin.
		-> Sử dụng hàm fclose(tập-tin-f).

------------------------------------------------------------

[GHI / LƯU TẬP TIN - WRITE FILE]

Giống như việc lưu (Save) / tạo (Create) một tập tin từ RAM và ghi xuống (Write) ổ đĩa.
	-> Ouput: từ trong RAM đi ra ổ đĩa.

	Ví dụ: Ghi / Lưu - tải từ RAM xuống ổ đĩa

		// Tạo mới một tập tin với dữ liệu là một bài thờ
		// và sau đó lưu xuống ổ đĩa
		void writeFile() {

			// Truyền (mở) tập tin (từ-ấy.txt) ở chế độ (write)
			// và nối đuôi (append) / w: write
			FILE* f = fopen("tu-ay.txt", "a");
			
			// Ghi dữ liệu xuống máy tính - chưa chỉ định nơi lưu
			// (Mặc định sẽ nằm chung trong thư mục chứa code)
			fprintf(f, "Tu ay trong toi bung code gao\n");
			fprintf(f, "Man hinh code do cua con tim\n");
			fprintf(f, "Hon toi ngap tran do-for-if\n");
			fprintf(f, "Rat nhi phan va day tieng do la\n");
			
			// Đóng tập tin
			fclose(f);
			
			printf("The file is created successfully!");
			
		}

------------------------------------------------------------

[ĐỌC / MỞ TẬP TIN - READ FILE]

Giống như việc mở (Open) / tải (Load) một tập tin từ ổ đĩa lên RAM để đọc (Read).

	// Mở một bài thơ đã sẵn có trên ổ đĩa
	// và sau đó in ra màn hình
	Ví dụ: Đọc / Mở - nạp từ ổ đĩa lên RAM

		void readFile() {

			// Truyền (mở) tập tin (từ-ấy.txt) ở chế độ (read)
			FILE* f = fopen("tu-ay.txt", "r");
			
			// Biến để lưu một kí tự,
			// đọc từng chữ trong tập tin
			char ch;
			
			// Vì số kí tự của tập tin luôn luôn có thể thay đổi,
			// nên ta sẽ sử dụng vòng lặp
			// để đọc từng kí tự trong tập tin
			// và sau đó in ra từng kí tự
			// cho đến khi gặp kí tự kết thúc tập tin (-1)
			// End of File (EOF): cuối tập tin
			do {
				// Hàm để đọc từng kí tự trong tập tin,
				// sau đó trả về từng kí tự đã đọc được
				ch = fgetc(f);
				printf("%c", ch);
			} while (ch != EOF);
			
			fclose(f);
			
		}

==========================================================================================

[STRUCT]

Struct (dữ liệu) + các hàm xử lý -> Object trong lập trình hướng đối tượng.

==========================================================================================
==========================================================================================
==========================================================================================

[QUY TRÌNH BIÊN DỊCH ỨNG DỤNG C/C++]

Các bước để từ mã nguồn của C ra được tập tin nhị phân:
	Preprocessing
	-> Scanning
	-> Parsing
	-> Semantic Analyzing
	-> Intermediate Representation Optimizing
	-> Code Generation
	-> Resource Allocation
	-> Assembling
	-> Linking
	-> Binary

--------------------------------------------------------------------------------

Các bước [CHÍNH] để trình biên dịch (compiler) biên dịch một chương trình C/C++:

	-------------------------				---------------------------------
	| Mã nguồn (Source Code)| 	01. Tiền xử lý		| Mã nguồn đã được tiền xử lý	|
	|			|------------------------------>| (Pre-processed Source)	|
	| [.h / .c / .cpp]	| 	(Pre-processor)		| [.i]				|
	-------------------------				---------------------------------
										|
										| 02. Trình biên dịch
										| (Compiler)
										|
										v
	---------------------------------				-------------------------
	| Mã máy (Object file)		|  03. Trình biên dịch hợp ngữ  | Mã Hợp ngữ		|
	| [.o / .obj]			|<------------------------------| (Assembly Code)	|
	| + các thư viện (library)	|	(Assembler)		| [.s]			|
	---------------------------------				-------------------------
			|
			| 04. Trình liên kết
			| (Linker / Link editor)
			|
			v
	---------------------------------
	| Mã thực thi (Executable file)	|
	| Thư viện (Library)		|
	| [.exe / .dll / .a / .app]	|
	---------------------------------

--------------------------------------------------------------------------------

	1. Tiền xử lý (Pre-processing): quá trình biên dịch các mã nguồn thành tập tin (.i). Trong đó:

----------------------------------------

		1.1. Các ghi chú (comment) trong mã nguồn sẽ được loại bỏ, giúp giảm bớt dung lượng của tập tin.

			Ví dụ: những phần ghi chú để giải thích mục đích của câu lệnh sẽ được loại bỏ trong quá trình tiền xử lý

				// Đây là ghi chú trên một dòng
				// (Single line comment / Step comment / In-line comment)

				/*
				 * Đây là ghi chú
				 * trên nhiều dòng,
				 * (Multi-line comment)
				 * thường sử dụng ở đầu chương trình
				 * (Header comment)
				 */

----------------------------------------

		1.2. Những nơi có dấu ở đằng trước '#' - chỉ thị tiền xử lý (preprocessor directive), được sử dụng để hỗ trợ cho những câu lệnh ở phía dưới, sẽ được thay thế.

--------------------

			01. Khai báo thư viện (Source file inclusion): #include
				-> Thay thế bởi hàm định nghĩa trong tập tin .h

				Ví dụ:
					#include<math.h>
					#include<stdio.h>
					#include<iostream>

--------------------

			02. (Macro definition): #define, #undef
				-> Thay thế bởi các khối câu lệnh tương ứng

				Ví dụ 1: #define PI 3.14

				Ví dụ 2:
					// Trước khi tiền xử lý
					#define TABLE_SIZE 100
					int table[TABLE_SIZE];

					// Sau khi tiền xử lý
					int table[100];

--------------------

			03. (Conditional inclusion): #ifdef, #ifndef, #if, #endif, #else, #elif
				-> Thay thế bởi giá trị của điều kiện tương ứng

				Ví dụ: giả sử đã #define TABLE_SIZE 40

					// Kiểm tra xem trong chương trình
					// đã khai báo biến TABLE_SIZE
					// với giá trị là bao nhiêu

					// Nếu trước đó TABLE_SIZE > 200,
					// định nghĩa lại TABLE_SIZE = 200
					#if TABLE_SIZE > 200
					#undef TABLE_SIZE
					#define TABLE_SIZE 200

					// Nếu trước đó TABLE_SIZE < 50,
					// định nghĩa lại TABLE_SIZE = 50
					#elif TABLE_SIZE < 50
					#undef TABLE_SIZE
					#define TABLE_SIZE 50

					// Nếu trước đó 50 <= TABLE_SIZE <= 200,
					// định nghĩa lại TABLE_SIZE = 100
					#else
					#undef TABLE_SIZE
					#define TABLE_SIZE 100
					#endif

					// Sẽ được định nghĩa lại thành 50
					int table [TABLE_SIZE]

--------------------

			04. (Line control): #line
				-> 

--------------------

			05. (Error directive): #error
				-> 

--------------------

			06. (Pragma directive): #pragma
				-> 

------------------------------------------------------------

	2. Biên dịch (Compiling): quá trình biên dịch tập tin tiền xử lý (.i) thành mã hợp ngữ (.s).

------------------------------------------------------------

	3. Hợp ngữ (Assembling): quá trình tạo ra mã máy (.o) hoặc (.obj) từ các tập tin hợp ngữ (.s).

		- Hệ điều hành UNIX (Linux / macOS): tập tin .o
		- Hệ điều hành Windows (Linux / macOS): tập tin .obj

------------------------------------------------------------

	4. Liên kết (Linking): các tập tin mã máy (.o / .obj) và các thư viện đã #include từ bên ngoài vào sẽ được liên kết lại với nhau để tạo ra mã thực thi (.exe / .dll). Đây cũng là quá trình cuối cùng trong quy trình biên dịch tập tin C/C++.
		- Nối các hàm với hàm main() và sau đó tạo ra những mã thực thi tương ứng.
		- Tùy vào cấu hình của chương trình mà tập tin sau khi biên dịch sẽ có phần mở rộng khác nhau.

==========================================================================================
==========================================================================================
==========================================================================================

[KỸ THUẬT CHIA, TÁCH TẬP TIN]

Trong một chương trình C/C++ sẽ có hai loại tập tin chính.

--------------------------------------------------------------------------------

	1. Tập tin thư viện (Header File): *.h

		* Có hai loại thư viện:

			1. Thư viện do ngôn ngữ lập trình cung cấp sẵn (Pre-defined).

				- Khi khai báo (include / import) sẽ sử dụng cặp dấu "<>".

					Ví dụ:
						#include <stdio.h>
						#include <math.h>
						#include <string.h>
						...

			2. Thư viện do người dùng tự định nghĩa (User-define).

				- Khi khai báo (include) sẽ sử dụng cặp dấu nháy đôi ("").

					Ví dụ:
						#include "thuviencuatoi"
						...

				- Bên trong chứa phần khai báo hàm do người dùng tự thiết kế, cụ thể là sẽ chỉ là những nguyên mẫu hàm (Function Prototype).

				- Cho phép tận dụng lại các hàm đã thiết ở nhiều nơi bằng cách khai báo tên của tập tin chứa thư viên, thay vì phải viết lại từ đầu mỗi khi chuyển sang làm việc trên một tập tin mã nguồn mới.
					+ Nếu tại tập tin thư viện đã khai báo sẵn các tập tin mặc định (ví dụ: stdio...) thì nơi sử dụng cũng không cần phải khai báo lại.
					+ Nếu trùng thư viện sẽ dẫn đến lỗi đụng độ thư viện.

				- Giúp che giấu bớt đi những xử lý chi tiết của hàm, chỉ cho biết cách dùng.

				- Các thư viện khác cần sử dụng trong quá trình định nghĩa hàm cũng sẽ được ưu tiên khai báo tại đây thay vì khai báo trong nơi định nghĩa hàm.
				
			=> Giống như mục lục của một quyển sách.

				Ví dụ:
					int coPhaiLaSoNguyenTo(int n);
					void giaiPhuongTrinhBacHai(double a, double b, double c);
					...

--------------------------------------------------------------------------------

	2. Tập tin chứa mã nguồn (Source File): *.c, *.cpp

		- Chứa các định nghĩa / phần thân hàm (hiện thực hoá) của các tập tin thư viện.
			+ Có thể được bên trong một thư mục riêng biệt (Resource File) để tránh nhầm lần với thư mục chứa tập tin main().

			+ Tên tập tin của phần định nghĩa sẽ trùng với tên của tập tin thư viện (*.h), nhưng trước khi bắt đầu tiến hành định nghĩa thì cần phải gọi (include / import) tên của những hàm sẽ được định nghĩa vào.

==========================================================================================

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------
























